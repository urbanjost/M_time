var tipuesearch = {"pages":[{"title":" M_time ","text":"M_time M_time.f90 and associated files CHANGELOG Name M_time - Fortran module for manipulating and presenting time and date values Description M_time(3f) can be used to display Civilian Calendar dates in many formats. In addition, it can manipulate or read many other date representations\nsuch as … Julian Dates Unix Epoch Dates High-level date formatting Ordinal days of the year days of the week ISO-8601 week numbers month and weekday names Julian and Unix Epoch Dates are particularly useful for\nmanipulating dates in simple numeric expressions. The M_time Fortran module complements the DATE_AND_TIME(3f) procedure\n( it is the standard Fortran intrinsic subroutine that returns the\ncurrent date and time in the Gregorian calendar). That is, the primary\nway this module represents dates is as an integer array with the same\nmeaning for elements as defined by the DATE_AND_TIME(3f) routine. The extensive formatting options include showing SYSTEM_CLOCK(3f) and CPU_USAGE(3f) information along with Gregorian date information,\nallowing for the easy incorporation of timing information into program\nmessages. In addition to conventional Civilian Calendar dates, the module supports\nthe ISO-8601 standard. Both a procedural and OOP (Object Oriented Programming) interface are\nprovided. Each routine is accompanied by a man(1) page which includes a sample\nprogram for that procedure. An HTML manual, the source, and example\nprograms are included in the package. Documentation User intro page OOP intro page man-page index BOOK_M_time is a consolidated\n  single-page version of the man-pages for ease in printing and searching( requires javascript ) Furthermore there are actual man-pages that can be installed on ULS (Unix-Like Systems): manpage.tgz and manpage.zip Developer Documentation (experimental) doxygen doxygen output . ford ford output . Download and Build using gmake To build the modules download the github repository, enter the src/\ndirectory and run make(1): git clone https : // github . com / urbanjost / M_time . git cd M_time / src make clean # change Makefile if not using one of the listed compilers # COMPILER_NAME = { ifort , nvfortran , or gfortran } make $C OMPILER_NAME # optionally make help # see other developer options make run # run all the demo programs from the man - pages This will compile the M_time module and optionally build all the example programs from\nthe document pages (in the example/ sub-directory) and run the unit tests. Download and Build using fpm To download the github repository and build and test it with fpm : git clone https://github.com/urbanjost/M_time.git cd M_time # on MSWindows: fpm test -flag \"-D _WIN32\" # on other platforms fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_time = { git = \"https://github.com/urbanjost/M_time.git\" } Demo Programs Each man-page contains a small sample program that has been extracted\nand placed in the example/ directory.  The small example programs\ndemonstrate how easily you can generate a variety of output formats: Sun , Jan 5 th , 2020 10 : 48 : 33 AM UTC - 05 : 00 Sunday , January 5 th , 2020 10 : 48 : 53 AM UTC - 05 : 00 January 2020 Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Julian Date is 2458854 . 1545532290 Unix Epoch time is 1578238955 . 5700049 ISO - 8601 Week : 2020 - W01 - 7 Day of year is : 5 for year 2020 days in year is : 366 weekday = 7 day = Sunday Easter day : the 12 th day of April in the year of our Lord 2020 In particular, the example program “now” easily lets you try out various\noptions. With no options it displays allowed formats. For example: ./now year month day\n  ./now 'julian epoch ordinal'\n  ./now 'The year is %Y and the month is %M (%L) %h:%m:%s'\n  ./now formal\n\n   20200105\n   2458854 1578240100 005\n   The year is 2020 and the month is 01 (January) 11:01:39\n   The 5th of January 2020 Definitions A “date_and_time” array “DAT” has the same format as the array of\nvalues generated by the Fortran intrinsic DATE_AND_TIME(3f). That is,\nit is an 8-element integer array containing year, month, day, Time zone\ndifference from UTC in minutes, hour, minutes, seconds, and milliseconds\nof the second. This array represents a date on the Proleptic Gregorian\nCalendar. The Proleptic Gregorian Calendar assumes the Gregorian Calendar\nexisted back to the beginning of the Julian Day calendar (4713 BC). This\nmeans historic dates will often be confused, as the Julian Calendar was\nused in the USA until 1752-09-03, for example. The Gregorian Calendar was\nformally decreed on 1582-10-15 but was not adapted in many countries. The\nJulian Calendar was first used around 45 BC. Note that the Proleptic\nGregorian Calendar includes a year zero (0). It is frequently used in\ncomputer software to simplify the handling of older dates. For example,\nit is the calendar used by MySQL, SQLite, PHP, CIM, Delphi, Python and\nCOBOL. The Proleptic Gregorian Calendar is explicitly required for all\ndates before 1582 by ISO 8601:2004 (clause 4.3.2.1 The Gregorian calendar)\nif the partners to information exchange agree. Unix Epoch Time (UET) is defined as the number of seconds since\n00:00:00 on January 1st. 1970, UTC. A JED is defined as a Julian Ephemeris Date . JED days start at\nnoon (not at midnight). 4713-01-01 BC at noon is defined as JED 0.0. If you are not familiar with them, in this context Julian Dates and Unix\nEpoch Times are scalar numbers that allow for easy computations using\ndates (to go back one day just subtract one from a Julian Date, for\nexample). Since these values are generally not considered intelligible,\nroutines are included to convert between these scalar values and the\ndate array so human-readable results can be obtained. Coordinated Universal Time (French: Temps universel coordonn’\be),\nabbreviated as UTC , is the primary time standard by which the world\nregulates clocks and time. It is within about 1 second of mean solar\ntime at 0o longitude;[1] it does not observe daylight saving time. It\nis one of several closely related successors to Greenwich Mean Time\n(GMT). For most purposes, UTC is considered interchangeable with GMT,\nbut GMT is no longer precisely defined by the scientific community. Limitations Like most collections of date and time procedures M_time is not a\nhigh- precision library that accounts internally for leap seconds and\nrelativistic effects. M_time(3f) is intended for use in the recent era and is not appropriate\nfor use with historical dates that used some other calendar scheme such\nas the Julian Calendar. That is, you have to remember to account for\nconversions to other calendar systems when using historical dates. When Daylight Savings is in effect calculations will generally be correct,\nas the date model includes a timezone value; but you are responsible for\nensuring dates you create use the correct timezone value or otherwise\naccount for Daylight Savings Time as needed. Currently, dates are manipulated using the current system timezone, which\ncan typically be set using the environment variable TZ. So if you desire\nto set the default timezone you generally set the environment variable before executing your program. This is compatible with current observed\nbehavior for the intrinsic procedure DATE_AND_TIME(3f) with compilers I\nhave tested with, but does not seem to be a specified behavior as far as\nthe standard is concerned. That is, DATE_AND_TIME(3f) returns a vector\nthat contains a current time zone, but does not specify how a current\ntime zone can be explicitly set.  Since this library is intentionally\ndesigned to complement DATE_AND_TIME(3f) it adopts the same behavior. See Also The ISO-8601 standard is often used for business-related transactions. There are (of course) the C/C++ intrinsics which provide much of the same\nfunctionality that should be bindable to Fortran via the ISO_C_BINDING\nmodule. If you are looking for a high-precision Fortran library that is well\ntested for manipulating dates I would suggest looking at the NASA\nSPICElib library.  If you care about Leap Seconds, Orbital Mechanics,\nGPS/Satellite communications, and Astronomy it is worth a look. The Fortran Wiki fortranwiki.org contains\ninformation on other libraries and modules that provide date-time\nprocedures. References Gregorian Calendar(Wikipedia) Fortran Package Manager fpm(1) registry github actions Developer Info John S. Urban","tags":"home","loc":"index.html"},{"title":"date_time – M_time ","text":"type, public :: date_time Contents Constructor date_time Type-Bound Procedures datout delta epoch format init julian operator(+) operator(-) operator(-) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) ordinal weekday Constructor public interface date_time private function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (:) Return Value type( date_time ) Type-Bound Procedures procedure, public :: datout => dt2d_ private function dt2d_(self) result(dat) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value integer(8) procedure, public :: delta private function delta(self, year, month, day, tz, hour, minute, second, millisecond, week, duration) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: tz integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: week character(len=*), intent(in), optional :: duration Return Value type( date_time ) procedure, public :: epoch => epoch_ private function epoch_(self) result(epoch_seconds) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value real(kind=realtime) procedure, public :: format private function format(self, fmt) result(string) usually used in a WRITE(3f) or PRINT(3f) so should not write output Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable procedure, public :: init => init_dt private subroutine init_dt(self, year, month, day, tz, hour, minute, second, millisecond, type, dat) Arguments Type Intent Optional Attributes Name class( date_time ) :: self integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: tz integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond character(len=*), intent(in), optional :: type integer, intent(in), optional :: dat (8) procedure, public :: julian => julian_ private function julian_(self) result(julian_days) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value real(kind=realtime) generic, public :: operator(+) => plus_seconds private function plus_seconds(self, seconds) result(dattim) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self real(kind=realtime), intent(in) :: seconds Return Value type( date_time ) generic, public :: operator(-) => minus_seconds private function minus_seconds(self, seconds) result(dattim) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self real(kind=realtime), intent(in) :: seconds Return Value type( date_time ) generic, public :: operator(-) => minus_date_time private function minus_date_time(self, other) result(seconds) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value real(kind=realtime) generic, public :: operator(/=) => ne private function ne(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(<) => lt private function lt(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(<=) => le private function le(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(==) => eq private function eq(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(>) => gt private function gt(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(>=) => ge private function ge(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical procedure, public :: ordinal private function ordinal(self) result(ordinal_days) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value integer procedure, public :: weekday private function weekday(self) result(iday) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value integer","tags":"","loc":"type/date_time.html"},{"title":"test_suite_M_time – M_time","text":"subroutine test_suite_M_time() Uses M_time M_verify iso_c_binding call unit_check_start(‘ephemeris      ‘,SAME//’ “ephemeris position of planets for adjusting an equatorial telescope” ‘)\ncall test_ephemeris() Arguments None Contents Variables SAME dat ierr Functions str2arr Subroutines put_environment_variable showme test_box_month test_d2j test_d2o test_d2u test_d2w test_date_to_julian test_date_to_unix test_days2sec test_dow test_easter test_fmtdate test_fmtdate_usage test_guessdate test_j2d test_julian_to_date test_mo2d test_mo2v test_moon_fullness test_now test_now_ex test_o2d test_ordinal_seconds test_ordinal_to_date test_phase_of_moon test_sec2days test_u2d test_unix_to_date test_v2mo test_w2d Source Code test_suite_M_time Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: SAME = '-library libGPF -section 3 -description' no not use M_system version or will create a circular dependency integer, public :: dat (8) integer, public :: ierr Functions pure function str2arr(string) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=c_char,len=1)(len(string)+1) Subroutines subroutine put_environment_variable(NAME, VALUE, STATUS) Arguments Type Intent Optional Attributes Name character(len=*) :: NAME character(len=*) :: VALUE integer, intent(out), optional :: STATUS subroutine showme(string) Arguments Type Intent Optional Attributes Name character(len=*) :: string subroutine test_box_month() Arguments None subroutine test_d2j() Arguments None subroutine test_d2o() use M_time, only : d2o Arguments None subroutine test_d2u() use M_time, only : d2u Arguments None subroutine test_d2w() Arguments None subroutine test_date_to_julian() use M_time,    only : date_to_julian, now, fmtdate, date_to_unix, realtime Arguments None subroutine test_date_to_unix() Arguments None subroutine test_days2sec() use M_time, only  : days2sec, realtime Arguments None subroutine test_dow() use M_time, only : dow Arguments None subroutine test_easter() use M_time,  only : easter Arguments None subroutine test_fmtdate() use M_time, only: guessdate, fmtdate Arguments None subroutine test_fmtdate_usage() Arguments None subroutine test_guessdate() use M_time, only: guessdate, w2d, d2w, fmtdate Arguments None subroutine test_j2d() Arguments None subroutine test_julian_to_date() use M_time, only : julian_to_date, fmtdate, realtime Arguments None subroutine test_mo2d() Arguments None subroutine test_mo2v() use M_time,     only: mo2v Arguments None subroutine test_moon_fullness() Arguments None subroutine test_now() Arguments None subroutine test_now_ex() Arguments None subroutine test_o2d() use M_time, only : o2d, ordinal_to_date, d2o Arguments None subroutine test_ordinal_seconds() use M_time, only : ordinal_seconds Arguments None subroutine test_ordinal_to_date() use M_time, only : o2d, ordinal_to_date, d2o Arguments None subroutine test_phase_of_moon() Arguments None subroutine test_sec2days() use M_time, only: sec2days Arguments None subroutine test_u2d() Arguments None subroutine test_unix_to_date() Arguments None subroutine test_v2mo() Arguments None subroutine test_w2d() use M_time, only: w2d Arguments None Source Code subroutine test_suite_M_time use M_verify , only : unit_check , unit_check_good , unit_check_bad , unit_check_done , unit_check_start , unit_check_msg , unit_check_level use M_verify , only : unit_check_stop use , intrinsic :: iso_c_binding , only : c_int , c_char , c_null_char use M_time implicit none integer :: dat ( 8 ) integer :: ierr character ( len =* ), parameter :: SAME = '-library libGPF -section 3 -description' !! no not use M_system version or will create a circular dependency call put_environment_variable ( 'TZ' , 'America/New_York' , ierr ) ! some of the test values assume EST call put_environment_variable ( 'TZ' , 'UTC+04:00' , ierr ) ! some of the test values assume EST call unit_check_msg ( 'M_time' , 'This section contains unit tests for procedures in the M_time(3f) module.' ) call unit_check_start ( 'box_month      ' , SAME // ' \"print specified month into character array\" ' ) call test_box_month () call unit_check_start ( 'd2j            ' , SAME // ' \"Convert date array to Julian Date\" ' ) call test_d2j () call unit_check_start ( 'd2o            ' , SAME // ' \"Converts date-time array to Ordinal day\" ' ) call test_d2o () call unit_check_start ( 'd2u            ' , SAME // ' \"Convert date array to Unix Time\" ' ) call test_d2u () call unit_check_start ( 'd2w            ' , SAME // ' \"Calculate iso-8601 Week-numbering year date yyyy-Www-d\" ' ) call test_d2w () call unit_check_start ( 'date_to_julian ' , SAME // ' \"Converts Proleptic Gregorian date array to Julian Date\" ' ) call test_date_to_julian () call unit_check_start ( 'date_to_unix   ' , SAME // ' \"Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970, UTC)\" ' ) call test_date_to_unix () call unit_check_start ( 'days2sec       ' , SAME // ' \"converts string D-HH:MM:SS to seconds from small to large\" ' ) call test_days2sec () call unit_check_start ( 'dow            ' , SAME // ' \"Return the day of the week\" ' ) call test_dow () call unit_check_start ( 'easter         ' , SAME // ' \"Determine month and day Easter falls on for given year\" ' ) call test_easter () !!call unit_check_start('ephemeris      ',SAME//' \"ephemeris position of planets for adjusting an equatorial telescope\" ') !!call test_ephemeris() call unit_check_start ( 'fmtdate        ' , SAME // ' \"given date array return date as string using format\" ' ) call test_fmtdate () call unit_check_start ( 'fmtdate_usage  ' , SAME // ' \"display macros recognized by fmtdate(3f)\" ' ) call test_fmtdate_usage () call unit_check_start ( 'guessdate      ' , SAME // ' \"Reads in a date, in various formats\" ' ) call test_guessdate () call unit_check_start ( 'j2d            ' , SAME // ' \"Convert Julian Date to date array\" ' ) call test_j2d () call unit_check_start ( 'julian_to_date ' , SAME // ' \"Converts Julian Date to (year, month, day, hour, minute, second)\" ' ) call test_julian_to_date () call unit_check_start ( 'mo2d           ' , SAME // ' \"return date array for beginning of given month name in specified year\" ' ) call test_mo2d () call unit_check_start ( 'mo2v           ' , SAME // ' \"given month as name return month number (1-12) of that month\" ' ) call test_mo2v () call unit_check_start ( 'moon_fullness  ' , SAME // ' \"return name for phase of moon for given date\" ' ) call test_moon_fullness () call unit_check_start ( 'now            ' , SAME // ' \"return string representing current time given format\" ' ) call test_now () call unit_check_start ( 'now_ex         ' , SAME // ' \"use of now(3f) outside of a module\" ' ) call test_now_ex () call unit_check_start ( 'o2d            ' , SAME // ' \"given ordinal day of year return date array, Jan 1st=1\" ' ) call test_o2d () call unit_check_start ( 'ordinal_to_date' , SAME // ' \"given ordinal day of year return date array, Jan 1st=1\" ' ) call test_ordinal_to_date () call unit_check_start ( 'phase_of_moon  ' , SAME // ' \"percentage of moon phase from new to full\" ' ) call test_phase_of_moon () call unit_check_start ( 'sec2days       ' , SAME // ' \"converts seconds to string D-HH:MM:SS\" ' ) call test_sec2days () call unit_check_start ( 'u2d            ' , SAME // ' \"Convert Unix Time to date array\" ' ) call test_u2d () call unit_check_start ( 'unix_to_date   ' , SAME // ' \"Converts Unix Time to date array\" ' ) call test_unix_to_date () call unit_check_start ( 'v2mo           ' , SAME // ' \"returns the month name of a Common month\" ' ) call test_v2mo () call unit_check_start ( 'w2d            ' , SAME // ' \"Given iso-8601 Week-numbering year date yyyy-Www-d calculate date\" ' ) call test_w2d () call unit_check_stop ( 'M_time tests completed' ) contains !=================================================================================================================================== #ifndef _WIN32 subroutine put_environment_variable ( name , value , status ) !  This is an private copy of the set_environment_variable routine(3f) routine from !  M_system.FF that is duplicated in order to prevent a circular dependency. ! ident_33=\"@(#)M_system::put_environment_variable(3f): call setenv(3c) to set environment variable\" character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS integer :: loc_err character ( kind = c_char , len = 1 ), allocatable :: temp_chars1 (:) character ( kind = c_char , len = 1 ), allocatable :: temp_chars2 (:) interface integer ( kind = c_int ) function c_setenv ( c_name , c_VALUE ) bind ( C , NAME = \"setenv\" ) import c_int , c_char character ( kind = c_char ) :: c_name ( * ) character ( kind = c_char ) :: c_VALUE ( * ) end function end interface temp_chars1 = str2arr ( trim ( NAME )) temp_chars2 = str2arr ( VALUE ) loc_err = c_setenv ( temp_chars1 , temp_chars2 ) if ( present ( STATUS )) STATUS = loc_err end subroutine put_environment_variable #else subroutine put_environment_variable ( name , value , status ) character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS write ( * , * ) '<WARNING>put_environment_variable is not working on this platform' if ( present ( STATUS )) STATUS = - 1 end subroutine put_environment_variable #endif !=================================================================================================================================== pure function str2arr ( string ) result ( array ) ! ident_34=\"@(#)M_system::str2arr(3fp): function copies string to null terminated char array\" character ( len =* ), intent ( in ) :: string character ( len = 1 , kind = c_char ) :: array ( len ( string ) + 1 ) integer :: i do i = 1 , len_trim ( string ) array ( i ) = string ( i : i ) enddo array ( size ( array )) = c_null_char end function str2arr !=================================================================================================================================== !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_julian () !!use M_time,    only : date_to_julian, now, fmtdate, date_to_unix, realtime implicit none real ( kind = realtime ) :: julian integer :: ierr call unit_check_start ( 'date_to_julian' , msg = 'Checking Julian Date' ) ! assume if got here passed checks call date_to_julian ( [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , abs ( julian - 244058 7.5d0 ). lt . 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) call date_to_julian ( [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) call date_to_julian ( [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) call date_to_julian ( [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) call date_to_julian ( [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) call date_to_julian ( [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_check_done ( 'date_to_julian' ) end subroutine test_date_to_julian !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_julian_to_date () !!use M_time, only : julian_to_date, fmtdate, realtime implicit none real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected call unit_check_start ( 'julian_to_date' ) juliandate = 245758 9.129d0 ! set sample Julian Date call julian_to_date ( juliandate , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_check ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ). eq . expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_check ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ). eq . expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_check ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ). eq . expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_check_done ( 'julian_to_date' ) end subroutine test_julian_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_unix real ( kind = realtime ) :: unixtime integer :: ierr call unit_check_start ( 'date_to_unix' ) call date_to_unix ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ], unixtime , ierr ) call unit_check ( 'd2u' , abs ( unixtime - 1490766407 ). lt . 0.001 , d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'date_to_unix' ) end subroutine test_date_to_unix !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unix_to_date call unit_check_start ( 'unix_to_date' ) call unit_check ( 'unix_to_date' , all ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]. eq . u2d ( 1490766407 )), msg = d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'unix_to_date' ) end subroutine test_unix_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2o () !!use M_time, only : d2o implicit none integer :: iday , iyear , omonth , oday , rday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme call unit_check_start ( 'd2o' ) do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) rday = d2o ( dat ) call unit_check ( 'd2o' , iday . eq . rday , msg = tests ( i )) enddo call unit_check_done ( 'd2o' ) end subroutine test_d2o !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_seconds () !!use M_time, only : ordinal_seconds implicit none integer :: rday call unit_check_start ( 'ordinal_seconds' ) rday = ordinal_seconds () / ( 60 * 60 * 24 ) call unit_check ( 'ordinal_seconds' , rday . eq . d2o (), rday , d2o ()) call unit_check_done ( 'ordinal_seconds' ) end subroutine test_ordinal_seconds !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_to_date () !!use M_time, only : o2d, ordinal_to_date, d2o implicit none integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme call unit_check_start ( 'ordinal_to_date' ) do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday call ordinal_to_date ( iyear , iday , dat ) call unit_check ( 'ordinal_to_date' , dat ( 2 ). eq . omonth . and . dat ( 3 ). eq . oday , 'year' , iyear , 'ordinal' , iday ) enddo call unit_check_done ( 'ordinal_to_date' ) end subroutine test_ordinal_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_o2d () !!use M_time, only : o2d, ordinal_to_date, d2o implicit none integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme call unit_check_start ( 'o2d' ) do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) call unit_check ( 'o2d' , dat ( 1 ). eq . iyear . and . dat ( 2 ). eq . omonth . and . dat ( 3 ). eq . oday , msg = tests ( i )) enddo call unit_check_done ( 'o2d' ) end subroutine test_o2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_v2mo call unit_check_start ( 'v2mo' ) call unit_check ( 'v2mo' , v2mo ( 1 ). eq . 'January' , msg = 'January' ) call unit_check ( 'v2mo' , v2mo ( 2 ). eq . 'February' , msg = 'February' ) call unit_check ( 'v2mo' , v2mo ( 3 ). eq . 'March' , msg = 'March' ) call unit_check ( 'v2mo' , v2mo ( 4 ). eq . 'April' , msg = 'April' ) call unit_check ( 'v2mo' , v2mo ( 5 ). eq . 'May' , msg = 'May' ) call unit_check ( 'v2mo' , v2mo ( 6 ). eq . 'June' , msg = 'June' ) call unit_check ( 'v2mo' , v2mo ( 7 ). eq . 'July' , msg = 'July' ) call unit_check ( 'v2mo' , v2mo ( 8 ). eq . 'August' , msg = 'August' ) call unit_check ( 'v2mo' , v2mo ( 9 ). eq . 'September' , msg = 'September' ) call unit_check ( 'v2mo' , v2mo ( 10 ). eq . 'October' , msg = 'October' ) call unit_check ( 'v2mo' , v2mo ( 11 ). eq . 'November' , msg = 'November' ) call unit_check ( 'v2mo' , v2mo ( 12 ). eq . 'December' , msg = 'December' ) call unit_check_done ( 'v2mo' ) end subroutine test_v2mo !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2d integer :: dat ( 8 ) call unit_check_start ( 'mo2d' ) call date_and_time ( values = dat ) call unit_check ( 'mo2d' , all ( mo2d ( 'january' , 2019 ). eq .[ 2019 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'January    2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'february' , 2019 ). eq .[ 2019 , 02 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'February   2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'march' , 2019 ). eq .[ 2019 , 03 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'March      2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'april' , 2019 ). eq .[ 2019 , 04 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'April      2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'may' , 2019 ). eq .[ 2019 , 05 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'May        2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'june' , 2019 ). eq .[ 2019 , 06 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'June       2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'july' , 2019 ). eq .[ 2019 , 07 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'July       2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'august' , 2019 ). eq .[ 2019 , 08 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'August     2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'september' , 2019 ). eq .[ 2019 , 09 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'September  2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'october' , 2019 ). eq .[ 2019 , 10 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'October    2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'november' , 2019 ). eq .[ 2019 , 11 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'November   2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'december' , 2019 ). eq .[ 2019 , 12 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'December   2019' ) call unit_check_done ( 'mo2d' ) end subroutine test_mo2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2v () !!use M_time,     only: mo2v call unit_check_start ( 'mo2v' ) call unit_check ( 'mo2v' , mo2v ( 'jan' ) . eq . 1 , msg = 'Check January' ) call unit_check ( 'mo2v' , mo2v ( 'Feb' ) . eq . 2 , msg = 'Check February' ) call unit_check ( 'mo2v' , mo2v ( 'March' ) . eq . 3 , msg = 'Check March' ) call unit_check ( 'mo2v' , mo2v ( 'APR' ) . eq . 4 , msg = 'Check April' ) call unit_check ( 'mo2v' , mo2v ( 'may' ) . eq . 5 , msg = 'Check May' ) call unit_check ( 'mo2v' , mo2v ( 'jun' ) . eq . 6 , msg = 'Check Jun' ) call unit_check ( 'mo2v' , mo2v ( 'july' ) . eq . 7 , msg = 'Check July' ) call unit_check ( 'mo2v' , mo2v ( 'Aug' ) . eq . 8 , msg = 'Check August' ) call unit_check ( 'mo2v' , mo2v ( 'Sept' ) . eq . 9 , msg = 'Check September' ) call unit_check ( 'mo2v' , mo2v ( 'Oct' ) . eq . 10 , msg = 'Check October' ) call unit_check ( 'mo2v' , mo2v ( 'Nov' ) . eq . 11 , msg = 'Check November' ) call unit_check ( 'mo2v' , mo2v ( 'December' ) . eq . 12 , msg = 'Check December' ) call unit_check ( 'mo2v' , mo2v ( 'jax' ) . eq . 1 , msg = 'Check \"jax\"' ) call unit_check ( 'mo2v' , mo2v ( 'ja' ) . eq . 1 , msg = 'Check \"ja\"' ) call unit_check ( 'mo2v' , mo2v ( 'j' ) . eq . - 1 , msg = 'Check \"j\"' ) call unit_check ( 'mo2v' , mo2v ( '' ) . eq . - 1 , msg = 'Check \"\"' ) call unit_check_done ( 'mo2v' ) ! assume if got here passed checks end subroutine test_mo2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now call unit_check_start ( 'now' ) call unit_check_done ( 'now' ) end subroutine test_now !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate !!use M_time, only: guessdate, fmtdate implicit none character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] call unit_check_start ( 'fmtdate' ) do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment if ( unit_check_level . gt . 0 ) then call unit_check_msg ( 'fmtdate' , 'GIVEN:' // trim ( date1 ) // ' ' // trim ( comment )) endif call guessdate ( date1 , dat ) ! convert date string to DAT call unit_check ( 'fmtdate' , fmtdate ( dat , 'year-month-day' ). eq . trim ( date2 ), 'GOT' , fmtdate ( dat , 'year-month-day' ), 'expected' , date2 ) ! convert DAT to ISO week date, all generated dates should match ISO week date call unit_check ( 'fmtdate' , fmtdate ( dat , \"%I\" ). eq . iso_week_date , msg = iso_week_date ) enddo call unit_check_done ( 'fmtdate' ) end subroutine test_fmtdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate_usage call unit_check_start ( 'fmtdate_usage' ) call unit_check_done ( 'fmtdate_usage' ) end subroutine test_fmtdate_usage !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_guessdate !!use M_time, only: guessdate, w2d, d2w, fmtdate implicit none character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i call unit_check_start ( 'guessdate' ) ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment call guessdate ( date1 , dat ) ! convert date string to DAT call unit_check ( 'guessdate' ,& & fmtdate ( dat , \"%I\" ). eq . iso_week_date , 'input' , date1 , 'produced' , fmtdate ( dat , \"%I\" ), 'expected' , iso_week_date ) call unit_check ( 'guessdate' ,& & fmtdate ( dat , \"year-month-day\" ). eq . date2 , 'input' , date1 , 'produced' , fmtdate ( dat , \"year-month-day\" ), 'expected' , date2 ) enddo call unit_check_done ( 'guessdate' ) end subroutine test_guessdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dow !!use M_time, only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call unit_check_start ( 'dow' ) call date_and_time ( values = dat ) call dow ([ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ], weekday , day , ierr ) call unit_check ( 'dow' , day . eq . 'Saturday' . and . weekday . eq . 6 , msg = 'Saturday' ) call unit_check_done ( 'dow' ) end subroutine test_dow !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_w2d !!use M_time, only: w2d implicit none character ( len = 372 ), allocatable :: line (:) integer :: y , m , d integer :: iso_year integer :: iso_week integer :: iso_weekday integer :: dat ( 8 ) integer :: i call unit_check_start ( 'w2d' ) ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' 2005 01 01  2004 53 6   ' , & & ' 2005 01 02  2004 53 7   ' , & & ' 2005 12 31  2005 52 6   ' , & & ' 2007 01 01  2007 01 1   ' , & & ' 2007 12 30  2007 52 7   ' , & & ' 2007 12 31  2008 01 1   ' , & & ' 2008 01 01  2008 01 2   ' , & & ' 2008 12 28  2008 52 7   ' , & & ' 2008 12 29  2009 01 1   ' , & & ' 2008 12 30  2009 01 2   ' , & & ' 2008 12 31  2009 01 3   ' , & & ' 2009 01 01  2009 01 4   ' , & & ' 2009 12 31  2009 53 4   ' , & & ' 2010 01 01  2009 53 5   ' , & & ' 2010 01 02  2009 53 6   ' , & & ' 2010 01 03  2009 53 7   ' , & & '                          ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) y , m , d , iso_year , iso_week , iso_weekday call w2d ( iso_year , iso_week , iso_weekday , dat ) ! convert ISO week date to DAT call unit_check ( 'w2d' , dat ( 1 ). eq . y . and . dat ( 2 ). eq . m . and . dat ( 3 ). eq . d , msg = line ( i )) ! all should match enddo call unit_check_done ( 'w2d' ) end subroutine test_w2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_box_month integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) character ( len = 21 ) :: mnth ( 8 ) dat = [ 2016 , 07 , 01 , - 240 , 12 , 0 , 0 , 0 ] mnth = [ & '      July 2016      ' , & 'Mo Tu We Th Fr Sa Su ' , & '             1  2  3 ' , & ' 4  5  6  7  8  9 10 ' , & '11 12 13 14 15 16 17 ' , & '18 19 20 21 22 23 24 ' , & '25 26 27 28 29 30 31 ' , & '                     ' ] call unit_check_start ( 'box_month' ) call box_month ( dat , calendar ) if ( unit_check_level . gt . 0 ) then write ( * , '(a)' ) calendar write ( * , '(a)' ) mnth endif call unit_check ( 'box_month' , all ( calendar . eq . mnth ), msg = 'July 2016' ) call unit_check_done ( 'box_month' ) end subroutine test_box_month !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2j real ( kind = realtime ) :: julian call unit_check_start ( 'd2j' ) call unit_check_start ( 'd2j' , msg = 'Checking Julian Date' ) ! assume if got here passed checks julian = d2j ( [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , abs ( julian - 244058 7.5d0 ). lt . 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) julian = d2j ( [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) julian = d2j ( [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) julian = d2j ( [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) julian = d2j ( [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) julian = d2j ( [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_check_done ( 'd2j' ) end subroutine test_d2j !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_j2d real ( kind = realtime ) :: juliandate character ( len = :), allocatable :: expected call unit_check_start ( 'j2d' ) juliandate = 245758 9.129d0 ! set sample Julian Date expected = '2016-07-19 11:05:45' call unit_check ( 'j2d' , fmtdate ( j2d ( juliandate ), 'year-month-day hour:minute:second' ). eq . expected , & & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( j2d ( juliandate ), 'year-month-day hour:minute:second' )) ! go back one day expected = '2016-07-18 11:05:45' call unit_check ( 'j2d' , fmtdate ( j2d ( juliandate - 1.0d0 ), 'year-month-day hour:minute:second' ). eq . expected , & & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( j2d ( juliandate - 1.0d0 ), 'year-month-day hour:minute:second' )) ! go forward one day expected = '2016-07-20 11:05:45' call unit_check ( 'j2d' , fmtdate ( j2d ( juliandate + 1.0d0 ), 'year-month-day hour:minute:second' ). eq . expected , & & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( j2d ( juliandate + 1.0d0 ), 'year-month-day hour:minute:second' )) call unit_check_done ( 'j2d' ) end subroutine test_j2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2u () !!use M_time, only : d2u implicit none !  Note that time zones are usually -HHMM or -HH:MM and not MM, which is what the DAT array uses !  Comparing to Unix date(1) command: !    date --date \"Wed Mar 29 01:46:47 EDT 2017\" +%s      ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 2017\" +%s          ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 -400 2017\" +%s     ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-400 2017\" +%s  ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-4:00 2017\" +%s ! 1490766407 call unit_check_start ( 'd2u' ) call unit_check ( 'd2u' , nint ( d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) + 0.5 ). eq . 1490766407 , d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'd2u' ) end subroutine test_d2u !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_u2d call unit_check_start ( 'u2d' ) call unit_check ( 'u2d' , all ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]. eq . u2d ( 1490766407 )),& & d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'u2d' ) end subroutine test_u2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sec2days () !!use M_time, only: sec2days implicit none call unit_check_start ( 'sec2days' ) call unit_check ( 'sec2days' , sec2days ( 129860 ). eq . '1-12:04:20' , '129860 is 1-12:04:20' ) call unit_check ( 'sec2days' , sec2days ( 8000 0.0d0 ). eq . '0-22:13:20' , '80000.0d0 is 0-22:13:20' ) call unit_check ( 'sec2days' , sec2days ( 80000 , crop = . true .). eq . '22:13:20' , '80000 is 22:13:20' ) call unit_check ( 'sec2days' , sec2days ( '1day 2hr 3 min 4s' ). eq . '1-02:03:04' , '1day 2hr 3 min 4s is 1-02:03:04' ) call unit_check_done ( 'sec2days' ) end subroutine test_sec2days !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_days2sec () !!use M_time, only  : days2sec, realtime implicit none call unit_check_start ( 'days2sec' ) call unit_check ( 'days2sec' , nint ( days2sec ( '1' )). eq . 1 , 'expected' , 1 , 'got' , nint ( days2sec ( '1' ))) call unit_check ( 'days2sec' , nint ( days2sec ( '1:00' )). eq . 60 , 'expected' , 60 , 'got' , nint ( days2sec ( '1:00' ))) call unit_check ( 'days2sec' , nint ( days2sec ( '1:00:00' )). eq . 3600 , 'expected' , 3600 , 'got' , nint ( days2sec ( '1:00:00' ))) call unit_check ( 'days2sec' , nint ( days2sec ( '1-00:00:00' )). eq . 86400 , 'expected' , 86400 , 'got' , nint ( days2sec ( '1-00:00:00' ))) call unit_check ( 'days2sec' ,& & nint ( days2sec ( '1d2h 3.0 minutes 4sec' )). eq . 93784 , 'expected' , 1 , 'got' , nint ( days2sec ( '1d2h 3.0 minutes 4sec' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1-12:04:20              ' )) . eq . 129860 , & & 'expected' , 129860 , 'got' , nint ( days2sec ( '1.12:03:20' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1.5 days                ' )) . eq . 129600 , & & 'expected' , 129600 , 'got' , nint ( days2sec ( '1.5 days' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) . eq . 145800 , & & 'expected' , 145800 , 'got' , nint ( days2sec ( '1.5 days 4hrs 30minutes' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1.5d                    ' )) . eq . 129600 , & & 'expected' , 129600 , 'got' , nint ( days2sec ( '1.5d' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1d2h3m4s                ' )) . eq . 93784 , & & 'expected' , 93784 , 'got' , nint ( days2sec ( '1d2h3m4s' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1d1d1d                  ' )) . eq . 259200 , & & 'expected' , 259200 , 'got' , nint ( days2sec ( '1d1d1d' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 4d-12h                  ' )) . eq . 302400 , & & 'expected' , 302400 , 'got' , nint ( days2sec ( '4d-12h' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 3  d  1 2   h           ' )) . eq . 302400 , & & 'expected' , 302400 , 'got' , nint ( days2sec ( '3 d 1 s  h' ))) call unit_check_done ( 'days2sec' ) end subroutine test_days2sec !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_phase_of_moon integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_check_start ( 'phase_of_moon' ) call unit_check ( 'phase_of_moon' , phase_of_moon ( dat ). eq . 'Waning crescent' ) call unit_check_done ( 'phase_of_moon' ) end subroutine test_phase_of_moon !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_moon_fullness integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_check_start ( 'moon_fullness' ) call unit_check ( 'moon_fullness' , moon_fullness ( dat ). eq . - 30 ) call unit_check_done ( 'moon_fullness' ) end subroutine test_moon_fullness !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_easter () !!use M_time,  only : easter implicit none character ( len = 20 ), parameter :: tests ( * ) = [ & '1980,4,6  ' , & '1981,4,19 ' , & '1982,4,11 ' , & '1983,4,3  ' , & '1984,4,22 ' , & '1985,4,7  ' , & '1986,3,30 ' , & '1987,4,19 ' , & '1988,4,3  ' , & '1989,3,26 ' , & '1990,4,15 ' , & '1991,3,31 ' , & '1992,4,19 ' , & '1993,4,11 ' , & '1994,4,3  ' , & '1995,4,16 ' , & '1996,4,7  ' , & '1997,3,30 ' , & '1998,4,12 ' , & '1999,4,4  ' , & '2000,4,23 ' , & '2001,4,15 ' , & '2002,3,31 ' , & '2003,4,20 ' , & '2004,4,11 ' , & '2005,3,27 ' , & '2006,4,16 ' , & '2007,4,8  ' , & '2008,3,23 ' , & '2009,4,12 ' , & '2010,4,4  ' , & '2011,4,24 ' , & '2012,4,8  ' , & '2013,3,31 ' , & '2014,4,20 ' , & '2015,4,5  ' , & '2016,3,27 ' , & '2017,4,16 ' , & '2018,4,1  ' , & '2019,4,21 ' , & '2020,4,12 ' , & '2021,4,4  ' , & '2022,4,17 ' , & '2023,4,9  ' , & '2024,3,31 ' ] character ( len = 20 ) :: readme integer :: tmonth , tday integer :: inyear , outmonth , outday integer :: ii integer :: dat ( 8 ) character ( len = 5 ) :: mon ( 3 : 4 ) = ( / 'march' , 'april' / ) call unit_check_start ( 'easter' ) ! assume if got here passed checks do ii = 1 , size ( tests ) readme = tests ( ii ) ! cannot do internal read on a parameter read ( readme , * ) inyear , tmonth , tday call easter ( inyear , dat ) outmonth = dat ( 2 ) outday = dat ( 3 ) call unit_check ( 'easter' , tmonth . eq . outmonth . and . tday . eq . outday , tests ( ii ), 'month=' , mon ( outmonth )) enddo call unit_check_done ( 'easter' ) ! assume if got here passed checks end subroutine test_easter !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now_ex call unit_check_start ( 'now_ex' ) call unit_check_done ( 'now_ex' ) end subroutine test_now_ex !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2w () use M_verify , only : unit_check , unit_check_good , unit_check_bad , unit_check_done , unit_check_start , unit_check_msg , unit_check_level implicit none call unit_check_start ( 'd2w' , msg = 'Examples of contemporary dates around New Year''s Day' ) call date_and_time ( values = dat ) dat = [ 2005 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 1 Jan 2005 2005-01-01 2004-W53-6 call showme ( \"2004-W53-6\" ) dat = [ 2005 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 2 Jan 2005 2005-01-02 2004-W53-7 call showme ( \"2004-W53-7\" ) dat = [ 2005 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 31 Dec 2005 2005-12-31 2005-W52-6 call showme ( \"2005-W52-6\" ) dat = [ 2007 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 1 Jan 2007 2007-01-01 2007-W01-1 Both years 2007 start with the same day. call showme ( \"2007-W01-1\" ) dat = [ 2007 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 30 Dec 2007 2007-12-30 2007-W52-7 call showme ( \"2007-W52-7\" ) dat = [ 2007 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 31 Dec 2007 2007-12-31 2008-W01-1 call showme ( \"2008-W01-1\" ) dat = [ 2008 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 1 Jan 2008 2008-01-01 2008-W01-2 !     Gregorian year 2008 is a leap year. ... !     ISO year 2008 is 2 days shorter: 1 day longer at the start, 3 days shorter at the end. call showme ( \"2008-W01-2\" ) dat = [ 2008 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 28 Dec 2008 2008-12-28 2008-W52-7 ... !     ISO year 2009 begins three days before the end of Gregorian 2008. call showme ( \"2008-W52-7\" ) dat = [ 2008 , 12 , 29 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 29 Dec 2008 2008-12-29 2009-W01-1 call showme ( \"2009-W01-1\" ) dat = [ 2008 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 30 Dec 2008 2008-12-30 2009-W01-2 call showme ( \"2009-W01-2\" ) dat = [ 2008 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Wed 31 Dec 2008 2008-12-31 2009-W01-3 call showme ( \"2009-W01-3\" ) dat = [ 2009 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 1 Jan 2009 2009-01-01 2009-W01-4 call showme ( \"2009-W01-4\" ) dat = [ 2009 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 31 Dec 2009 2009-12-31 2009-W53-4  ... !     ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010. call showme ( \"2009-W53-4\" ) dat = [ 2010 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Fri 1 Jan 2010 2010-01-01 2009-W53-5 call showme ( \"2009-W53-5\" ) dat = [ 2010 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 2 Jan 2010 2010-01-02 2009-W53-6 call showme ( \"2009-W53-6\" ) dat = [ 2010 , 01 , 03 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 3 Jan 2010 2010-01-03 2009-W53-7 call showme ( \"2009-W53-7\" ) call unit_check_done ( 'd2w' ) ! assume if got here passed checks end subroutine test_d2w subroutine showme ( string ) use M_time , only : d2w implicit none character ( len =* ) :: string integer :: iyear , iweek , iweekday character ( len = 10 ) :: name call d2w ( dat , iyear , iweek , iweekday , name ) call unit_check ( 'd2w' , name . eq . string , iyear , iweek , iweekday , name , string ) end subroutine showme !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end subroutine test_suite_M_time","tags":"","loc":"proc/test_suite_m_time.html"},{"title":"d2j – M_time","text":"public function d2j(dat) result(julian) NAME d2j(3f) - [M_time:JULIAN] given DAT date-time array returns Julian Date\n(LICENSE:PD) SYNOPSIS function d2j(dat) result ( julian ) integer , intent ( in ) :: dat ( 8 ) real ( kind = realtime ) :: julian DESCRIPTION Given DAT date-time array returns Julian Date OPTIONS dat Integer array holding a \" DAT \" array , similar in structure to the array returned by the intrinsic DATE_AND_TIME ( 3 f ) : dat = [ year , month , day , timezone , hour , & & minutes , seconds , milliseconds ] If not present , use current time . RETURNS julian    The Julian Date. EXAMPLE Sample program : program demo_d2j use M_time , only : d2j implicit none integer :: dat ( 8 ) call date_and_time ( val ues = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Julian Date is ' , d2j ( dat ) end program demo_d2j results : Today is : 2016 : 7 : 19 :- 240 : 2 : 11 : 50 : 885 Julian Date is 2457588.7582278359 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: dat (8) Return Value real(kind=realtime) Contents Source Code d2j Source Code function d2j ( dat ) result ( julian ) ! ident_21=\"@(#)M_time::d2j(3f): Given DAT date-time array returns Julian Date\" integer , intent ( in ), optional :: dat ( 8 ) real ( kind = realtime ) :: julian integer :: ierr integer :: dat_local ( 8 ) if ( present ( dat )) then ! if dat array is present use value contained in it call date_to_julian ( dat , julian , ierr ) else ! if dat array is not present create one containing current time dat_local = getnow () call date_to_julian ( dat_local , julian , ierr ) endif end function d2j","tags":"","loc":"proc/d2j.html"},{"title":"d2o – M_time","text":"public function d2o(dat) result(ordinal) NAME d2o(3f) - [M_time:ORDINAL_DAY] converts DAT date-time array to Ordinal day\n(LICENSE:PD) SYNOPSIS function d2o(dat) result ( ordinal ) integer , intent ( in ), optional :: dat ( 8 ) integer :: ordinal DESCRIPTION Given a date in the form of a “DAT” array return the Ordinal Day,\n   (ie. “the day of the year”). OPTIONS dat  Integer array holding a \"DAT\" array, similar in structure\n      to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n          dat=[ year,month,day,timezone,hour,&\n           & minutes,seconds,milliseconds] RETURNS ordinal The day of the year calculated for the given input date , where Jan 1 st = 1 . EXAMPLE Sample program : program demo_d2o use M_time , only : d2o implicit none integer :: dat ( 8 ) call date_and_time ( val ues = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Day of year is:' , d2o ( dat ) ! year , month , day , timezone , hour , minute , seconds , milliseconds dat = [ 2020 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2021 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2022 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2023 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2024 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) end program demo_d2o results : Today is : 2016 : 7 : 19 :- 240 : 20 : 1 : 19 : 829 Day of year is : 201 2020 Days in year is : 366 2021 Days in year is : 365 2022 Days in year is : 365 2023 Days in year is : 365 2024 Days in year is : 366 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: dat (8) Return Value integer Contents Source Code d2o Source Code function d2o ( dat ) result ( ordinal ) ! ident_6=\"@(#)M_time::d2o(3f): Converts DAT date-time array to Ordinal day\" ! JSU 2015-12-13 integer , intent ( in ), optional :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME integer :: dat_local ( 8 ) integer :: ordinal ! the returned number of days real ( kind = realtime ) :: unixtime ! Unix time (seconds) real ( kind = realtime ) :: unix_first_day integer :: ierr ! return 0 on success, otherwise 1 from date_to_unix(3f) integer :: temp_dat ( 8 ) if ( present ( dat )) then dat_local = dat else dat_local = getnow () endif call date_to_unix ( dat_local , unixtime , ierr ) ! convert date to Unix Epoch Time if ( ierr . ne . 0 ) then call stderr ( '*d2o* bad date array' ) ordinal =- 1 ! initialize to bad value else temp_dat = [ dat_local ( 1 ), 1 , 1 , dat_local ( 4 ), 0 , 0 , 0 , 0 ] call date_to_unix ( temp_dat , unix_first_day , ierr ) ordinal = int (( unixtime - unix_first_day ) / secday ) + 1 endif end function d2o","tags":"","loc":"proc/d2o.html"},{"title":"d2u – M_time","text":"public function d2u(dat) result(unixtime) NAME d2u(3f) - [M_time:UNIX_EPOCH] given DAT date-time array returns Unix\nEpoch Time (UET starts at 0000 on 1 Jan. 1970, UTC)\n(LICENSE:PD) SYNOPSIS function d2u(dat) result ( unixtime ) integer , intent ( in ), optional :: dat ( 8 ) real ( kind = realtime ) :: unixtime DESCRIPTION Converts a DAT date-time array to a Unix Epoch Time value. Typically\n   mathematical operations such as sums, sorting and comparison are\n   performed with simple UET numeric values, and then they are converted\n   back. OPTIONS dat Integer array holding a \" DAT \" array , similar in structure to the array returned by the intrinsic DATE_AND_TIME ( 3 f ) : dat = [ year , month , day , timezone , hour , & & minutes , seconds , milliseconds ] If not present the current time is used RETURNS unixtime  The \"Unix Epoch\" time, or the number of seconds since 00:00:00 on\n          January 1st, 1970, UTC. EXAMPLE Sample program : program demo_d2u use M_time , only : d2u implicit none integer :: dat ( 8 ) call date_and_time ( val ues = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Unix Epoch time is ' , d2u ( dat ) end program demo_d2u results : Today is : 2016 : 7 : 19 :- 240 : 2 : 0 : 48 : 561 Unix Epoch time is 1468908048.5610321 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: dat (8) Return Value real(kind=realtime) Contents Source Code d2u Source Code function d2u ( dat ) result ( unixtime ) ! ident_23=\"@(#)M_time::d2u(3f): Given DAT date-time array returns Unix Epoch time\" real ( kind = realtime ) :: unixtime integer , intent ( in ), optional :: dat ( 8 ) integer :: datlocal ( 8 ) integer :: ierr if ( present ( dat )) then datlocal = dat else datlocal = getnow () ! current time is placed in array endif call date_to_unix ( datlocal , unixtime , ierr ) end function d2u","tags":"","loc":"proc/d2u.html"},{"title":"days2sec – M_time","text":"public function days2sec(str) result(time) NAME days2sec(3f) - [ M_time:DURATION ] convert string of form [[ - ] dd - ] hh:mm:ss . nn to seconds (LICENSE:PD) SYNOPSIS function days2sec(str) result ( time ) character ( len = * ), intent ( in ) :: str real ( kind = realtime ) :: time DESCRIPTION Given a string representing a duration of the form\n   “[-][[[dd-]hh:]mm:]ss”  or [NNd][NNh][NNm[]NNs][NNw]\n   return a value representing seconds. If “dd-” is present, units for the numbers are assumed to\n   proceed from day to hour to minute to second. But if no\n   day is present, the units are assumed to proceed from second\n   to minutes to hour from left to right. That is … [ - ] dd - hh:mm:ss [ - ] dd - hh:mm [ - ] dd - hh hh:mm:ss mm:ss ss Where dd is days , hh hours , mm minutes and ss seconds . A decimal fraction is supported on the seconds (Actually,\n   any of the numeric values may represent positive floating\n   point numbers). Spaces are ignored. Simple numeric values may also be used with unit suffixes; where\n   s,m,h, or d represents seconds, minutes, hours or days and w\n   represents a week. Allowed aliases for w,d,h,m, and s units are [ NNd ][ NNh ][ NNm ][ NNs ][ NNw ] d - days , day m - minutes , minute , min , mins h - hours , hour , hr , hrs s - seconds , second , sec , secs w - week , weeks , wk , wks The numeric values may represent floating point numbers. Spaces, commas and case are ignored. OPTIONS str   string of the general form dd-hh:mm:ss.nn RETURNS time  the number of seconds represented by the input string EXAMPLE Sample program : program demo_days2sec use M_time , only : days2sec implicit none write ( * , * ) days2sec ( ' 1-12:04:20 ' ) write ( * , * ) ' one second ' , days2sec ( ' 1 ' ) write ( * , * ) ' one minute ' , days2sec ( ' 1:00 ' ) write ( * , * ) ' one hour ' , days2sec ( ' 1:00:00 ' ) write ( * , * ) ' one day ' , days2sec ( ' 1-00:00:00 ' ) write ( * , * ) nint ( days2sec ( ' 1-12:04:20 ' )) . eq . 129860 write ( * , * ) nint ( days2sec ( ' 1.5 days ' )) . eq . 129600 write ( * , * ) nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) . eq . 145800 write ( * , * ) nint ( days2sec ( ' 1.5d ' )) . eq . 129600 write ( * , * ) nint ( days2sec ( ' 1d2h3m4s ' )) . eq . 93784 ! duplicates write ( * , * ) nint ( days2sec ( ' 1d1d1d ' )) . eq . 259200 ! negative values write ( * , * ) nint ( days2sec ( ' 4d-12h ' )) . eq . 302400 end program demo_days2sec Results : > 129860 . 00000000000 > one second 1 . 0000000000000000 > one minute 60 . 000000000000000 > one hour 3600 . 0000000000000 > one day 86400 . 000000000000 > T > T > T > T > T > T > T AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=realtime) Contents Source Code days2sec Source Code function days2sec ( str ) result ( time ) implicit none ! ident_26=\"@(#)M_time::days2sec(3f): convert string [[-]dd-]hh:mm:ss.nn to seconds or string IId JJh KKm LLs to seconds\" character ( len =* ), intent ( in ) :: str real ( kind = realtime ) :: time ! Supported input syntax: !    [-]dd-hh:mm:ss !          hh:mm:ss !          mm:ss !          ss ! character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: array (:) real ( kind = realtime ), parameter :: units_lh ( 4 ) = [ 1.0_dp , 6 0.0_dp , 360 0.0_dp , 8640 0.0_dp ] real ( kind = realtime ), parameter :: units_hl ( 4 ) = [ 8640 0.0_dp , 360 0.0_dp , 6 0.0_dp , 1.0_dp ] integer :: i , icount , iwords , ilast logical :: negative time = 0.0_dp strlocal = compact ( str , '' ) ! remove whitespace strlocal = transliterate ( strlocal , \"_',\" , '' ) ! remove single quotes,underscores sometimes used in numbers strlocal = lower ( strlocal ) // repeat ( ' ' , len ( strlocal )) ! change to lowercase and add whitespace to make room for spaces if ( len ( strlocal ). eq . 0 ) then time = 0.0_dp elseif ( scan ( strlocal , 'smhdw' ). ne . 0 ) then ! unit code values not DD-HH:MM:SS either plain number or unit numbers call substitute ( strlocal , 'days' , 'd' ) ! from long names to short names substitute common aliases for units call substitute ( strlocal , 'day' , 'd' ) call substitute ( strlocal , 'hours' , 'h' ) call substitute ( strlocal , 'hour' , 'h' ) call substitute ( strlocal , 'hrs' , 'h' ) call substitute ( strlocal , 'hr' , 'h' ) call substitute ( strlocal , 'minutes' , 'm' ) call substitute ( strlocal , 'minute' , 'm' ) call substitute ( strlocal , 'mins' , 'm' ) call substitute ( strlocal , 'min' , 'm' ) call substitute ( strlocal , 'seconds' , 's' ) call substitute ( strlocal , 'second' , 's' ) call substitute ( strlocal , 'secs' , 's' ) call substitute ( strlocal , 'sec' , 's' ) call substitute ( strlocal , 'weeks' , 'w' ) call substitute ( strlocal , 'week' , 'w' ) call substitute ( strlocal , 'wks' , 'w' ) call substitute ( strlocal , 'wk' , 'w' ) call substitute ( strlocal , 's' , 's ' ) ! assuming only one suffix character and not too many to exceed length of strlocal call substitute ( strlocal , 'm' , 'm ' ) call substitute ( strlocal , 'h' , 'h ' ) call substitute ( strlocal , 'd' , 'd ' ) call substitute ( strlocal , 'w' , 'w ' ) call split ( strlocal , array , ' ' ) iwords = size ( array ) icount = 0 do i = iwords , 1 , - 1 icount = icount + 1 ilast = len_trim ( array ( i )) select case ( array ( i )( ilast : ilast )) case ( 'w' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) * 7 case ( 'd' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) case ( 'h' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 2 ) case ( 'm' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 3 ) case ( 's' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 4 ) case default time = time + s2v ( array ( i )) end select enddo else if ( strlocal ( 1 : 1 ). eq . '-' ) then ! allow negative prefix as first character but remove it and change sign of value at end negative = . true . strlocal ( 1 : 1 ) = ' ' else negative = . false . endif call split ( trim ( strlocal ), array , ' -:' ) iwords = size ( array ) if ( iwords . gt . 4 ) then write ( * , * ) '*days2sec* error: too many values in ' // trim ( strlocal ) iwords = 4 endif if ( index ( strlocal , '-' ). gt . 0 ) then ! found a dash, assume has days and form DD-HH:MM:SS, DD-, DD-HH, DD-HH:MM do i = 1 , iwords time = time + s2v ( array ( i )) * units_hl ( i ) enddo else ! no dash, assume no days, either HH:MM:SS or MM:SS, SS icount = 0 do i = iwords , 1 , - 1 icount = icount + 1 ilast = len_trim ( array ( i )) time = time + s2v ( array ( i )) * units_lh ( icount ) enddo endif if ( negative ) time =- time endif end function days2sec","tags":"","loc":"proc/days2sec.html"},{"title":"fmtdate – M_time","text":"public function fmtdate(values, format) result(timestr) NAME fmtdate ( 3 f ) - [ M_time : DATE_PRINTING ] given DAT date - time array return date as string using specified format ( LICENSE : PD ) SYNOPSIS function fmtdate(values,format) RESULT ( timestr ) integer , dimension ( 8 ), intent ( in ) :: values character ( len = * ), intent ( in ), optional :: format character ( len =:), allocatable :: timestr DESCRIPTION The fmtdate(3f) procedure lets you reformat a DAT array in\n   many common formats using a special string containing macro names\n   beginning with ‘%’. To see the allowable macros call or see the\n   fmtdate_usage(3f) routine. OPTIONS values date in a \" DAT \" array , which is the same format as the values returned by the intrinsic DATE_AND_TIME ( 3 f ) : dat = [ year , month , day , timezone , hour , & & minutes , seconds , milliseconds ] format string describing how to format the \" DAT \" array . For a complete description of the formatting macros supported see fmtdate_usage ( 3 f ) . RETURNS timestr  formatted output string representing date EXAMPLE Sample program : program demo_fmtdate use M_time , only : fmtdate implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , * ) fmtdate ( dat , \" current date: %w, %l %d, %Y %H:%m:%s %N \" ) call showme () contains subroutine showme () use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine showme end program demo_fmtdate results : The current date is Sun , Jul 17 th , 2016 01 : 21 : 35 PM ::\n    :: An up - to - date description of all the :: formatting options will appear here :: AUTHOR John S. Urban, 2015-12-19 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(8) :: values character(len=*), intent(in), optional :: format Return Value character(len=:),allocatable Contents Source Code fmtdate Source Code function fmtdate ( values , format ) RESULT ( timestr ) ! ident_14=\"@(#)M_time::fmtdate(3f): given DAT date-time array return date as string using format\" ! JSU 2015-10-24 integer , dimension ( 8 ), intent ( in ) :: values ! numeric time values as DATE_AND_TIME(3f) intrinsic returns character ( len =* ), intent ( in ), optional :: format ! input format string character ( len = :), allocatable :: timestr !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - integer , dimension ( 8 ) :: valloc ! numeric time values as DATE_AND_TIME(3f) intrinsic returns integer , parameter :: longest = 4096 character ( len = 1 ) :: chara ! character being looked at in format string character ( len = 10 ) :: iso_name character ( len = 2 ) :: dayend character ( len = 9 ) :: day ! day of week character ( len = :), allocatable :: local_format character ( len = longest ) :: text ! character array character ( len = longest ) :: xxxx integer :: i , ii , i10 integer :: ierr integer :: iout integer :: iso_year , iso_week , iso_weekday integer :: systemclock , countrate integer :: weekday integer , save :: called = 0 logical :: keyword ! flag that previous character was a % character logical , save :: since = . FALSE . real ( kind = realtime ) :: cputime real ( kind = realtime ) :: julian real ( kind = realtime ) :: unixtime real ( kind = realtime ), save :: unixtime_last valloc = values if ( present ( format )) then local_format = format else local_format = ' ' endif select case ( local_format ) case ( 'iso-8601W' , 'isoweek' ) ; local_format = '%I' ! 2016-W24-5 (yyyy-Www-d) case ( 'iso-8601' , 'iso' ) ; local_format = '%Y-%M-%DT%h:%m:%s%z' ! 2006-08-14T02:34:56-0600 case ( 'sql' ) ; local_format = '\"%Y-%M-%D %h:%m:%s.%x\"' ! case ( 'sqlday' ) ; local_format = '\"%Y-%M-%D\"' ! case ( 'sqltime' ) ; local_format = '\"%h:%m:%s.%x\"' ! case ( 'rfc-2822' ) ; local_format = '%w, %D %l %Y %h:%m:%s %T' ! Mon, 14 Aug 2006 02:34:56 -0600 case ( 'rfc-3339' ) ; local_format = '%Y-%M-%DT%h:%m:%s%z' ! 2006-08-14 02:34:56-06:00 case ( 'suffix' ) ; local_format = '%Y%D%M%h%m%s' ! 20170122210327 case ( 'date' ) ; local_format = '%w %l %D %h:%m:%s UTC%z %Y' ! Mon Jul 25 03:19:21 UTC-4:00 2016 case ( 'short' ) ; local_format = '%w, %l %d, %Y %H:%m:%s %N UTC%z' ! Fri, Jun 17th, 2016 06:31:00 PM UTC-04:00 case ( 'long' ) ; local_format = '%W, %L %d, %Y %H:%m:%s %N UTC%z' ! Friday, June 17th, 2016 06:31:00 PM UTC-04:00 case ( ' ' ) ; local_format = '%W, %L %d, %Y %H:%m:%s %N UTC%z' ! Friday, June 17th, 2016 06:31:00 PM UTC-04:00 case ( 'formal' ) ; local_format = 'The %d of %L %Y' ! The 9th of November 2014 case ( 'lord' ) ; local_format = 'the %d day of %L in the year of our Lord %Y' ! the 9th day of November in the year of our Lord 2014 case ( 'easter' ) call easter ( values ( 1 ), valloc ) ! given year get month and day Easter falls on local_format = \"Easter day: the %d day of %L in the year of our Lord %Y\" case ( 'all' ) local_format = '& & Civil Calendar:%t%W %L %d%n& & Civil Date:%t%t%Y-%M-%D %h:%m:%s %z%n& & Julian Date:%t%t%J%n& & Unix Epoch Time:%t%E%n& & Day Of Year:%t%t%O%n& & ISO-8601 week:%t%t%I& &' case default xxxx = local_format if ( index ( xxxx , '%' ). eq . 0 ) then ! if no % characters try to guess what macros are present call substitute ( xxxx , 'year' , '%Y' ) call substitute ( xxxx , 'month' , '%M' ) call substitute ( xxxx , 'MONTH' , '%L' ) call substitute ( xxxx , 'Month' , '%l' ) call substitute ( xxxx , 'weekday' , '%u' ) call substitute ( xxxx , 'WEEKDAY' , '%W' ) call substitute ( xxxx , 'Weekday' , '%w' ) call substitute ( xxxx , 'today' , '%Y%M%D' ) call substitute ( xxxx , 'day' , '%D' ) call substitute ( xxxx , 'DAY' , '%d' ) call substitute ( xxxx , 'GOOD' , '%N' ) call substitute ( xxxx , 'HOUR' , '%H' ) call substitute ( xxxx , 'hour' , '%h' ) call substitute ( xxxx , 'minute' , '%m' ) call substitute ( xxxx , 'timezone' , '%T' ) call substitute ( xxxx , 'TIMEZONE' , '%z' ) call substitute ( xxxx , 'Timezone' , '%Z' ) call substitute ( xxxx , 'millisecond' , '%x' ) call substitute ( xxxx , 'second' , '%s' ) call substitute ( xxxx , 'epoch' , '%e' ) call substitute ( xxxx , 'julian' , '%j' ) call substitute ( xxxx , 'ordinal' , '%O' ) if ( index ( xxxx , '%' ). eq . 0 ) then ! if no % characters change every char to %char if a format macro letter do i = 65 , 122 select case ( char ( i )) case ( 'B' : 'E' , 'H' : 'J' , 'L' : 'Q' , 'S' , 'T' , 'U' , 'W' , 'Y' , 'Z' , 'b' : 'e' , 'h' : 'm' , 'n' , 'o' : 'q' , 's' : 'u' , 'w' , 'x' , 'z' ) call substitute ( xxxx , char ( i ), '%' // char ( i )) end select enddo endif endif local_format = trim ( xxxx ) end select text = ' ' !  write string, when encounter a percent character do a substitution keyword = . FALSE . iout = 1 do i10 = 1 , len ( local_format ) ! Read the FORMAT string and replace the \"%\" strings per the following rules: chara = local_format ( i10 : i10 ) if ( chara . eq . '%' . and .. not . keyword ) then keyword = . TRUE . cycle endif if ( keyword ) then keyword = . FALSE . select case ( chara ) !===================================================================================== case ( '%' ); write ( text ( iout :), '(A1)' ) chara ! literal percent character !===================================================================================== case ( 'b' ); write ( text ( iout :), '(A1)' ) ' ' ! space character !===================================================================================== case ( 'B' ); write ( text ( iout :), '(A1)' ) '!' ! exclamation (bang) character !===================================================================================== case ( 'c' ); call cpu_time ( cputime ) ! CPU_TIME() write ( text ( iout :), '(G0)' ) cputime !===================================================================================== case ( 'C' ); called = called + 1 ! number of times this routine called write ( text ( iout :), '(I0)' ) called !===================================================================================== case ( 'd' ); ! the day of the month 1st..31st dayend = '  ' select case ( valloc ( 3 )) case ( 1 , 21 , 31 ); dayend = 'st' case ( 2 , 22 ); dayend = 'nd' case ( 3 , 23 ); dayend = 'rd' case ( 4 : 20 , 24 : 30 ); dayend = 'th' case default end select write ( text ( iout :), '(I0,a)' ) valloc ( 3 ), dayend !===================================================================================== case ( 'D' ); write ( text ( iout :), '(I2.2)' ) valloc ( 3 ) ! the day of the month 1..31 !===================================================================================== case ( 'e' ); call date_to_unix ( valloc , unixtime , ierr ) ! integer Unix Epoch time in seconds write ( text ( iout :), '(G0)' ) nint ( unixtime ) !===================================================================================== case ( 'E' ); call date_to_unix ( valloc , unixtime , ierr ) ! Unix Epoch time in seconds write ( text ( iout :), '(G0)' ) unixtime !===================================================================================== case ( 'h' ); write ( text ( iout :), '(I2.2)' ) valloc ( 5 ) ! the hour of the day, in the range of 0 to 23 !===================================================================================== case ( 'H' ); ii = mod ( valloc ( 5 ), 12 ) ! hour of day in range 1..12 if ( ii . eq . 0 ) then ii = 12 endif write ( text ( iout :), '(I0)' ) ii !===================================================================================== case ( 'i' ); call d2w ( valloc , iso_year , iso_week , iso_weekday , iso_name ) ! ISO week of year write ( text ( iout :), '(I0)' ) iso_week !===================================================================================== case ( 'I' ); call d2w ( valloc , iso_year , iso_week , iso_weekday , iso_name ) ! iso-8601 Week-numbering year date write ( text ( iout :), '(a)' ) iso_name !===================================================================================== case ( 'j' ); call date_to_julian ( valloc , julian , ierr ) ! integer Julian Day (truncated to integer) write ( text ( iout :), '(I0)' ) int ( julian ) !===================================================================================== case ( 'J' ); call date_to_julian ( valloc , julian , ierr ) ! Julian Date out to milliseconds !write(text(iout:),'(I0,\".\",i3.3)')int(julian),nint((julian-int(julian))*1000.0) write ( text ( iout :), '(g0)' ) julian !===================================================================================== case ( 'k' ); call system_clock ( count = systemclock , count_rate = countrate ) ! systemclock/countrate write ( text ( iout :), '(G0)' ) real ( systemclock ) / countrate !===================================================================================== case ( 'K' ); call system_clock ( count = systemclock , count_rate = countrate ) ! system clock count write ( text ( iout :), '(I0)' ) systemclock !===================================================================================== case ( 'l' ); write ( text ( iout :), '(A3)' ) v2mo ( valloc ( 2 )) ! three characters of the name of the month of the year !===================================================================================== case ( 'L' ); write ( text ( iout :), '(A)' ) v2mo ( valloc ( 2 )) ! name of the month of the year !===================================================================================== case ( 'm' ); write ( text ( iout :), '(I2.2)' ) valloc ( 6 ) ! the minutes of the hour, in the range 0 to 59 !===================================================================================== case ( 'M' ); write ( text ( iout :), '(I2.2)' ) valloc ( 2 ) ! month of year (1..12) !===================================================================================== case ( 'N' ); if ( valloc ( 5 ). ge . 12 ) then ! AM||PM write ( text ( iout :), '(\"PM\")' ) else write ( text ( iout :), '(\"AM\")' ) endif !===================================================================================== case ( 'n' ); write ( text ( iout :), '(a)' ) new_line ( \"A\" ) !===================================================================================== case ( 'O' ); write ( text ( iout :), '(I3.3)' ) d2o ( valloc ) ! Ordinal day of year !===================================================================================== case ( 'o' ); call date_to_unix ( valloc , unixtime , ierr ) ! integer Unix Epoch time in seconds write ( text ( iout :), '(G0)' ) floor ( unixtime / 86400 ) ! number of whole days since Epoch time !===================================================================================== !===================================================================================== case ( 'p' ); write ( text ( iout :), '(A)' ) phase_of_moon ( valloc ) ! phase of moon !===================================================================================== case ( 'P' ); write ( text ( iout :), '(i0,\"%\")' ) moon_fullness ( valloc ) ! percent of fullness !===================================================================================== case ( 'q' ); write ( text ( iout :), '(\"''\")' ) ! single quote (apostrophe) !===================================================================================== case ( 'Q' ); write ( text ( iout :), '(''\"'')' ) ! double quote !===================================================================================== case ( 's' ); write ( text ( iout :), '(I2.2)' ) valloc ( 7 ) ! the seconds of the minute, in the range 0 to 59 !===================================================================================== case ( 'S' ); if (. not . since ) then ! seconds since last called since = . TRUE . call date_to_unix ( valloc , unixtime_last , ierr ) endif call date_to_unix ( valloc , unixtime , ierr ) write ( text ( iout :), '(G0)' ) unixtime - unixtime_last unixtime_last = unixtime !===================================================================================== case ( 't' ); write ( text ( iout :), '(A1)' ) CHAR ( 9 ) ! tab character !===================================================================================== case ( 'T' ); write ( text ( iout :), '(SP,I3.2,SS,I2.2)' ) int ( valloc ( 4 ) / 60 ), abs ( mod ( valloc ( 4 ), 60 )) ! time from UTC as +-hhmm !===================================================================================== case ( 'U' ); call dow ( valloc , weekday , day , ierr ) write ( text ( iout :), '(I1)' ) mod ( weekday + 7 , 7 ) + 1 ! Return the day of the week, 1..7 Sunday=1 !===================================================================================== case ( 'u' ); call dow ( valloc , weekday , day , ierr ) ! Return the day of the week, 1..7 Monday=1 write ( text ( iout :), '(I1)' ) weekday !===================================================================================== case ( 'W' ); call dow ( valloc , weekday , day , ierr ) ! Return the name of the day of the week write ( text ( iout :), '(a)' ) day !===================================================================================== case ( 'w' ); call dow ( valloc , weekday , day , ierr ) ! Return the first three characters of the day of the week write ( text ( iout :), '(A3)' ) day ( 1 : 3 ) !===================================================================================== case ( 'x' ); write ( text ( iout :), '(I3.3)' ) valloc ( 8 ) ! the milliseconds of the second, in the range 0 to 999 !===================================================================================== case ( 'Y' ); write ( text ( iout :), '(I0.4)' ) valloc ( 1 ) ! the year, including the century (for example, 1990) !===================================================================================== case ( 'Z' ); write ( text ( iout :), '(SP,I5.4)' ) valloc ( 4 ) ! time difference with respect to UTC in minutes !===================================================================================== case ( 'z' ); write ( text ( iout :), '(SP,I3.2,\":\",SS,I2.2)' ) int ( valloc ( 4 ) / 60 ), abs ( mod ( valloc ( 4 ), 60 )) ! time from UTC as +-hh:mm !===================================================================================== case default write ( text ( iout :), '(A1)' ) chara !===================================================================================== end select !===================================================================================== iout = len_trim ( text ) + 1 if ( iout . ge . longest ) exit else write ( text ( iout :), '(A1)' ) chara ; iout = iout + 1 endif enddo timestr = trim ( text ) end function fmtdate","tags":"","loc":"proc/fmtdate.html"},{"title":"j2d – M_time","text":"public function j2d(julian) result(dat) NAME j2d(3f) - [M_time:JULIAN] given a JED (Julian Ephemeris Date) returns a\ndate-time array DAT.\n(LICENSE:PD) SYNOPSIS function j2d(julian) result ( dat ) real ( kind = realtime ), intent ( in ), optional :: julian integer :: dat ( 8 ) DESCRIPTION Converts a Julian Ephemeris Date to a DAT date-time array. OPTIONS julian A Julian Ephemeris Date ( JED ) is the number of days since noon ( not midnight ) on January 1 st , 4713 BC . If not present , use current time . RETURNS dat   Integer array holding a \"DAT\" array, similar in structure\n      to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n             dat=[ year,month,day,timezone,hour,&\n              & minutes,seconds,milliseconds] EXAMPLE Sample program : program demo_j2d use M_time , only : j2d , d2j , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0 . 0 d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2j ( dat ) ! convert today to Julian Date write ( * , * ) ' Today= ' , fmtdate ( j2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) ' Yesterday= ' , fmtdate ( j2d ( today - 1 . 0 _dp )) write ( * , * ) ' Tomorrow= ' , fmtdate ( j2d ( today + 1 . 0 _dp )) end program demo_j2d results : Today = Tuesday , July 19 th , 2016 08 : 48 : 20 AM Yesterday = Monday , July 18 th , 2016 08 : 48 : 20 AM Tomorrow = Wednesday , July 20 th , 2016 08 : 48 : 20 AM AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name real(kind=realtime), intent(in) :: julian Return Value integer(8) Contents Source Code j2d Source Code function j2d ( julian ) result ( dat ) ! ident_22=\"@(#)M_time::j2d(3f): Given Julian Date returns DAT date-time array\" real ( kind = realtime ), intent ( in ) :: julian integer :: dat ( 8 ) integer :: ierr call julian_to_date ( julian , dat , ierr ) end function j2d","tags":"","loc":"proc/j2d.html"},{"title":"mo2d – M_time","text":"public function mo2d(month_name, year) result(dat) NAME mo2d ( 3 f ) - [ M_time : MONTH_NAME ] given month name return DAT date - time array for beginning of that month in specified year ( LICENSE : PD ) SYNOPSIS function mo2d(month_name,year) result ( dat ) character ( len = * ), intent ( in ) :: month_name integer , intent ( in ), optional :: year integer :: dat ( 8 ) DESCRIPTION Given a Common Calendar month name, return the date as a “DAT” array\n   for the 1st day of the month. An optional year may be specified. The\n   year defaults to the current year. OPTIONS month_name  A string representing a Common Calendar month name.\nyear        Optional year. Defaults to current year RETURNS dat         An integer array that has the same structure as the array\n            returned by the Fortran intrinsic DATE_AND_TIME(3f):\n\n             dat=[ year,month,day,timezone,hour,&\n              & minutes,seconds,milliseconds] EXAMPLE Sample program : program demo_mo2d use M_time , only : mo2d implicit none write ( * , '(*(i0:,\":\"))' ) mo2d ( 'March' ) end program demo_mo2d results : 2016 : 3 : 1 :- 240 : 0 : 0 : 0 : 0 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: month_name integer, intent(in), optional :: year Return Value integer(8) Contents Source Code mo2d Source Code function mo2d ( month_name , year ) result ( dat ) ! ident_11=\"@(#)M_time::mo2d(3f): month name to DAT date-time array for 1st of that month in specified year\" character ( len =* ), intent ( in ) :: month_name integer , intent ( in ), optional :: year integer :: dat ( 8 ) dat = getnow () if ( present ( year )) then dat ( 1 ) = year endif dat ( 2 ) = mo2v ( month_name ) ! convert given month name to a number if ( dat ( 2 ). le . 0 ) then call stderr ( '*mo2d* bad month name ' // trim ( month_name )) dat ( 2 ) = 1 endif dat ( 3 ) = 1 ! set day to first of month dat ( 5 ) = 0 ! set hour to zero dat ( 6 ) = 0 ! set minutes to zero dat ( 7 ) = 0 ! set seconds to zero dat ( 8 ) = 0 ! set milliseconds to zero end function mo2d","tags":"","loc":"proc/mo2d.html"},{"title":"mo2v – M_time","text":"public function mo2v(month_name) result(imonth) NAME mo2v ( 3 f ) - [ M_time : MONTH_NAME ] given month name return month number ( 1 - 12 ) of that month ( LICENSE : PD ) SYNOPSIS function mo2v(month_name) result ( imonth ) character ( len = * ), intent ( in ):: month_name ! month name integer :: imonth ! month number DESCRIPTION Given a string representing the name or abbreviation of a Gregorian\n   Calendar month return a number representing the position of the\n   month in the calendar starting with 1 for January and ending with\n   12 for December. OPTIONS month_name  name or abbreviation of month. Case is ignored\n            Once enough characters are found to uniquely identify a\n            month the rest of the name is ignored. RETURNS imonth month number returned . If the name is not recognized a - 1 is returned . EXAMPLE Sample program : program demo_mo2v use M_time , only : mo2v implicit none write ( * , * ) mo2v ( \" April \" ) write ( * , * ) mo2v ( ' Apr ' ) ! NOTE : still matches September , as \" SE \" was enough write ( * , * ) mo2v ( ' sexember ' ) write ( * , * ) mo2v ( ' unknown ' ) ! returns - 1 end program demo_mo2v results : > 4 > 4 > 9 > - 1 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: month_name Return Value integer Contents Source Code mo2v Source Code function mo2v ( month_name ) result ( imonth ) ! ident_12=\"@(#)M_time::mo2v(3f): given month name return month number (1-12) of that month\" ! JSU 2015-12-13 character ( len =* ), intent ( in ) :: month_name ! string containing month name or abbreviation. integer :: imonth ! the number of the month(1-12), or -1 if the name could not be recognized. character ( len = 3 ) :: string string = upper ( month_name ) ! Case is ignored; test string now guaranteed to have three characters imonth = 0 FIND : select case ( string ( 1 : 1 )) ! The month name has to match up to the unique beginning of a month name, and the rest is ignored. case ( 'F' ); imonth = 2 ! February case ( 'S' ); imonth = 9 ! September case ( 'O' ); imonth = 10 ! October case ( 'N' ); imonth = 11 ! November case ( 'D' ); imonth = 12 ! December case default select case ( string ( 1 : 2 )) case ( 'JA' ); imonth = 1 ! JAnuary case ( 'AP' ); imonth = 4 ! APril case ( 'AU' ); imonth = 8 ! AUgust case default select case ( string ( 1 : 3 )) case ( 'MAR' ); imonth = 3 ! MARch case ( 'MAY' ); imonth = 5 ! MAY case ( 'JUN' ); imonth = 6 ! JUNe case ( 'JUL' ); imonth = 7 ! JULy case default imonth =- 1 end select end select end select FIND end function mo2v","tags":"","loc":"proc/mo2v.html"},{"title":"moon_fullness – M_time","text":"public function moon_fullness(datin) NAME moon_fullness ( 3 f ) - [ M_time : ASTROLOGICAL ] return percentage of moon phase from new to full ( LICENSE : PD ) SYNOPSIS function moon_fullness(datin) integer,intent(in)            :: datin(8)\ninteger                       :: moon_fullness DESCRIPTION This procedure is used to support the %P field descriptor for the\n   fmtdate(3f) routine. The moon circles the earth every 29.530588853 days on average, so pick\n   a starting point and count. A new moon occurred at January 6, 2000,\n   18:14 UTC. Then it is easy to count the number of days since the last\n   new moon. This is an approximate calculation. OPTIONS datin      DAT Date array describing input date RESULTS moon_fullness 0 is a new or dark moon , 100 is a full moon , + for waxing and - for waning . EXAMPLES Sample : program demo_moon_fullness use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( val ues = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * ) & & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance='no' ) & &'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' ) & &'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_moon_fullness Sample output : Today is : 2018 : 11 : 3 :- 240 : 20 : 18 : 44 : 245 The phase of the moon is Waning crescent , with a fullness of - 30 % The phase of the moon is Waning crescent , with a fullness of - 30 % AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: datin (8) Return Value integer Contents Source Code moon_fullness Source Code function moon_fullness ( datin ) implicit none ! ident_28=\"@(#)M_time::moon_fullness(3f): return percentage of moon phase from new to full\" integer , intent ( in ) :: datin ( 8 ) integer :: moon_fullness real ( kind = realtime ), parameter :: syndonic_month = 2 9.530588853_realtime ! average period of a lunar cycle, or days per lunation integer , parameter :: reference ( * ) = [ 2000 , 1 , 6 , 0 , 18 , 14 , 0 , 0 ] ! new moon of January 2000 was January 6, 18:14 UTC. real ( kind = realtime ) :: days_into_cycle days_into_cycle = mod ( d2j ( datin ) - d2j ( reference ) , syndonic_month ) ! number of days into lunar cycle if ( days_into_cycle . lt . 0 ) days_into_cycle = days_into_cycle + syndonic_month ! correct for input date being before reference date if ( days_into_cycle . le . syndonic_month / 2.0_realtime ) then ! if waxing from new to full report as 0% to 100% moon_fullness = int (( days_into_cycle / syndonic_month ) * 20 0.0_realtime + 0.5_realtime ) else ! if waning from full to new report as -99% to -1% moon_fullness =- ( 200 - int (( days_into_cycle / syndonic_month ) * 20 0.0_realtime )) endif end function moon_fullness","tags":"","loc":"proc/moon_fullness.html"},{"title":"now – M_time","text":"public function now(format) NAME now ( 3 f ) - [ M_time : DATE_PRINTING ] return string representing current time given format ( LICENSE : PD ) SYNOPSIS function now(format) RESULT ( timestr ) character ( len = * ), intent ( in ) :: format ! input format string character ( len =:), allocatable :: timestr ! formatted date DESCRIPTION The now(3f) function is a call to the fmtdate(3f) function using the\n   current date and time. That is, it is a convenient way to print the\n   current date and time. OPTIONS format string describing how to format the current date and time . For a complete description of the formatting macros supported see fmtdate_usage ( 3 f ) . RETURNS timestr     formatted output string representing date EXAMPLE Sample Program : program demo_now use M_time , only : now implicit none write ( * , * ) now ( \" The current date is %w, %l %d, %Y %H:%m:%s %N \" ) call showme () contains subroutine showme () ! see all formatting options use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine end program demo_now results : The current date is Sun , Jul 17 th , 2016 01 : 21 : 35 PM ::\n    :: description of all formatting options will appear here :: AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: format Return Value character(len=:),allocatable Contents Source Code now Source Code function now ( format ) ! ident_13=\"@(#)M_time::now(3f): return string representing current time given format\" ! JSU 2015-10-24 character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: now integer :: values ( 8 ) !----------------------------------------------------------------------------------------------------------------------------------- values = getnow () if ( present ( format )) then now = fmtdate ( values , format ) else now = trim ( fmtdate ( values )) endif end function now","tags":"","loc":"proc/now.html"},{"title":"o2d – M_time","text":"public function o2d(ordinal, year) result(dat) NAME o2d(3f) - [M_time:ORDINAL_DAY] converts Ordinal day to DAT date-time array\n(LICENSE:PD) SYNOPSIS function o2d(ordinal,[year]) result ( dat ) integer , intent ( in ) :: ordinal ! the day of the year integer , optional :: year ! year integer :: dat ( 8 ) ! date time array DESCRIPTION Given an Ordinal day of the year return a date in the form of a\n   “DAT” array. OPTIONS ordinal The day of the year for the given year , where Jan 1 st = 1 . year An optional year for the ordinal day . If not present the current year is assumed . RETURNS dat   Integer array holding a \"DAT\" array, similar in structure\n       to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n          dat=[ year,month,day,timezone,hour,&\n           & minutes,seconds,milliseconds]\n\n       The timezone value is from the current time on the current\n       platform. EXAMPLE Sample program : program demo_o2d use M_time , only : o2d , fmtdate implicit none integer :: year do year = 2004 , 2008 write ( * , * ) & & ' 100th day of ' , year , ' is ' , fmtdate ( o2d ( 100 , year )) enddo write ( * , * ) ' 100th day of this year is ' , fmtdate ( o2d ( 100 )) end program demo_o2d results : 100 th day of 2004 is Friday , April 9 th , 2004 ... 00 : 00 : 00 PM UTC - 02 : 40 100 th day of 2005 is Sunday , April 10 th , 2005 ... 00 : 00 : 00 PM UTC - 02 : 40 100 th day of 2006 is Monday , April 10 th , 2006 ... 00 : 00 : 00 PM UTC - 02 : 40 100 th day of 2007 is Tuesday , April 10 th , 2007 ... 00 : 00 : 00 PM UTC - 02 : 40 100 th day of 2008 is Wednesday , April 9 th , 2008 ... 00 : 00 : 00 PM UTC - 02 : 40 100 th day of this year is Saturday , April 9 th , 2016 ... 00 : 00 : 00 PM UTC - 02 : 40 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: ordinal integer, optional :: year Return Value integer(8) Contents Source Code o2d Source Code function o2d ( ordinal , year ) result ( dat ) ! ident_9=\"@(#)M_time::o2d(3f): Converts ordinal day to DAT date-time array\" integer :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME integer , intent ( in ) :: ordinal ! the returned number of days integer , optional :: year real ( kind = realtime ) :: unixtime ! Unix time (seconds) integer :: ierr ! return 0 on success, otherwise 1 from date_to_unix(3f) if ( present ( year )) then dat = [ year , 1 , ordinal , get_timezone (), 0 , 0 , 0 , 0 ] ! initialize DAT with parameters and set timezone, set HH:MM:SS.XX to zero else dat = getnow () ! set year and timezone to current values dat = [ dat ( 1 ), 1 , ordinal , dat ( 4 ), 0 , 0 , 0 , 0 ] ! apply ordinal parameter to January of current year, set HH:MM:SS.XX to zero endif ierr = 0 call date_to_unix ( dat , unixtime , ierr ) ! convert date to Unix Epoch Time if ( ierr . ne . 0 ) then call stderr ( '*o2d* bad date array' ) else dat = u2d ( unixtime ) endif end function o2d","tags":"","loc":"proc/o2d.html"},{"title":"ordinal_seconds – M_time","text":"public function ordinal_seconds() NAME ordinal_seconds(3f) - [M_time:ORDINAL_DAY] seconds since beginning of year\n(LICENSE:PD) SYNOPSIS function ordinal_seconds () integer :: ordinal_seconds DESCRIPTION Return number of seconds since beginning of current year. Before using this routine consider the consequences if the application\n   is running at the moment a new year begins. EXAMPLE sample program program demo_ordinal_seconds use M_time , only : ordinal_seconds implicit none character ( len = 1 ) :: paws integer :: ios integer :: istart , iend istart = ordinal_seconds () write ( * , ' (a) ' , advance = ' no ' ) ' now pause. Enter return to continue ... ' read ( * , ' (a) ' , iostat = ios ) paws iend = ordinal_seconds () write ( * , * ) ' that took ' , iend - istart , ' seconds ' write ( * , * ) istart , iend end program demo_ordinal_seconds AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments None Return Value integer Contents Source Code ordinal_seconds Source Code integer function ordinal_seconds () ! ident_7=\"@(#)M_time::ordinal_seconds(3f): seconds since beginning of year\" integer :: vtime ( 8 ) integer :: year , month , day , hour , minutes , seconds , timezone , milliseconds integer :: ordinal_day_of_year equivalence ( vtime ( 1 ), year ) equivalence ( vtime ( 2 ), month ) equivalence ( vtime ( 3 ), day ) equivalence ( vtime ( 4 ), timezone ) equivalence ( vtime ( 5 ), hour ) equivalence ( vtime ( 6 ), minutes ) equivalence ( vtime ( 7 ), seconds ) equivalence ( vtime ( 8 ), milliseconds ) vtime = getnow () ordinal_day_of_year = d2o ( vtime ) ordinal_seconds = ordinal_day_of_year * 24 * 60 * 60 + hour * 60 * 60 + minutes * 60 + seconds end function ordinal_seconds","tags":"","loc":"proc/ordinal_seconds.html"},{"title":"phase_of_moon – M_time","text":"public function phase_of_moon(datin) NAME phase_of_moon ( 3 f ) - [ M_time : ASTROLOGICAL ] return name for phase of moon for given date ( LICENSE : PD ) SYNOPSIS function phase_of_moon(datin) integer,intent(in)            :: datin(8)\ncharacter(len=:),allocatable  :: phase_of_moon DESCRIPTION Phases Of The Moon This procedure is used to support the %p field descriptor for the\n   fmtdate(3f) routine. The moon circles the earth every 29.530588853 days on average, so pick a\n   starting point and count. A new moon occurred at Julian date 2451550.1\n   (January 6, 2000, 18:14 UTC). Then it is easy to count the number of\n   days since the last new moon. This is an approximate calculation. There are eight generally recognized phases of the moon in common use o new or dark\no waxing crescent\no first quarter\no waxing gibbous\no full\no waning gibbous\no last quarter\no waning crescent To calculate the phase of the moon simply divide the days since the\n   last new moon by eight and select the appropriate phase. Note that technically the four states (new, first quarter, full, third\n   quarter) are events not phases. That is to say, the moon is technically\n   only new for an instant. EXAMPLES Sample: program demo_phase_of_moon\n   use M_time, only : now\n   use M_time, only : phase_of_moon\n   use M_time, only : moon_fullness\n   implicit none\n   integer             :: dat(8)\n    ! generate DAT array\n    call date_and_time(values=dat)\n    ! show DAT array\n    write( ,’(” Today is:”, (i0:,”:”))’)dat\n    ! the %p and %P fields are supported by fmtdate(3f)\n    write( , )&\n    & now(‘The phase of the moon is %p, with a fullness of %P’)\n    write( ,’(1x, (a))’,advance=’no’)&\n    & ‘The phase of the moon is ‘,trim( phase_of_moon(dat)),’,’\n    write(*,’(1x,a,i0,a)’)’with a fullness of ‘,moon_fullness(dat),’%’\n   end program demo_phase_of_moon Sample output: Today is : 2018 : 11 : 3 :- 240 : 20 : 18 : 44 : 245 The phase of the moon is Waning crescent , with a fullness of - 30 % The phase of the moon is Waning crescent , with a fullness of - 30 % AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: datin (8) Return Value character(len=:),allocatable Contents Source Code phase_of_moon Source Code function phase_of_moon ( datin ) implicit none ! ident_27=\"@(#)M_time::phase_of_moon(3f): return name for phase of moon for given date\" integer , intent ( in ) :: datin ( 8 ) character ( len = :), allocatable :: phase_of_moon real ( kind = realtime ), parameter :: syndonic_month = 2 9.530588853_realtime ! average period of a lunar cycle, or days per lunation integer , parameter :: reference ( * ) = [ 2000 , 1 , 6 , 0 , 18 , 14 , 0 , 0 ] ! new moon of January 2000 was January 6, 18:14 UTC. character ( len = 20 ), parameter :: phase_names ( * ) = [ \"New            \" , \"Waxing crescent\" , & \"First quarter  \" , \"Waxing gibbous \" , & \"Full           \" , \"Waning gibbous \" , & \"Last quarter   \" , \"Waning crescent\" ] real ( kind = realtime ), parameter :: phase_length = syndonic_month / 8_realtime ! days per phase integer :: phase real ( kind = realtime ) :: days days = d2j ( datin ) - d2j ( reference ) ! days between reference date and input date days = mod ( days + phase_length / 2.0_dp , syndonic_month ) ! modulo calculation of which phase rounding up if ( days . lt . 0 ) days = days + syndonic_month ! correct for days before reference date phase = int ( days * ( size ( phase_names ) / syndonic_month )) + 1 ! index into phase names phase_of_moon = phase_names ( phase ) end function phase_of_moon","tags":"","loc":"proc/phase_of_moon.html"},{"title":"sec2days – M_time","text":"public function sec2days(seconds, crop) result(dhms) Uses iso_fortran_env NAME sec2days(3f) - [M_time:DURATION] convert seconds to string of form\ndd-hh:mm:ss\n(LICENSE:PD) SYNOPSIS function sec2days(seconds,crop) result ( dhms ) real ( kind = realtime ), intent ( in ) :: seconds or integer , intent ( in ) :: seconds or real , intent ( in ) :: seconds or character ( len = * ) :: seconds logical , intent ( in ), optional :: crop character ( len =:), allocatable :: dhms DESCRIPTION Given a number of seconds convert it to a string of the form dd-hh:mm:ss where dd is days, hh hours, mm minutes and ss seconds. OPTIONS seconds number of seconds to convert to string of form dd - hh : mm : ss . May be of type INTEGER , REAL , REAL ( KIND = REALTIME ), or CHARACTER . CHARACTER strings may be of the form [ NNd ][ NNh ][ NNm ][ NNs ][ NNw ] . Case , spaces and underscores are ignored . Allowed aliases for d , h , m , and s units are d - days , day m - minutes , minute , min h - hours , hour , hrs , hr s - seconds , second , sec The numeric values may represent floating point numbers . crop if . true ., remove leading zero day values or day and hour values . Optional , defaults to . false . . RETURNS dmhs       the returned string of form [d:h:]m:s EXAMPLE Sample Program : program demo_sec2days use M_time , only : sec2days implicit none integer , parameter :: dp = kind ( 0 . 0 d0 ) write ( * , * ) sec2days ( 129860 ) write ( * , * ) sec2days ( 80000 . 0 _dp ) write ( * , * ) sec2days ( 80000 . 0 , crop = . true . ) write ( * , * ) sec2days ( ' 1 day 2.0hr 100 min 300.0seconds ' ) end program demo_sec2days results : 1 - 12 : 04 : 20 0 - 22 : 13 : 20 22 : 13 : 20 1 - 03 : 45 : 00 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: seconds logical, intent(in), optional :: crop Return Value character(len=:),allocatable Contents Source Code sec2days Source Code function sec2days ( seconds , crop ) result ( dhms ) use , intrinsic :: iso_fortran_env , only : int64 ! ident_25=\"@(#)M_time::sec2days(3f): converts seconds or string of form IId JJh KKm LLs to string showing days of form D-HH:MM:SS\" ! on this platform, (select_int_kind(i),i=1,100) returns ! 1:2=1 ,3:4=2 ,5:9=4 ,10:18= 8 ,19:38=16 ,39:=-1 !integer,parameter        :: k(38)=[(selected_int_kind(i),i=1,38)] integer :: i class ( * ), intent ( in ) :: seconds logical , intent ( in ), optional :: crop character ( len = :), allocatable :: dhms real ( kind = realtime ), parameter :: units_hl ( 4 ) = [ 8640 0.0_dp , 360 0.0_dp , 6 0.0_dp , 1.0_dp ] character ( len = 40 ) :: scratch integer ( kind = int64 ) :: days , hours , minutes , secsleft integer , parameter :: one_day = 86400 integer , parameter :: one_hour = 3600 integer , parameter :: one_minute = 60 logical :: crop_local integer :: iprint logical :: negative integer :: ilast character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: array (:) doubleprecision :: dtime !  Convert input value to nearest integer !  Notice that the value SECONDS can be any of several types ( INTEGER,REAL,REAL(KIND=REALTIME)) select type ( seconds ) type is ( integer ); secsleft = seconds type is ( real ); secsleft = nint ( seconds ) type is ( real ( kind = realtime )); secsleft = nint ( seconds ) type is ( character ( len =* )) ! note _ is removed from input strings to allow use of _ every three digits in a number as sometimes seen in Java, perl, ... strlocal = compact ( lower ( transliterate ( seconds , \" _',\" , '' )), '' ) // '                ' ! add whitespace to make room for spaces call substitute ( strlocal , 'days' , 'd' ) ! from long names to short names substitute common aliases for units call substitute ( strlocal , 'day' , 'd' ) call substitute ( strlocal , 'hours' , 'h' ) call substitute ( strlocal , 'hour' , 'h' ) call substitute ( strlocal , 'hrs' , 'h' ) call substitute ( strlocal , 'hr' , 'h' ) call substitute ( strlocal , 'minutes' , 'm' ) call substitute ( strlocal , 'minute' , 'm' ) call substitute ( strlocal , 'min' , 'm' ) call substitute ( strlocal , 'seconds' , 's' ) call substitute ( strlocal , 'second' , 's' ) call substitute ( strlocal , 'secs' , 's' ) call substitute ( strlocal , 'sec' , 's' ) call substitute ( strlocal , 'weeks' , 'w' ) call substitute ( strlocal , 'week' , 'w' ) call substitute ( strlocal , 'wks' , 'w' ) call substitute ( strlocal , 'wk' , 'w' ) call substitute ( strlocal , 's' , 's ' ) ! assuming only one suffix character and not too many to exceed length of strlocal call substitute ( strlocal , 'm' , 'm ' ) call substitute ( strlocal , 'h' , 'h ' ) call substitute ( strlocal , 'd' , 'd ' ) call substitute ( strlocal , 'w' , 'w ' ) dtime = 0.0_dp call split ( strlocal , array , ' ' ) do i = 1 , size ( array ) ilast = len_trim ( array ( i )) select case ( array ( i )( ilast : ilast )) case ( 'w' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) * 7 case ( 'd' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) case ( 'h' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 2 ) case ( 'm' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 3 ) case ( 's' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 4 ) case default dtime = dtime + s2v ( array ( i )) end select enddo secsleft = int ( dtime , kind = int64 ) end select if ( present ( crop )) then ! whether to trim cases where(days=0) and (hours=0 when days=0) from output or always show dd-hh:mm:ss crop_local = crop else crop_local = . false . endif if ( secsleft . lt . 0 ) then secsleft =- secsleft negative = . true . else negative = . false . endif iprint = 4 days = secsleft / one_day ! get whole number of days if ( days . eq . 0 ) iprint = 3 secsleft = secsleft - days * one_day ! calculate remainder hours = secsleft / one_hour ! get whole number of hours if ( days . eq . 0. and . hours . eq . 0 ) iprint = 2 secsleft = secsleft - hours * one_hour minutes = secsleft / one_minute ! get whole number of minutes secsleft = secsleft - minutes * one_minute if (. not . crop_local ) then iprint = 4 endif select case ( iprint ) ! select format if cropping is on and leading zero values are present case ( 2 ) write ( scratch , '(i2.2,\":\",i2.2)' ) minutes , secsleft case ( 3 ) write ( scratch , '(i2.2,\":\",i2.2,\":\",i2.2)' ) hours , minutes , secsleft case default write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2)' ) days , hours , minutes , secsleft end select if ( negative ) then dhms = '-' // trim ( scratch ) else dhms = trim ( scratch ) endif end function sec2days","tags":"","loc":"proc/sec2days.html"},{"title":"u2d – M_time","text":"public function u2d(unixtime) result(dat) NAME u2d(3f) - [M_time:UNIX_EPOCH] given Unix Epoch Time returns DAT\ndate-time array\n(LICENSE:PD) SYNOPSIS function u2d(unixtime) result ( dat ) class ( * ), intent ( in ), optional :: unixtime ! integer ! real ! real ( kind = realtime ) integer :: dat ( 8 ) DESCRIPTION Given Unix Epoch Time returns DAT date-time array OPTIONS unixtime The \" Unix Epoch \" time , or the number of seconds since 00 : 00 : 00 on January 1 st , 1970 , UTC . If not present , use current time . RETURNS dat       Integer array holding a \"DAT\" array, similar in structure\n          to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n             dat=[ year,month,day,timezone,hour,&\n              & minutes,seconds,milliseconds] EXAMPLE Sample program : program demo_u2d use M_time , only : u2d , d2u , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0 . 0 d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) ! get the date using intrinsic call date_and_time ( values = dat ) ! convert today to Julian Date today = d2u ( dat ) write ( * , * ) ' Today= ' , fmtdate ( u2d ( today )) ! subtract day write ( * , * ) ' Yesterday= ' , fmtdate ( u2d ( today - 86400 . 0 _dp )) ! add day write ( * , * ) ' Tomorrow= ' , fmtdate ( u2d ( today + 86400 . 0 _dp )) end program demo_u2d results : Today = Tuesday , July 19 th , 2016 11 : 10 : 08 AM Yesterday = Monday , July 18 th , 2016 11 : 10 : 08 AM Tomorrow = Wednesday , July 20 th , 2016 11 : 10 : 08 AM AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: unixtime Return Value integer(8) Contents Source Code u2d Source Code function u2d ( unixtime ) result ( dat ) ! ident_24=\"@(#)M_time::u2d(3f): Given Unix Epoch Time returns DAT date-time array\" class ( * ), intent ( in ), optional :: unixtime integer :: dat ( 8 ) real ( kind = realtime ) :: local_unixtime integer :: ierr if ( present ( unixtime )) then select type ( unixtime ) type is ( integer ); local_unixtime = unixtime type is ( integer ( kind = int64 )); local_unixtime = unixtime type is ( real ); local_unixtime = unixtime type is ( real ( kind = realtime )); local_unixtime = unixtime end select else local_unixtime = d2u () endif call unix_to_date ( local_unixtime , dat , ierr ) end function u2d","tags":"","loc":"proc/u2d.html"},{"title":"v2mo – M_time","text":"public function v2mo(imonth) result(month_name) NAME v2mo(3f) - [M_time:MONTH_NAME] returns the month name of a Common\nmonth number\n(LICENSE:PD) SYNOPSIS function v2mo(imonth) result ( month_name ) integer , intent ( in ) :: imonth ! month number ( 1 - 12 ) character ( len =:), allocatable :: month_name ! month name DESCRIPTION Given a Common Calendar month number, return the name of the month\n   as a string. OPTIONS imonth Common month number ( 1 - 12 ) . If out of the allowable range the month name returned will be ' UNKNOWN ' . RETURNS month_name  A string representing a month name or the word 'UNKNOWN' EXAMPLE Sample program : program demo_v2mo use M_time , only : v2mo implicit none integer :: i write ( * , * )( v2mo ( i ) , i = 1 , 13 ) end program demo_v2mo results : January February March April May June July August September October November December UNKNOWN . AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: imonth Return Value character(len=:),allocatable Contents Source Code v2mo Source Code function v2mo ( imonth ) result ( month_name ) ! ident_10=\"@(#)M_time::v2mo(3f): returns the month name of a Common month number\" ! JSU 2015-12-13 character ( len = :), allocatable :: month_name ! string containing month name or abbreviation. integer , intent ( in ) :: imonth ! the number of the month(1-12) character ( len =* ), parameter :: names ( 12 ) = [ & & 'January  ' , 'February ' , 'March    ' , 'April    ' , 'May      ' , 'June     ' , & & 'July     ' , 'August   ' , 'September' , 'October  ' , 'November ' , 'December ' ] select case ( imonth ) case ( 1 : 12 ); month_name = trim ( names ( imonth )) case default ; month_name = 'UNKNOWN' end select end function v2mo","tags":"","loc":"proc/v2mo.html"},{"title":"Easter – M_time","text":"public subroutine Easter(year, dat) NAME easter ( 3 f ) - [ M_time : ASTROLOGICAL ] calculate date for Easter given a year ( LICENSE : PD ) SYNOPSIS subroutine easter(year,dat) integer, intent(in)   :: year\n integer, intent(out)  :: dat DESCRIPTION The Date of Easter (Sunday) The algorithm is due to J.-M. Oudin (1940) and is reprinted\n   in the Explanatory Supplement to the Astronomical Almanac,\n   ed. P. K. Seidelmann (1992). See Chapter 12, “Calendars”, by\n   L. E. Doggett. The following are dates of Easter from 1980 to 2024: 1980  April  6        1995  April 16        2010  April  4\n    1981  April 19        1996  April  7        2011  April 24\n    1982  April 11        1997  March 30        2012  April  8\n    1983  April  3        1998  April 12        2013  March 31\n    1984  April 22        1999  April  4        2014  April 20\n    1985  April  7        2000  April 23        2015  April  5\n    1986  March 30        2001  April 15        2016  March 27\n    1987  April 19        2002  March 31        2017  April 16\n    1988  April  3        2003  April 20        2018  April  1\n    1989  March 26        2004  April 11        2019  April 21\n    1990  April 15        2005  March 27        2020  April 12\n    1991  March 31        2006  April 16        2021  April  4\n    1992  April 19        2007  April  8        2022  April 17\n    1993  April 11        2008  March 23        2023  April  9\n    1994  April  3        2009  April 12        2024  March 31 N.B. The date of Easter for the Eastern Orthodox Church may be different. OPTIONS year Year for which to calculate day that Easter falls on RESULTS dat Date array for noon on Easter for the specified year EXAMPLE Sample program: program demo_easter use M_time , only : easter , fmtdate implicit none integer :: year integer :: dat ( 8 ) ! year , month , day , tz , hour , minute , second , millisecond call date_and_time ( values = dat )  ! get current year year = dat ( 1 ) call easter ( year , dat ) write (*,*) fmtdate ( dat ,& \"Easter day: the %d day of %L in the year of our Lord %Y\" ) end program demo_easter Sample output: Easter day: the 16 th day of April in the year of our Lord 2017 U.S. Naval Observatory Astronomical Applications Department This code assembled by Alan Miller\n   Reference web site:\n   http://aa.usno.navy.mil/faq/docs/easter.html\n   Latest revision 8 April 2002 Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(out) :: dat (8) Contents Source Code Easter Source Code SUBROUTINE Easter ( year , dat ) implicit none ! ident_29=\"@(#)M_time::easter(3f): calculate date for Easter given a year\" integer , intent ( in ) :: year integer , intent ( out ) :: dat ( 8 ) ! year,month,day,tz,hour,minute,second,millisecond integer :: day , month integer :: c , i , j , k , l , n c = year / 100 n = year - 19 * ( year / 19 ) k = ( c - 17 ) / 25 i = c - c / 4 - ( c - k ) / 3 + 19 * n + 15 i = i - 30 * ( i / 30 ) i = i - ( i / 28 ) * ( 1 - ( i / 28 ) * ( 29 / ( i + 1 )) * ( ( 21 - n ) / 11 ) ) j = year + year / 4 + i + 2 - c + c / 4 j = j - 7 * ( j / 7 ) l = i - j month = 3 + ( l + 40 ) / 44 day = l + 28 - 31 * ( month / 4 ) ! fill out a date_and_time array dat = getnow () ! get current year dat = [ year , month , day , dat ( 4 ), 12 , 0 , 0 , 0 ] end subroutine Easter","tags":"","loc":"proc/easter.html"},{"title":"box_month – M_time","text":"public subroutine box_month(dat, calen) NAME box_month(3f) - [M_time:DATE_PRINTING] create specified month in a\ncharacter array\n(LICENSE:PD) SYNOPSIS subroutine box_month(dat,calen)\n\n integer,intent(in)    :: dat(8)\n character(len=21)     :: calen(8) DESCRIPTION box_month(3f) uses a year and month from a date array to populate\n   a small character array with a calendar representing the month. OPTIONS dat  \"DAT\" array (an integer array of the same format as\n      the array returned by the intrinsic DATE_AND_TIME(3f))\n      describing the date to be used to specify what calendar\n      month to produce.\n\n             dat=[ year,month,day,timezone,hour,&\n              & minutes,seconds,milliseconds] RETURNS calen  returned character array holding a display of the\n       specified month EXAMPLE Sample program : program demo_box_month use M_time , only : box_month implicit none integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) call date_and_time ( values = dat ) call box_month ( dat , calendar ) write ( * , ' (a) ' ) calendar end program demo_box_month results : > July 2016 > Mo Tu We Th Fr Sa Su > 1 2 3 > 4 5 6 7 8 9 10 > 11 12 13 14 15 16 17 > 18 19 20 21 22 23 24 > 25 26 27 28 29 30 31 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) character(len=wklen) :: calen (8) Contents Source Code box_month Source Code subroutine box_month ( dat , calen ) ! ident_20=\"@(#)M_time::box_month(3f): generate month specified by DAT date-time array in character array\" integer , parameter :: wklen = 3 * 7 !----------------------------------------------------------------------------------------------------------------------------------- ! uses year and month from date array DAT to populate a small character array with a calendar representing the month integer , intent ( in ) :: dat ( 8 ) character ( len = wklen ) :: calen ( 8 ) !----------------------------------------------------------------------------------------------------------------------------------- real ( kind = realtime ) :: julian integer :: weekday integer :: dat_1st ( 8 ) integer :: dat_nextday ( 8 ) integer :: location , ierr , i !----------------------------------------------------------------------------------------------------------------------------------- calen (:) = '                    ' ! initialize output array to spaces dat_1st = [ dat ( 1 ), dat ( 2 ), 1 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! create date array for first day in month specified call dow ( dat_1st , weekday , ierr = ierr ) ! return the day of the week for first of month !----------------------------------------------------------------------------------------------------------------------------------- calen ( 1 ) = adjustc ( v2mo ( dat ( 2 )) // ' ' // v2s ( dat ( 1 )), len ( calen ( 1 ))) ! build first line with month and year centered calen ( 2 ) = 'Mo Tu We Th Fr Sa Su' ! build second line with days of week !----------------------------------------------------------------------------------------------------------------------------------- location = 1 + (( weekday - 1 ) * 3 ) ! if data were one row where would 3-character day value start? call date_to_julian ( dat_1st , julian , ierr ) ! get Julian Date for 1st day of month MNTH : do i = 1 , 31 ! put dates into rest of array starting at third line write ( calen ( location / wklen + 3 )( mod ( location , wklen ):), '(i2)' ) i if ( i . ge . 28 ) then ! is tomorrow in another month? call julian_to_date ( julian + i , dat_nextday , ierr ) if ( dat_nextday ( 2 ). ne . dat ( 2 )) then exit MNTH endif endif location = location + 3 enddo MNTH !----------------------------------------------------------------------------------------------------------------------------------- end subroutine box_month","tags":"","loc":"proc/box_month.html"},{"title":"d2w – M_time","text":"public subroutine d2w(dat, iso_year, iso_week, iso_weekday, iso_name) NAME d2w(3f) - [M_time:WEEK_OF_YEAR] calculate iso-8601 Week-numbering\nyear date yyyy-Www-d given DAT date-time array\n(LICENSE:PD) SYNOPSIS subroutine d2w(dat,iso_year,iso_week,iso_weekday,iso_name)\n\n integer,intent(in)              :: dat(8)     ! input date array\n integer,intent(out)             :: iso_year, iso_week, iso_weekday\n character(len=10),intent(out)   :: iso_name DESCRIPTION Given a “DAT” array defining a date and time, return the ISO-8601\n   Week in two formats – as three integer values defining the ISO year,\n   week of year and weekday; and as a string of the form “yyyy-Www-d”. OPTIONS dat          \"DAT\" array (an integer array of the same format as\n             the array returned by the intrinsic DATE_AND_TIME(3f))\n             describing the date, which is the basic time description\n             used by the other M_time(3fm) module procedures. RETURNS iso_year ISO - 8601 year number for the given date iso_week ISO - 8601 week number for the given date iso_weekday ISO - 8601 weekday number for the given date iso_name ISO - 8601 Week string for the data in the form \" yyyy-Www-d \" . EXAMPLE Sample program : program demo_d2w use M_time , only : d2w implicit none integer :: dat ( 8 ) ! input date array integer :: iso_year , iso_week , iso_weekday character ( len = 10 ) :: iso_name call date_and_time ( values = dat ) call d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) write ( * , ' (\"ISO-8601 Week:   \",a) ' ) iso_name write ( * , ' (a,i0) ' ) ' ISO-8601 year ' , iso_year write ( * , ' (a,i0) ' ) ' ISO-8601 week ' , iso_week write ( * , ' (a,i0) ' ) ' ISO-8601 weekday ' , iso_weekday end program demo_d2w results : ISO - 8601 Week : 2016 - W29 - 1 ISO - 8601 year 2016 ISO - 8601 week 29 ISO - 8601 weekday 1 DEFINITION The ISO-8601 date and time standard was issued by the International\n   Organization for Standardization (ISO). It is used (mainly) in\n   government and business for fiscal years, as well as in timekeeping.\n   The system specifies a week year atop the Gregorian calendar by defining\n   a notation for ordinal weeks of the year. o An ISO week-numbering year (also called ISO year informally) has 52\n     or 53 full weeks. That is 364 or 371 days instead of the usual 365\n     or 366 days.\n   o The extra week is referred to here as a leap week, although ISO-8601\n     does not use this term.  Weeks start with Monday.\n   o The first week of a year is the week that contains the first Thursday\n     of the year (and, hence, always contains 4 January).  ISO week year\n     numbering therefore slightly deviates from the Gregorian for some days\n     close to January 1st. CALCULATION The ISO-8601 week number of any date can be calculated, given its\n   ordinal date (i.e. position within the year) and its day of the week. METHOD Using ISO weekday numbers ( running from 1 for Monday to 7 for Sunday ) , subtract the weekday from the ordinal date , then add 10 . Divide the result by 7 . Ignore the remainder ; the quotient equals the week number . If the week number thus obtained equals 0 , it means that the given date belongs to the preceding ( week - based ) year . If a week number of 53 is obtained , one must check that the date is not actually in week 1 of the following year . These two statements are assumed true when correcting the dates around January 1 st : o The number of weeks in a given year is equal to the corresponding week number of 28 December . o January 4 th is always in the first week . ISO_NAME Week date representations are in the format YYYYWww-D. o [ YYYY ] indicates the ISO week - numbering year which is slightly different from the traditional Gregorian calendar year . o [ Www ] is the week number prefixed by the letter W , from W01 through W53 . o [ D ] is the weekday number , from 1 through 7 , beginning with Monday and ending with Sunday . For example, the Gregorian date 31 December 2006 corresponds to the\n   Sunday of the 52nd week of 2006, and is written 2006-W52-7 (extended form)\n or\n 2006W527 (compact form). REFERENCE From Wikipedia, the free encyclopedia 2015-12-19 AUTHOR John S. Urban, 2015-12-19 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) integer, intent(out) :: iso_year integer, intent(out) :: iso_week integer, intent(out) :: iso_weekday character(len=10), intent(out) :: iso_name Contents Source Code d2w Source Code subroutine d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) ! ident_18=\"@(#)M_time::d2w(3f): DAT date-time array to iso-8601 Week-numbering year date yyyy-Www-d\" integer , intent ( in ) :: dat ( 8 ) ! input date array integer , intent ( out ) :: iso_year , iso_week , iso_weekday character ( len = 10 ), intent ( out ) :: iso_name integer :: shared_weekday integer :: last_week_this_year integer :: dec28_lastyear ( 8 ) ! December 28th is always in last week integer :: dec28_thisyear ( 8 ) ! December 28th is always in last week character ( len = 9 ) :: day integer :: ierr iso_year = dat ( 1 ) ! initially assume the iso_year is the same as the data array year iso_week = uncorrected_week_of_year ( dat ) ! this is the week number unless around January 1st iso_weekday = shared_weekday ! this is the number of the day of the week assuming Monday=1 dec28_thisyear = [ dat ( 1 ), 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week; use this to get number of weeks last_week_this_year = uncorrected_week_of_year ( dec28_thisyear ) ! get the number of the last week of the year (52 or 53) ! correct dates around January 1st if ( iso_week < 1 ) then ! if week < 1 then week = lastWeek(year -1) dec28_lastyear = [ dat ( 1 ) - 1 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week, we want its week number iso_week = uncorrected_week_of_year ( dec28_lastyear ) ! got the week number for the last week of last year (52 or 53) iso_year = dat ( 1 ) - 1 ! our date belongs to last year elseif ( iso_week > last_week_this_year ) then ! if week > lastweek(year) then week = 1 iso_week = iso_week - last_week_this_year ! our date belongs to next year iso_year = dat ( 1 ) + 1 endif write ( iso_name , '(i4.4,\"-W\",i2.2,\"-\",i1)' ) iso_year , iso_week , iso_weekday ! create ISO string designation for our date contains function uncorrected_week_of_year ( datin ) implicit none integer :: uncorrected_week_of_year integer , intent ( in ) :: datin ( 8 ) integer :: ordinal call dow ( datin , shared_weekday , day , ierr ) ! formula needs day of week 1..7 where Monday=1 ordinal = d2o ( datin ) ! formula needs ordinal day of year where Jan 1st=1 uncorrected_week_of_year = ( ordinal - shared_weekday + 10 ) / 7 end function uncorrected_week_of_year end subroutine d2w","tags":"","loc":"proc/d2w.html"},{"title":"date_to_julian – M_time","text":"public subroutine date_to_julian(dat, julian, ierr) NAME date_to_julian(3f) - [M_time:JULIAN] converts DAT date-time array to\nJulian Date\n(LICENSE:PD) SYNOPSIS subroutine date_to_julian(dat,juliandate,ierr)\n\n integer,intent(in)               :: dat(8)\n real(kind=realtime),intent(out)  :: juliandate\n integer,intent(out)              :: ierr DESCRIPTION Converts a DAT date-time array to a Unix Epoch Time (UET) value.\n   UET is the number of seconds since 00:00 on January 1st, 1970, UTC. OPTIONS dat   Integer array holding a \"DAT\" array, similar in structure\n      to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n       dat=[ year,month,day,timezone,hour,&\n           & minutes,seconds,milliseconds] RETURNS juliandate A Julian Ephemeris Date ( JED ) is the number of days since noon ( not midnight ) on January 1 st , 4713 BC . ierr Error code . If 0 no error occurred . EXAMPLE Sample Program : program demo_date_to_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: juliandate integer :: ierr ! generate DAT array call date_and_time ( val ues = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , * ) 'Julian Date is ' , juliandate write ( * , * ) 'ierr is ' , ierr end program demo_date_to_julian results : Today is : 2016 : 7 : 19 :- 240 : 11 : 3 : 13 : 821 Julian Date is 2457589.1272432986 ierr is 0 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) AUTHOR:    John S. Urban VERSION:   2.0 2022-01-16 REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 real(kind=realtime), intent(out) :: julian integer, intent(out) :: ierr Contents Source Code date_to_julian Source Code subroutine date_to_julian ( dat , julian , ierr ) !----------------------------------------------------------------------------------------------------------------------------------- !> !! AUTHOR:    John S. Urban !!##VERSION:   2.0 2022-01-16 !! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 ! * There is no year zero ! * Julian Date must be non-negative ! * Julian Date starts at noon; while Civil Calendar date starts at midnight !----------------------------------------------------------------------------------------------------------------------------------- ! ident_2=\"@(#)M_time::date_to_julian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date\" integer , intent ( in ) :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) real ( kind = realtime ), intent ( out ) :: julian ! Julian Date (non-negative, but may be non-integer) integer , intent ( out ) :: ierr ! Error return: 0 =successful execution,-1=invalid year,-2=invalid month,-3=invalid day ! -4=invalid date (29th Feb, non leap-year) integer :: year , month , day , utc , hour , minute real ( kind = realtime ) :: second integer :: A , Y , M , JDN !----------------------------------------------------------------------------------------------------------------------------------- year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0_dp ! Second   ! correction for time zone and milliseconds !----------------------------------------------------------------------------------------------------------------------------------- julian = - HUGE ( 99999 ) ! this is the date if an error occurs and IERR is < 0 !----------------------------------------------------------------------------------------------------------------------------------- if ( year == 0 . or . year . lt . - 4713 ) then ierr =- 1 return endif !----------------------------------------------------------------------------------------------------------------------------------- !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or February, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian Calendar date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0_dp + dble ( minute ) / 144 0.0_dp + second / 8640 0.0_dp !----------------------------------------------------------------------------------------------------------------------------------- if ( julian . lt . 0.0_dp ) then ! Julian Day must be non-negative ierr = 1 else ierr = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine date_to_julian","tags":"","loc":"proc/date_to_julian.html"},{"title":"date_to_unix – M_time","text":"public subroutine date_to_unix(dat, unixtime, ierr) NAME date_to_unix(3f) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix\nEpoch Time\n(LICENSE:PD) SYNOPSIS subroutine date_to_unix(dat,unixtime,ierr)\n\n integer,intent(in)               :: dat(8)\n real(kind=realtime),intent(out)  :: unixtime\n integer,intent(out)              :: ierr DESCRIPTION Converts a DAT date-time array to a UET (Unix Epoch Time). OPTIONS dat   Integer array holding a \"DAT\" array, similar in structure\n      to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n          dat=[ year,month,day,timezone,hour,&\n           & minutes,seconds,milliseconds] RETURNS unixtime The \" Unix Epoch \" time , or the number of seconds since 00 : 00 : 00 on January 1 st , 1970 , UTC . ierr Error code . If 0 no error occurred . EXAMPLE Sample program : program demo_date_to_unix use M_time , only : date_to_unix , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: unixtime integer :: ierr call date_and_time ( val ues = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat call date_to_unix ( dat , unixtime , ierr ) write ( * , * ) 'Unix Epoch time is ' , unixtime write ( * , * ) 'ierr is ' , ierr end program demo_date_to_unix results : Today is : 2016 : 7 : 18 :- 240 : 23 : 44 : 20 : 434 Unix Epoch time is 1468899860.4340105 ierr is 0 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) real(kind=realtime), intent(out) :: unixtime integer, intent(out) :: ierr Contents Source Code date_to_unix Source Code subroutine date_to_unix ( dat , unixtime , ierr ) ! ident_4=\"@(#)M_time::date_to_unix(3f): Convert DAT date-time array to Unix Epoch Time\" integer , intent ( in ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME real ( kind = realtime ), intent ( out ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! return 0 on success, otherwise 1 real ( kind = realtime ) :: julian real ( kind = realtime ), save :: julian_at_epoch logical , save :: first = . true . integer , parameter :: ref ( 8 ) = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Convert zero of Unix Epoch Time to Julian Date and save call date_to_julian ( ref , julian_at_epoch , ierr ) if ( ierr . ne . 0 ) return ! Error first = . false . endif !----------------------------------------------------------------------------------------------------------------------------------- call date_to_julian ( dat , julian , ierr ) if ( ierr . ne . 0 ) return ! Error unixtime = ( julian - julian_at_epoch ) * secday end subroutine date_to_unix","tags":"","loc":"proc/date_to_unix.html"},{"title":"dow – M_time","text":"public subroutine dow(values, weekday, day, ierr) NAME dow ( 3 f ) - [ M_time : DAY_OF_WEEK ] given a date - time array DAT return the day of the week ( LICENSE : PD ) SYNOPSIS subroutine dow(values, weekday, day, ierr)\n\n integer,intent(in) :: values(8)\n integer,intent(out),optional :: weekday\n character(len=*),intent(out),optional :: day\n integer,intent(out),optional :: ierr DESCRIPTION Given a date array DAT\n   return the day of the week as a number and a name, Mon=1. OPTIONS values   \"DAT\" array (an integer array of the same format as\n         the array returned by the intrinsic DATE_AND_TIME(3f))\n         describing the date to be used to calculate the day\n         of the week. RETURNS weekday The numeric day of the week , starting with Monday = 1 . Optional . day The name of the day of the week . Optional . ierr Error code o [ 0 ] correct o [ - 1 ] invalid input date o [ - 2 ] neither day nor weekday return values were requested . If the error code is not returned and an error occurs , the program is stopped . EXAMPLE Sample program : program demo_dow use M_time , only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) call dow ( dat , weekday , day , ierr ) write ( * , ' (a,i0) ' ) ' weekday= ' , weekday write ( * , ' (a,a) ' ) ' day= ' , trim ( day ) write ( * , ' (a,i0) ' ) ' ierr= ' , ierr end program demo_dow results : weekday = 1 day = Monday ierr = 0 AUTHOR John S. Urban, 2015-12-19 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: values (8) integer, intent(out), optional :: weekday character(len=*), intent(out), optional :: day integer, intent(out), optional :: ierr Contents Source Code dow Source Code subroutine dow ( values , weekday , day , ierr ) ! ident_17=\"@(#)M_time::dow(3f): Given DAT date-time array return the day of the week\" integer , intent ( in ) :: values ( 8 ) ! date and time array used to get time zone integer , intent ( out ), optional :: weekday ! The day of the week, 1 = Monday, 7 = Sunday character ( len =* ), intent ( out ), optional :: day ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9 integer , intent ( out ), optional :: ierr ! Error code,0=correct,-1=invalid input date,-2=neither day nor weekday specified real ( kind = realtime ) :: julian ! the Julian Date for which the weekday is required, integer :: iweekday integer :: ierr_local call date_to_julian ( values , julian , ierr_local ) ! need Julian Date to calculate day of week for first day of month ierr_local = 0 iweekday = 0 ! bad value. if ( julian < 0 ) then ierr_local = - 1 elseif (. not . present ( day ). and . . not . present ( weekday )) then ierr_local =- 2 else ! Julian Day is in Z time zone and starts at noon so add 1/2 day; and add time zone iweekday = mod ( int (( julian + dble ( values ( 4 ) / 6 0.0_dp / 2 4.0_dp ) + 0.5_dp ) + 1.0_dp ), 7 ) iweekday = iweekday + 1 ! change range from 0 to 6 to 1 to 7 iweekday = mod ( iweekday + 5 , 7 ) + 1 ! change from Sunday=1 to Monday=1 if ( present ( day )) then select case ( iweekday ) case ( 1 ) ; day = 'Monday' case ( 2 ) ; day = 'Tuesday' case ( 3 ) ; day = 'Wednesday' case ( 4 ) ; day = 'Thursday' case ( 5 ) ; day = 'Friday' case ( 6 ) ; day = 'Saturday' case ( 7 ) ; day = 'Sunday' case default ; day = 'error' end select endif endif if ( present ( ierr )) then ierr = ierr_local elseif ( ierr_local . ne . 0 ) then write ( * , * ) '*dow* Unprocessed Error ' , ierr_local , ' stopping.' stop 2 endif if ( present ( weekday )) then weekday = iweekday endif end subroutine dow","tags":"","loc":"proc/dow.html"},{"title":"fmtdate_usage – M_time","text":"public subroutine fmtdate_usage(indent) NAME fmtdate_usage(3f) - [M_time:DATE_PRINTING] display macros recognized\nby fmtdate(3f) and now(3f)\n(LICENSE:PD) SYNOPSIS subroutine fmtdate_usage(indent)\n\n integer,intent(in),optional      :: indent DESCRIPTION The fmtdate_usage(3f) subroutine displays the formatting options\n   available for use in procedures such as fmtdate(3f) and now(3f).\n   It is typically used to produce up-to-date help text in commands\n   that use the M_time(3fm) module, so that the formatting information\n   only needs maintained in one place (this routine) and is easily\n   displayed so users can quickly obtain a description of the formatting\n   macros. OPTIONS indent how many spaces to prefix the output with , so that calling programs can position the output . Default for this optional parameter is three ( 3 ) . EXAMPLE Sample Program : program demo_fmtdate_usage use M_time , only : fmtdate_usage implicit none call fmtdate_usage () ! see all formatting options end program demo_fmtdate_usage results ( actually call the routine to ensure this is up to date ) : Description Example Base time array : ( 1 ) % Y -- year , yyyy 2016 ( 2 ) % M -- month of year , 01 to 12 07 ( 3 ) % D -- day of month , 01 to 31 29 %d -- day of month , with suffix ( 1 st , 2 nd ,...) 29 th ( 4 ) % Z -- minutes from UTC -0240 %z -- -+ hh : mm from UTC -04 : 00 % T -- -+ hhmm from UTC -0400 ( 5 ) %h -- hours , 00 to 23 10 % H -- hour ( 1 to 12 , or twelve - hour clock ) 10 % N -- midnight < AM <= noon ; noon <= PM < midnight AM ( 6 ) %m -- minutes , 00 to 59 54 ( 7 ) %s -- sec , 00 to 59 08 ( 8 ) %x -- milliseconds 000 to 999 521 Conversions : % E -- Unix Epoch time 1469804048.5220029 %e -- integer value of Unix Epoch time 1469804049 % J -- Julian date 2457599.121 %j -- integer value of Julian Date ( Julian Day ) 2457599 % O -- Ordinal day ( day of year ) 211 %o -- Whole days since Unix Epoch date 17011 % U -- day of week , 1..7 Sunday = 1 6 %u -- day of week , 1..7 Monday = 1 5 %i -- ISO week of year 1..53 30 % I -- iso -8601 week - numbering date ( yyyy - Www - d ) 2016 - W30 -5 Names : %l -- abbreviated month name Jul % L -- full month name July %w -- first three characters of weekday Fri % W -- weekday name Friday %p -- phase of moon New % P -- percent of way from new to full moon -1 % Literals : %% -- a literal % % %t -- tab character %b -- blank character % B -- exclamation ( bang ) character %n -- new line ( system dependent ) %q -- single quote ( apostrophe ) % Q -- double quote Program timing : %c -- CPU_TIME ( 3f ) output .21875000000000000 % C -- number of times this routine is used 1 % S -- seconds since last use of this format .0000000000000000 %k -- time in seconds from SYSTEM_CLOCK ( 3f ) 723258.812 % K -- time in clicks from SYSTEM_CLOCK ( 3f ) 723258812 If no percent ( % ) is found in the format one of several alternate substitutions occurs . If the format is composed entirely of one of the following keywords the following substitutions occur : \"iso-8601\" , \"iso\" ==> % Y -% M -% DT %h : %m : %s%z \"iso-8601W\" , \"isoweek\" ==> % I 2016 - W30 -5 \"sql\" ==> \"%Y-%M-%D %h:%m:%s.%x\" \"sqlday\" ==> \"%Y-%M-%D\" \"sqltime\" ==> \"%h:%m:%s.%x\" \"rfc-2822\" ==> %w , % D %l % Y %h : %m : %s % T \"rfc-3339\" ==> % Y -% M -% DT %h : %m : %s%z \"date\" ==> %w %l % D %h : %m : %s UTC %z % Y \"short\" ==> %w , %l %d , % Y % H : %m : %s % N UTC %z \"long\" , \" \" ==> % W , % L %d , % Y % H : %m : %s % N UTC %z \"suffix\" ==> % Y % D % M %h%m%s \"formal\" ==> The %d of % L % Y \"lord\" ==> the %d day of % L in the year of our Lord % Y \"easter\" ==> FOR THE YEAR OF THE CURRENT DATE : Easter day : the %d day of % L in the year of our Lord % Y \"all\" ==> A SAMPLE OF DATE FORMATS otherwise the following words are replaced with the most common macros : numeric values : year % Y 2016 month % M 07 day % D 29 hour %h 10 minute %m 54 second %s 08 timezone % T 0400 epoch %e 1469804049 julian %j 2457599 ordinal % O 211 weekday %u 5 string values : MONTH % L July Month %l Jul WEEKDAY % W Thursday Weekday %w Thu DAY %d 7 th TIMEZONE %z -04 : 00 Timezone % Z -240 GOOD % N AM HOUR % H 10 if none of these keywords are found then every letter that is a macro is assumed to have an implied percent in front of it . For example : YMDhms ==> % Y % M % D %h%m%s ==> 20160729105408 AUTHOR John S. Urban, 2015-10-24 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: indent Contents Source Code fmtdate_usage Source Code subroutine fmtdate_usage ( indent ) ! ident_15=\"@(#)M_time::fmtdate_usage(3f): display macros recognized by fmtdate(3f)\" integer , intent ( in ), optional :: indent character ( len = 128 ), allocatable :: usage (:) integer :: i , ii character ( len = :), allocatable :: blanks if ( present ( indent )) then ! set indent to passed value or, if value is not present, set indent to 3 ii = indent else ii = 3 endif blanks = repeat ( ' ' , ii ) ! define a prefix string to create specified indent usage = [ CHARACTER ( LEN = 128 ) :: & ! 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890 123456789 123456789 123456789 123456789 12345678 & 'Description                                        Example%b ' ,& & '%b                                                           ' ,& & '%bBase time array:                                           ' ,& & ' (1) %%Y -- year, yyyy                                %Y     ' ,& & ' (2) %%M -- month of year, 01 to 12                   %M     ' ,& & ' (3) %%D -- day of month, 01 to 31                    %D     ' ,& & '     %%d -- day of month, with suffix (1st, 2nd,...)  %d     ' ,& & ' (4) %%Z -- minutes from UTC                          %Z     ' ,& & '     %%z -- -+hh:mm from UTC                          %z     ' ,& & '     %%T -- -+hhmm  from UTC                          %T     ' ,& & ' (5) %%h -- hours, 00 to 23                           %h     ' ,& & '     %%H -- hour (1 to 12, or twelve-hour clock)      %H     ' ,& & '     %%N -- midnight< AM <=noon; noon<= PM <midnight  %N     ' ,& & ' (6) %%m -- minutes, 00 to 59                         %m     ' ,& & ' (7) %%s -- sec, 00 to 59                             %s     ' ,& & ' (8) %%x -- milliseconds 000 to 999                   %x     ' ,& & '%bConversions:                                               ' ,& & '     %%E -- Unix Epoch time                           %E     ' ,& & '     %%e -- integer value of Unix Epoch time          %e     ' ,& & '     %%J -- Julian  date                              %J     ' ,& & '     %%j -- integer value of Julian Date(Julian Day)  %j     ' ,& & '     %%O -- Ordinal day (day of year)                 %O     ' ,& & '     %%o -- Whole days since Unix Epoch date          %o     ' ,& & '     %%U -- day of week, 1..7 Sunday=1                %U     ' ,& & '     %%u -- day of week, 1..7 Monday=1                %u     ' ,& & '     %%i -- ISO week of year 1..53                    %i     ' ,& & '     %%I -- iso-8601 week-numbering date(yyyy-Www-d)  %I     ' ,& & '%b Names:                                                    ' ,& & '     %%l -- abbreviated month name                    %l     ' ,& & '     %%L -- full month name                           %L     ' ,& & '     %%w -- first three characters of weekday         %w     ' ,& & '     %%W -- weekday name                              %W     ' ,& & '     %%p -- phase of moon                             %p     ' ,& & '     %%P -- percent of way from new to full moon      %P     ' ,& & '%b Literals:                                                 ' ,& & '     %%%% -- a literal %%                               %%   ' ,& & '     %%t -- tab character                             %t     ' ,& & '     %%b -- blank character                           %b     ' ,& & '     %%B -- exclamation(bang) character               %B     ' ,& & '     %%n -- new line (system dependent)               %n     ' ,& & '     %%q -- single quote (apostrophe)                 %q     ' ,& & '     %%Q -- double quote                              %Q     ' ,& & '%b Program timing:                                           ' ,& & '     %%c -- CPU_TIME(3f) output                       %c     ' ,& & '     %%C -- number of times this routine is used      %C     ' ,& & '     %%S -- seconds since last use of this format     %S     ' ,& & '     %%k -- time in seconds from SYSTEM_CLOCK(3f)     %k     ' ,& & '     %%K -- time in clicks from SYSTEM_CLOCK(3f)      %K     ' ,& & '%b                                                           ' ,& & '%bIf no percent (%%) is found in the format one of several   ' ,& & '%balternate substitutions occurs.                            ' ,& & '%b                                                           ' ,& & '%bIf the format is composed entirely of one of the following ' ,& & '%bkeywords the following substitutions occur:                ' ,& & '%b  \"iso-8601\",                                              ' ,& & '%b  \"iso\"        ==> %%Y-%%M-%%DT%%h:%%m:%%s%%z             %Y-%M-%DT%h:%m:%s%z     ' ,& & '%b  \"iso-8601W\",                                                                    ' ,& & '%b  \"isoweek\"    ==> %%I                              %I                            ' ,& & '%b  \"sql\"        ==> \"%%Y-%%M-%%D %%h:%%m:%%s.%%x\"          \"%Y-%M-%D %h:%m:%s.%x\"  ' ,& & '%b  \"sqlday\"     ==> \"%%Y-%%M-%%D\"                      \"%Y-%M-%D\"                  ' ,& & '%b  \"sqltime\"    ==> \"%%h:%%m:%%s.%%x\"                   \"%h:%m:%s.%x\"              ' ,& & '%b  \"rfc-2822\"   ==> %%w, %%D %%l %%Y %%h:%%m:%%s %%T        ' ,& & '%b                   %w, %D %l %Y %h:%m:%s %T                ' ,& & '%b  \"rfc-3339\"   ==> %%Y-%%M-%%DT%%h:%%m:%%s%%z             %Y-%M-%DT%h:%m:%s%z     ' ,& & '%b  \"date\"       ==> %%w %%l %%D %%h:%%m:%%s UTC%%z %%Y      ' ,& & '%b                   %w %l %D %h:%m:%s UTC%z %Y              ' ,& & '%b  \"short\"      ==> %%w, %%l %%d, %%Y %%H:%%m:%%s %%N UTC%%z' ,& & '%b                   %w, %l %d, %Y %H:%m:%s %N UTC%z         ' ,& & '%b  \"long\",\" \"   ==> %%W, %%L %%d, %%Y %%H:%%m:%%s %%N UTC%%z' ,& & '%b                   %W, %L %d, %Y %H:%m:%s %N UTC%z         ' ,& & '%b  \"suffix\"     ==> %%Y%%D%%M%%h%%m%%s                    %Y%D%M%h%m%s             ' ,& & '%b  \"formal\"     ==> The %%d of %%L %%Y                 The %d of %L %Y             ' ,& & '%b  \"lord\"       ==> the %%d day of %%L in the year of our Lord %%Y                 ' ,& & '%b                   the %d day of %L in the year of our Lord %Y                    ' ,& & '%b  \"easter\"     ==> FOR THE YEAR OF THE CURRENT DATE:       ' ,& & '%b                     Easter day: the %%d day of %%L in the year of our Lord %%Y   ' ,& & '%b  \"all\"        ==> A SAMPLE OF DATE FORMATS                ' ,& & '%botherwise the following words are replaced with the most   ' ,& & '%bcommon macros:                                             ' ,& & '%b   year          %%Y  %Y                                   ' ,& & '%b   month         %%M  %M                                   ' ,& & '%b   day           %%D  %D                                   ' ,& & '%b   timezone      %%z  %z                                   ' ,& & '%b   hour          %%h  %h                                   ' ,& & '%b   minute        %%m  %m                                   ' ,& & '%b   second        %%s  %s                                   ' ,& & '%b   millisecond   %%x  %x                                   ' ,& & '%b   epoch         %%e  %e                                   ' ,& & '%b   julian        %%j  %j                                   ' ,& & '%b   ordinal       %%O  %O                                   ' ,& & '%b   weekday       %%u  %u                                   ' ,& & '%b   MONTH         %%L  July                                 ' ,& & '%b   Month         %%l  Jul                                  ' ,& & '%b   DAY           %%d  7th                                  ' ,& & '%b   HOUR          %%H  10                                   ' ,& & '%b   GOOD          %%N  AM                                   ' ,& & '%b   Weekday       %%w  Thu                                  ' ,& & '%b   WEEKDAY       %%W  Thursday                             ' ,& & '%b   Timezone      %%Z  -240                                 ' ,& & '%b   TIMEZONE      %%z  -04:00                               ' ,& & '%bif none of these keywords are found then every letter that ' ,& & '%bis a macro is assumed to have an implied percent in front  ' ,& & '%bof it. For example:                                        ' ,& & '%b   YMDhms ==> %%Y%%M%%D%%h%%m%%s ==> %Y%M%D%h%m%s          ' ,& & '%b                                                           ' ] write ( * , '(a,a)' )( blanks ,( trim ( now ( usage ( i )))), i = 1 , size ( usage )) end subroutine fmtdate_usage","tags":"","loc":"proc/fmtdate_usage.html"},{"title":"guessdate – M_time","text":"public subroutine guessdate(datestring, dat, ier) NAME guessdate ( 3 f ) - [ M_time : READING_DATES ] reads in a date , in various formats ( LICENSE : PD ) SYNOPSIS subroutine guessdate(anot,dat)\n\n character(len=*),intent(in) :: anot\n integer,intent(out)         :: dat(8) DESCRIPTION Read in strings and except for looking for month names remove\n   non-numeric characters and try to convert a string assumed to represent\n   a date to a date-time array. Years should always be expressed as four-digit numbers, and except for\n   the special format yyyy-mm-dd the day should come after the year. Named\n   months are preferred. If ambiguous the order is assumed to be day -\n   month - year. Times are assumed to be of the form HH:MM:SS It is planned that this routine will be superseded. As an alternative,\n   a C routine exists in the standard C libraries that allows for\n   expansive features when reading dates that can be called via the\n   ISO_C_BINDING interface. OPTIONS anot  A string assumed to represent a date including a year, month and day.\n\ndat   Integer array holding a \"DAT\" array, similar in structure\n      to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n             dat=[ year,month,day,timezone,hour,&\n              & minutes,seconds,milliseconds] EXAMPLE Sample program : program demo_guessdate use M_time , only : guessdate , fmtdate implicit none character ( len = 20 ) , allocatable :: datestrings ( : ) character ( len = : ) , allocatable :: answer integer :: dat ( 8 ) integer :: i datestrings = [ & & ' January 9th, 2001 ' , & & ' Tue Jul 19 2016 ' , & & ' 21/12/2016 ' , & & ' 4th of Jul 2004 ' ] do i = 1 , size ( datestrings ) write ( * , ' (a) ' ) repeat ( ' - ' , 80 ) write ( * , * ) ' TRYING ' , datestrings ( i ) call guessdate ( datestrings ( i ) , dat ) write ( * , * ) ' DAT ARRAY ' , dat answer = fmtdate ( dat ) write ( * , * ) ' FOR ' // datestrings ( i ) // ' GOT ' // trim ( answer ) enddo end program demo_guessdate results : --------------------------------------------------------------------- TRYING January 9 th , 2001 DAT ARRAY 2001 1 9 - 240 0 0 0 0 FOR January 9 th , 2001 GOT Tuesday , January 9 th , 2001 12 : 00 : 00 AM --------------------------------------------------------------------- TRYING Tue Jul 19 2016 DAT ARRAY 2016 7 19 - 240 0 0 0 0 FOR Tue Jul 19 2016 GOT Tuesday , July 19 th , 2016 12 : 00 : 00 AM --------------------------------------------------------------------- TRYING 21 / 12 / 2016 DAT ARRAY 2016 12 21 - 240 0 0 0 0 FOR 21 / 12 / 2016 GOT Wednesday , December 21 st , 2016 12 : 00 : 00 AM --------------------------------------------------------------------- TRYING 4 th of Jul 2004 DAT ARRAY 2004 7 4 - 240 0 0 0 0 FOR 4 th of Jul 2004 GOT Sunday , July 4 th , 2004 12 : 00 : 00 AM LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datestring integer, intent(out) :: dat (8) integer, optional :: ier Contents Source Code guessdate Source Code subroutine guessdate ( datestring , dat , ier ) ! ident_16=\"@(#)M_time::guessdate(3f): Guess format of a date string to create a DAT date-time array\" ! partially based on a concept from JRH 1991-03-19 ! JSU, 20160729 ! ! makes an odd number of assumptions trying to guess what date format is being used. If you know the format of your date ! values READ(3f) and parse them directly instead of using this procedure, even though it does a good job with common USA formats. ! !x! REDO more rigorously with regular expressions and recognize standard formats directly ! NOTE : Main constraint is that day is input BEFORE year unless use YYYY-MM-DD and a : implies HH:MM:SS, no timezone names !        Not rigorous. Gets most common formats but can easily make errors in all but simple unambiguous common date formats character ( len =* ), intent ( in ) :: datestring ! Date in string format character ( len = :), allocatable :: datestring_local ! Date in string format character ( len = :), allocatable :: temp integer , intent ( out ) :: dat ( 8 ) integer , optional :: ier integer :: ier_local integer :: iye , mon , idy ! Year, Month, Day integer :: ihr , imi , ise ! Hour, Minute, Second integer :: itz , imill ! Timezone, Milliseconds character ( len = len ( datestring ) * 2 ) :: buff integer :: i , idum , ind logical :: alpha integer :: ios integer :: itries character ( len = 3 ), parameter :: amon ( 12 ) = [ 'JAN' , 'FEB' , 'MAR' , 'APR' , 'MAY' , 'JUN' , 'JUL' , 'AUG' , 'SEP' , 'OCT' , 'NOV' , 'DEC' ] integer , parameter :: idmon ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] character ( len = :), allocatable :: scratch (:) integer , parameter :: isize = 40 real :: rvalues ( isize ) character ( len = 2 ) :: ampm integer :: iend , inums , ierr logical :: number logical :: verbose integer :: loops dat = getnow () ! get time zone of current process and set defaults iye = dat ( 1 ) mon = dat ( 2 ) idy = dat ( 3 ) itz = dat ( 4 ) ! default is to use current timezone ihr = 0 imi = 0 ise = 0 imill = 0 ier_local = 0 rvalues = 0.0 datestring_local = '' verbose = . false . !----------------------------------------------------------------------------------------------------------------------------------- temp = ' ' // trim ( upper ( datestring )) if ( len ( temp ). ge . 2 ) then if ( temp ( 2 : 2 ). eq . '?' ) then verbose = . true . temp = temp ( 3 :) endif endif if ( verbose ) write ( * , * ) '*guessdate* a ' , temp , '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- number = . false . ! when transition from letter to number add a space do i = 1 , len ( temp ) select case ( temp ( i : i )) case ( 'A' : 'Z' , '/' ) if ( number ) then datestring_local = datestring_local // ' ' endif number = . false . case default number = . true . end select datestring_local = datestring_local // temp ( i : i ) enddo !----------------------------------------------------------------------------------------------------------------------------------- if ( verbose ) write ( * , * ) '*guessdate* b ' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill datestring_local = datestring_local // '                 ' ! pad string so substitute will fit if old string shorter than new string !make sure spaces are around month names call substitute ( datestring_local , 'JANUARY' , ' JAN ' ) call substitute ( datestring_local , 'FEBRUARY' , ' FEB ' ) call substitute ( datestring_local , 'MARCH' , ' MAR ' ) call substitute ( datestring_local , 'APRIL' , ' APR ' ) call substitute ( datestring_local , 'MAY' , ' MAY ' ) call substitute ( datestring_local , 'JUNE' , ' JUN ' ) call substitute ( datestring_local , 'JULY' , ' JUL ' ) call substitute ( datestring_local , 'AUGUST' , ' AUG ' ) call substitute ( datestring_local , 'SEPTEMBER' , ' SEP ' ) call substitute ( datestring_local , 'OCTOBER' , ' OCT ' ) call substitute ( datestring_local , 'NOVEMBER' , ' NOV ' ) call substitute ( datestring_local , 'DECEMBER' , ' DEC ' ) call substitute ( datestring_local , 'SEPT' , ' SEP ' ) call substitute ( datestring_local , 'JAN' , ' JAN ' ) call substitute ( datestring_local , 'FEB' , ' FEB ' ) call substitute ( datestring_local , 'MAR' , ' MAR ' ) call substitute ( datestring_local , 'APR' , ' APR ' ) call substitute ( datestring_local , 'MAY' , ' MAY ' ) call substitute ( datestring_local , 'JUN' , ' JUN ' ) call substitute ( datestring_local , 'JUL' , ' JUL ' ) call substitute ( datestring_local , 'AUG' , ' AUG ' ) call substitute ( datestring_local , 'SEP' , ' SEP ' ) call substitute ( datestring_local , 'OCT' , ' OCT ' ) call substitute ( datestring_local , 'NOV' , ' NOV ' ) call substitute ( datestring_local , 'DEC' , ' DEC ' ) ! assume T[0=9] is from yyyyy-mm-ddThh:mm:ss.xx ISO-8601 format (or SEPTnn,OCTnn AUGUSTnn, where space was added or name changed) call substitute ( datestring_local , 'T0' , ' 0' ) call substitute ( datestring_local , 'T1' , ' 1' ) call substitute ( datestring_local , 'T2' , ' 2' ) call substitute ( datestring_local , 'T3' , ' 3' ) call substitute ( datestring_local , 'T4' , ' 4' ) call substitute ( datestring_local , 'T5' , ' 5' ) call substitute ( datestring_local , 'T6' , ' 6' ) call substitute ( datestring_local , 'T7' , ' 7' ) call substitute ( datestring_local , 'T8' , ' 8' ) call substitute ( datestring_local , 'T9' , ' 9' ) call substitute ( datestring_local , ': ' , ':' ) call substitute ( datestring_local , ' :' , ':' ) if ( verbose ) write ( * , * ) '*guessdate* A ' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- call substitute ( datestring_local , 'UTC' , ' ' ) !----------------------------------------------------------------------------------------------------------------------------------- call split ( datestring_local , scratch , ' ;,\"''' ) if ( verbose ) write ( * , * ) '*guessdate* B ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! a leading +/- is assumed to be a timezone if ( index ( \"+-\" , scratch ( i )( 1 : 1 )) . ne . 0 ) then if ( index ( scratch ( i ), ':' ). ne . 0 ) then ! assumed to be +-hh:mm call string_to_values ( scratch ( i ), isize , rvalues , inums , ':' , ierr ) if ( inums . ge . 2 ) then itz = 60 * nint ( rvalues ( 1 )) + nint ( rvalues ( 2 )) elseif ( inums . eq . 1 ) then itz = 60 * nint ( rvalues ( 1 )) endif else ! assumed to be +-mm itz = nint ( s2v ( scratch ( i ))) endif scratch ( i ) = ' ' endif enddo if ( verbose ) write ( * , * ) '*guessdate* C ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! AM and PM are assumed to only occur significantly (not end of day or month name, ...) if ( len_trim ( scratch ( i )). ge . 2 ) then iend = len_trim ( scratch ( i )) ampm = scratch ( i )( iend - 1 : iend ) select case ( ampm ) case ( 'AM' ) call substitute ( scratch ( i ), 'AM' , ':' ) case ( 'PM' ) ihr = ihr + 12 call substitute ( scratch ( i ), 'PM' , ':' ) end select endif enddo if ( verbose ) write ( * , * ) '*guessdate* E ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! look for HH:MM:SS if ( index ( scratch ( i ), ':' ). ne . 0 ) then buff = scratch ( i ) call substitute ( buff , '-' , ' -' ) call substitute ( buff , '+' , ' +' ) call string_to_values ( buff , isize , rvalues , inums , ':/' , ierr ) if ( inums . ge . 1 ) ihr = ihr + nint ( rvalues ( 1 )) if ( inums . ge . 2 ) imi = nint ( rvalues ( 2 )) if ( inums . ge . 3 ) ise = nint ( rvalues ( 3 )) if ( inums . ge . 4 ) itz = nint ( rvalues ( 4 )) scratch ( i ) = ' ' endif enddo if ( verbose ) write ( * , * ) '*guessdate* F ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! assume yyyy-mm-dd if found a dash if ( index ( scratch ( i ), \"-\" ). ne . 0 ) then call string_to_values ( scratch ( i ), isize , rvalues , inums , '-' , ierr ) select case ( inums ) case ( 3 ) iye = nint ( rvalues ( 1 )) mon = nint ( rvalues ( 2 )) idy = nint ( rvalues ( 3 )) scratch ( i ) = v2s ( nint ( rvalues ( 3 ))) // ' ' // v2s ( nint ( rvalues ( 2 ))) // ' ' // v2s ( nint ( rvalues ( 1 ))) case ( 2 ) iye = nint ( rvalues ( 1 )) mon = nint ( rvalues ( 2 )) scratch ( i ) = v2s ( nint ( rvalues ( 2 ))) // ' ' // v2s ( nint ( rvalues ( 1 ))) case default end select endif enddo if ( verbose ) write ( * , * ) '*guessdate* D ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- datestring_local = '' do i = 1 , size ( scratch ) datestring_local = datestring_local // ' ' // adjustl ( trim ( scratch ( i ))) enddo if ( verbose ) write ( * , * ) '*guessdate* G ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- if ( datestring_local . eq . ' ' ) then loops = 0 else loops = 1000 endif if ( verbose ) write ( * , * ) '*guessdate* Ga' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill , loops INFINITE : do itries = 1 , loops ! give up after 1000 passes buff = datestring_local ! copy to buffer alpha = . false . do i = 1 , 12 ind = index ( buff , amon ( i )) if ( ind . ne . 0 ) then ! Found a matching month mon = i buff ( ind : ind + 2 ) = '   ' ! Delete month alpha = . true . ! Alphabetic month exit endif enddo do i = 1 , len ( buff ) ! First remove all non-numeric characters idum = ichar ( buff ( i : i )) if ( idum . lt . 4 8. or . idum . gt . 57 ) then buff ( i : i ) = ' ' endif enddo if ( alpha ) then ! Alphabetic month read ( buff , * , iostat = ios ) idy , iye if ( ios . ne . 0 ) cycle INFINITE else read ( buff , * , iostat = ios ) idy , mon , iye if ( ios . ne . 0 ) cycle INFINITE endif !x!if(iye.le.99)then !x!   iye=iye+2000                                       ! Cope with two digit year (assume 21st century.) !x!endif if ( mon . lt . 1. or . mon . gt . 12 ) cycle INFINITE ! Check range of months if ( mon . eq . 2 ) then ! Special check for Feb. if (( iye / 4 ) * 4. eq . iye ) then ! Leap year if ( idy . lt . 1. or . idy . gt . 29 ) cycle INFINITE else ! Non-leap year if ( idy . lt . 1. or . idy . gt . 28 ) cycle INFINITE endif else if ( idy . lt . 1. or . idy . gt . idmon ( mon )) cycle INFINITE ! Error ..... re-input endif exit enddo INFINITE if ( verbose ) write ( * , * ) '*guessdate* H ' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill if ( itries . ge . 1000 ) then write ( * , * ) '*guessdate* ERROR: could not extract date for ' // trim ( datestring ) endif dat ( 1 ) = iye dat ( 2 ) = mon dat ( 3 ) = idy dat ( 4 ) = itz dat ( 5 ) = ihr dat ( 6 ) = imi dat ( 7 ) = ise dat ( 8 ) = imill if ( present ( ier )) ier = ier_local end subroutine guessdate","tags":"","loc":"proc/guessdate.html"},{"title":"julian_to_date – M_time","text":"public subroutine julian_to_date(julian, dat, ierr) NAME julian_to_date(3f) - [M_time:JULIAN] converts a JED(Julian Ephemeris\nDate) to a DAT date-time array.\n(LICENSE:PD) SYNOPSIS subroutine julian_to_date(julian,dat,ierr)\n\n real(kind=realtime),intent(in) :: julian\n integer,intent(out)            :: dat(8)\n integer,intent(out)            :: ierr DESCRIPTION Converts a Unix Epoch Time (UET) value to a DAT date-time array.\n   UET is the number of seconds since 00:00 on January 1st, 1970, UTC. OPTIONS julian  Julian Date (days)\n dat     Integer array holding a \"DAT\" array, similar in structure\n         to the array returned by the intrinsic DATE_AND_TIME(3f):\n\n          dat=[ year,month,day,timezone,hour,&\n           & minutes,seconds,milliseconds] RETURNS unixtime The \" Unix Epoch \" time , or the number of seconds since 00 : 00 : 00 on January 1 st , 1970 , UTC . ierr Error code . If 0 no error occurred . EXAMPLE Sample program : program demo_julian_to_date use M_time , only : julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0 d0 ) real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr ! set sample Julian Date juliandate = 2457589.129 _dp ! create DAT array for this date call julian_to_date ( juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call julian_to_date ( juliandate - 1.0 _dp , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call julian_to_date ( juliandate + 1.0 _dp , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_julian_to_date Results : Sample Date = Tuesday , July 19 th , 2016 11 : 05 : 45 AM UTC - 04 : 00 Day Before = Monday , July 18 th , 2016 11 : 05 : 45 AM UTC - 04 : 00 Day After = Wednesday , July 20 th , 2016 11 : 05 : 45 AM UTC - 04 : 00 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name real(kind=realtime), intent(in) :: julian integer, intent(out) :: dat (8) integer, intent(out) :: ierr Contents Source Code julian_to_date Source Code subroutine julian_to_date ( julian , dat , ierr ) ! ident_3=\"@(#)M_time::julian_to_date(3f): Converts Julian Date to DAT date-time array\" real ( kind = realtime ), intent ( in ) :: julian ! Julian Date (non-negative) integer , intent ( out ) :: dat ( 8 ) integer , intent ( out ) :: ierr ! 0 for successful execution, otherwise 1 integer :: tz real ( kind = realtime ) :: second integer :: year integer :: month integer :: day integer :: hour integer :: minute integer :: jalpha , ja , jb , jc , jd , je , ijul if ( julian . lt . 0.0_dp ) then ! Negative Julian Date not allowed ierr = 1 return else ierr = 0 endif tz = get_timezone () ijul = idint ( julian ) ! Integral Julian Date second = sngl (( julian - dble ( ijul )) * secday ) ! Seconds from beginning of Jul. Day second = second + ( tz * 60 ) if ( second . ge .( secday / 2.0_dp )) then ! In next calendar day ijul = ijul + 1 second = second - ( secday / 2.0_dp ) ! Adjust from noon to midnight else ! In same calendar day second = second + ( secday / 2.0_dp ) ! Adjust from noon to midnight endif if ( second . ge . secday ) then ! Final check to prevent time 24:00:00 ijul = ijul + 1 second = second - secday endif minute = int ( second / 6 0.0_dp ) ! Integral minutes from beginning of day second = second - dble ( minute * 60 ) ! Seconds from beginning of minute hour = minute / 60 ! Integral hours from beginning of day minute = minute - hour * 60 ! Integral minutes from beginning of hour !--------------------------------------------- jalpha = idint (( dble ( ijul - 1867216 ) - 0.25_dp ) / 3652 4.25_dp ) ! Correction for Gregorian Calendar ja = ijul + 1 + jalpha - idint ( 0.25_dp * dble ( jalpha )) !--------------------------------------------- jb = ja + 1524 jc = idint ( 668 0.0_dp + ( dble ( jb - 2439870 ) - 12 2.1_dp ) / 36 5.25_dp ) jd = 365 * jc + idint ( 0.25_dp * dble ( jc )) je = idint ( dble ( jb - jd ) / 3 0.6001_dp ) day = jb - jd - idint ( 3 0.6001_dp * dble ( je )) month = je - 1 if ( month . gt . 12 ) then month = month - 12 endif year = jc - 4715 if ( month . gt . 2 ) then year = year - 1 endif if ( year . le . 0 ) then year = year - 1 endif dat = [ year , month , day , tz , hour , minute , int ( second ), int (( second - int ( second )) * 100 0.0 )] ierr = 0 end subroutine julian_to_date","tags":"","loc":"proc/julian_to_date.html"},{"title":"ordinal_to_date – M_time","text":"public subroutine ordinal_to_date(yyyy, ddd, dat) NAME ordinal_to_date ( 3 f ) - [ M_time : ORDINAL_DAY ] when given a valid year and day of the year returns the DAT array for the date ( LICENSE : PD ) SYNOPSIS subroutine ordinal_to_date(yyyy, ddd, dat)\n\n   integer, intent(in)   :: yyyy\n   integer, intent(in)   :: ddd\n   integer, intent(out)  :: dat DESCRIPTION When given a valid year, YYYY, and day of the year, DDD, returns the\n   date as a DAT date array OPTIONS yyyy  known year\n   ddd   known ordinal day of the year RETURNS dat   DAT array describing the date EXAMPLE Sample program : program demo_ordinal_to_date use M_time , only : ordinal_to_date implicit none INTEGER :: yyyy , ddd , mm , dd , yy integer :: dat ( 8 ) integer :: ios INFINITE : do write ( * , ' (a) ' , advance = ' no ' ) & & ' Enter year YYYY and ordinal day of year DD ' read ( * , * , iostat = ios ) yyyy , ddd if ( ios . ne . 0 ) exit INFINITE ! recover month and day from year and day number . call ordinal_to_date ( yyyy , ddd , dat ) yy = dat ( 1 ) mm = dat ( 2 ) dd = dat ( 3 ) write ( * , ' (*(g0)) ' ) ' For Year ' , yyyy , ' and Ordinal day ' , ddd , & & ' Month is ' , mm , ' and Day of Month is ' , dd , & & ' and Year is ' , yy enddo INFINITE end program demo_ordinal_to_date Arguments Type Intent Optional Attributes Name integer :: yyyy integer :: ddd integer :: dat (8) Contents Source Code ordinal_to_date Source Code subroutine ordinal_to_date ( yyyy , ddd , dat ) !x!use M_time, only : d2j,j2d, realtime ! ident_8=\"@(#)M_time::ordinal_to_date(3f): given a valid year and day of the year returns the DAT array for the date\" integer :: yyyy integer :: ddd integer :: dat ( 8 ) integer :: temp_dat ( 8 ) !dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] ! find Julian day for first day of given year and add ordinal day -1 and convert back to a DAT temp_dat = [ yyyy , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] dat = j2d ( d2j ( temp_dat ) + real ( ddd - 1 , kind = realtime ) ) end subroutine ordinal_to_date","tags":"","loc":"proc/ordinal_to_date.html"},{"title":"system_sleep – M_time","text":"public subroutine system_sleep(seconds) Uses iso_c_binding NAME system_sleep(3f) - [M_time:C_INTERFACE] call C sleep(3c) or usleep(3c)\nprocedure\n(LICENSE:PD) SYNOPSIS subroutine system_sleep(wait_seconds)\n\n   integer,intent(in)  :: wait_seconds\n      or\n   real,intent(in)  :: wait_seconds DESCRIPTION The system_sleep(3f) routine uses the intrinsic ISO_C_BINDING\n   interface to call the C sleep(3c) procedure or usleep(3c)\n   routine. OPTIONS wait_seconds integer , real or doubleprecision number of seconds for process to sleep . EXAMPLE Sample program : program demo_system_sleep use M_time , only : system_sleep , now implicit none integer :: i ! write ( * , ' (a) ' ) \" Time before integer call is: \" , now () call system_sleep ( 4 ) write ( * , ' (a) ' ) \" Time after  integer call is: \" , now () ! write ( * , ' (a) ' ) \" Time before real call is: \" , now () call system_sleep ( 4 . 0 ) write ( * , ' (a) ' ) \" Time after  real call is: \" , now () ! write ( * , ' (a) ' ) \" Time before loop is: \" , now () do i = 1 , 1000 call system_sleep ( 4 . 0 / 1000 . 0 ) enddo write ( * , ' (a) ' ) \" Time after loop  is: \" , now () ! end program demo_system_sleep results Time before integer call is : Sunday , July 17 th , 2016 2 : 29 : 45 AM UTC - 0240 Time after integer call is : Sunday , July 17 th , 2016 2 : 29 : 49 AM UTC - 0240 Time before real call is : Sunday , July 17 th , 2016 2 : 29 : 49 AM UTC - 0240 Time after real call is : Sunday , July 17 th , 2016 2 : 29 : 53 AM UTC - 0240 Time before loop is : Sunday , July 17 th , 2016 2 : 29 : 53 AM UTC - 0240 Time after loop is : Sunday , July 17 th , 2016 2 : 30 : 09 AM UTC - 0240 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: seconds Contents Source Code system_sleep Source Code subroutine system_sleep ( seconds ) use , intrinsic :: iso_c_binding , only : c_int ! ident_30=\"@(#)M_time::system_sleep(3f): call sleep(3c) or usleep(3c)\" class ( * ), intent ( in ) :: seconds integer ( kind = c_int ) :: cint select type ( seconds ) type is ( integer ); cint = seconds ; call call_sleep ( cint ) type is ( real ); cint = nint ( seconds * 100000 0.0_dp ) ; call call_usleep ( cint ) type is ( real ( kind = realtime )); cint = nint ( seconds * 100000 0.0_dp ) ; call call_usleep ( cint ) end select end SUBROUTINE system_sleep","tags":"","loc":"proc/system_sleep.html"},{"title":"unix_to_date – M_time","text":"public subroutine unix_to_date(unixtime, dat, ierr) NAME unix_to_date(3f) - [M_time:UNIX_EPOCH] converts Unix Epoch Time to\nDAT date-time\narray\n(LICENSE:PD) SYNOPSIS subroutine unix_to_date(unixtime,dat,ierr)\n\n real(kind=realtime),intent(in) :: unixtime\n integer,intent(out)            :: dat(8)\n integer,intent(out)            :: ierr DESCRIPTION Converts a Unix Epoch Time (UET) to a DAT date-time array. OPTIONS unixtime The \"Unix Epoch\" time , or the number of seconds since 00 : 00 : 00 on January 1st , 1970 , UTC ; of type real ( kind = realtime ). RETURNS dat Integer array holding a \" DAT \" array , similar in structure to the array returned by the intrinsic DATE_AND_TIME ( 3 f ) : dat = [ year , month , day , timezone , hour , & & minutes , seconds , milliseconds ] ierr Error code . If 0 no error occurred . EXAMPLE Sample program : program demo_unix_to_date use M_time , only : unix_to_date , u2d , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0 d0 ) real ( kind = realtime ) :: unixtime ! seconds in a day real ( kind = realtime ), parameter :: DAY = 86400.0 _dp integer :: dat ( 8 ) integer :: ierr ! sample Unix Epoch time unixtime = 1468939038.4639933 _dp ! create DAT array for today call unix_to_date ( unixtime , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call unix_to_date ( unixtime - DAY , dat , ierr ) ! subtract day and print write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call unix_to_date ( unixtime + DAY , dat , ierr ) ! add day print write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_unix_to_date Results : Sample Date = Tuesday , July 19 th , 2016 10 : 37 : 18 AM Day Before = Monday , July 18 th , 2016 10 : 37 : 18 AM Day After = Wednesday , July 20 th , 2016 10 : 37 : 18 AM AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: unixtime integer, intent(out) :: dat (8) integer, intent(out) :: ierr Contents Source Code unix_to_date Source Code subroutine unix_to_date ( unixtime , dat , ierr ) ! ident_5=\"@(#)M_time::unix_to_date(3f): Converts Unix Time to DAT date-time array\" class ( * ), intent ( in ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: dat ( 8 ) ! date and time array integer , intent ( out ) :: ierr ! 0 for successful execution, otherwise 1 real ( kind = realtime ) :: julian ! Unix time converted to a Julian Date real ( kind = realtime ) :: local_unixtime real ( kind = realtime ), save :: Unix_Origin_as_Julian ! start of Unix Time as Julian Date logical , save :: first = . TRUE . integer , parameter :: ref ( 8 ) = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] !  Notice that the value UNIXTIME can be any of several types ( INTEGER,REAL,REAL(KIND=REALTIME)) select type ( unixtime ) type is ( integer ); local_unixtime = dble ( unixtime ) type is ( real ); local_unixtime = dble ( unixtime ) ! typically not precise enough for UET values. type is ( real ( kind = realtime )); local_unixtime = unixtime end select !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Initialize calculated constants on first call call date_to_julian ( ref , Unix_Origin_as_Julian , ierr ) ! Compute start of Unix Time as a Julian Date if ( ierr . ne . 0 ) return ! Error first = . FALSE . endif !----------------------------------------------------------------------------------------------------------------------------------- julian = ( local_unixtime / secday ) + Unix_Origin_as_Julian ! convert seconds from Unix Epoch to Julian Date call julian_to_date ( julian , dat , ierr ) ! calculate date-time array from Julian Date !dat(4)=get_timezone()                                          ! need to get time zone end subroutine unix_to_date","tags":"","loc":"proc/unix_to_date.html"},{"title":"w2d – M_time","text":"public subroutine w2d(iso_year, iso_week, iso_weekday, dat) NAME w2d(3f) - [M_time:WEEK_OF_YEAR] calculate DAT date-time array from iso-8601\nWeek-numbering year date yyyy-Www-d\n(LICENSE:PD) SYNOPSIS subroutine w2d(iso_year,iso_week,iso_weekday,dat)\n\n integer,intent(in)      :: iso_year, iso_week, iso_weekday\n integer,intent(out)     :: dat(8)     ! output date array DESCRIPTION Given an ISO-8601 week return a “DAT” array defining a date and time,\n   The ISO-8601 is supplied as three integer values defining the ISO\n   year, week of year and weekday. OPTIONS iso_year ISO - 8601 year number for the given date iso_week ISO - 8601 week number for the given date iso_weekday ISO - 8601 weekday number for the given date iso_name ISO - 8601 Week string for the data in the form \" yyyy-Www-d \" . RETURNS dat          \"DAT\" array (an integer array of the same format as\n             the array returned by the intrinsic DATE_AND_TIME(3f))\n             describing the date to be used, which is the basic\n             time description used by the other M_time(3fm) module\n             procedures. EXAMPLE Sample program: program demo_w2d use M_time , only : w2d , fmtdate implicit none write ( * ,'( a )') & & ' Given Monday 29 December 2008 is written \"2009-W01-1\" ' call printit ( 2009 , 1 , 1 ) write ( * ,'( a )') & & ' Given Sunday 3 January 2010 is written \"2009-W53-7\" ' call printit ( 2009 , 53 , 7 ) write ( * ,'( a )') & & ' Given the Gregorian date Sun 31 December 2006 & & is written 2006 - W52 - 7 ' call printit ( 2006 , 52 , 7 ) write ( * ,'( a )') & & ' Given 27 September 2008 is 2008 - W39 - 6 ' call printit ( 2008 , 39 , 6 ) contains subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO - 8601 Week: 2016 - W29 - 1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * ,'( a , i0 ) ')' GIVEN: ' write ( * ,'( a , i0 ) ')' ISO - 8601 year ', iso_year write ( * ,'( a , i0 ) ')' ISO - 8601 week ', iso_week write ( * ,'( a , i0 ) ')' ISO - 8601 weekday ', iso_weekday write ( * ,'( a , i0 ) ')' RESULT: ' write ( * ,'( a , * ( i0: , \",\" )) ')' DAT array ', dat write ( * ,'( a , / , 67 ( \"=\" )) ')' ' //fmtdate(dat,'long') end subroutine printit end program demo_w2d Results: Given Monday 29 December 2008 is written \"2009-W01-1\" GIVEN: ISO - 8601 year 2009 ISO - 8601 week 1 ISO - 8601 weekday 1 RESULT: DAT array 2008 , 12 , 29 , - 240 , 0 , 0 , 0 , 0 Monday , December 29 th , 2008 12 : 00 : 00 AM UTC - 04 : 00 ========================================================= Given Sunday 3 January 2010 is written \"2009-W53-7\" GIVEN: ISO - 8601 year 2009 ISO - 8601 week 53 ISO - 8601 weekday 7 RESULT: DAT array 2010 , 1 , 3 , - 240 , 0 , 0 , 0 , 0 Sunday , January 3 rd , 2010 12 : 00 : 00 AM UTC - 04 : 00 ========================================================= Given the Gregorian date Sun 31 December 2006 is written 2006 - W52 - 7 GIVEN: ISO - 8601 year 2006 ISO - 8601 week 52 ISO - 8601 weekday 7 RESULT: DAT array 2006 , 12 , 31 , - 240 , 0 , 0 , 0 , 0 Sunday , December 31 st , 2006 12 : 00 : 00 AM UTC - 04 : 00 ========================================================= Given 27 September 2008 is 2008 - W39 - 6 GIVEN: ISO - 8601 year 2008 ISO - 8601 week 39 ISO - 8601 weekday 6 RESULT: DAT array 2008 , 9 , 27 , - 240 , 0 , 0 , 0 , 0 Saturday , September 27 th , 2008 12 : 00 : 00 AM UTC - 04 : 00 ========================================================= DEFINITION The ISO-8601 date and time standard was issued by the International\n   Organization for Standardization (ISO). It is used (mainly) in\n   government and business for fiscal years, as well as in timekeeping.\n   The system specifies a week year atop the Gregorian calendar by\n   defining a notation for ordinal weeks of the year. An ISO week-numbering year (also called ISO year informally) has\n   52 or 53 full weeks. That is 364 or 371 days instead of the usual\n   365 or 366 days. The extra week is referred to here as a leap week,\n   although ISO-8601 does not use this term. Weeks start with Monday.\n   The first week of a year is the week that contains the first Thursday\n   of the year (and, hence, always contains 4 January). ISO week year\n   numbering therefore slightly deviates from the Gregorian for some\n   days close to January 1st. METHOD Calculating a date given the year , week number and weekday This method requires that one know the weekday of 4 January of the year in question . Add 3 to the number of this weekday , giving a correction to be used for dates within this year . Method : Multiply the week number by 7 , then add the weekday . From this sum subtract the correction for the year . The result is the ordinal date , which can be converted into a calendar date . If the ordinal date thus obtained is zero or negative , the date belongs to the previous calendar year ; if greater than the number of days in the year , to the following year . Example : year 2008 , week 39 , Saturday ( day 6 ) Correction for 2008 : 5 + 3 = 8 ( 39 x 7 ) + 6 = 279 279 - 8 = 271 Ordinal day 271 of a leap year is day 271 - 244 = 27 September Result : 27 September 2008 ISO_NAME Week date representations are in the format YYYYWww-D. o [ YYYY ] indicates the ISO week - numbering year which is slightly different from the traditional Gregorian calendar year . o [ Www ] is the week number prefixed by the letter W , from W01 through W53 . o [ D ] is the weekday number , from 1 through 7 , beginning with Monday and ending with Sunday . For example, the Gregorian date 31 December 2006 corresponds to the\n   Sunday of the 52nd week of 2006, and is written 2006-W52-7 (extended form)\n or\n 2006W527 (compact form). REFERENCE From Wikipedia, the free encyclopedia 2016-08-08 AUTHOR John S. Urban, 2015 LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: iso_year integer, intent(in) :: iso_week integer, intent(in) :: iso_weekday integer, intent(out) :: dat (8) Contents Source Code w2d Source Code subroutine w2d ( iso_year , iso_week , iso_weekday , dat ) ! ident_19=\"@(#)M_time::w2d(3f): convert iso-8601 Week-numbering year date yyyy-Www-d to DAT date-time array\" integer , intent ( in ) :: iso_year , iso_week , iso_weekday integer , intent ( out ) :: dat ( 8 ) ! output date array integer :: jan4weekday integer :: correction integer :: ordinal integer :: ierr integer :: temp_dat ( 8 ) temp_dat = [ iso_year , 1 , 4 , 0 , 12 , 0 , 0 , 0 ] call dow ( temp_dat , jan4weekday , ierr = ierr ) ! get day of week for January 4th where Sun=1 correction = jan4weekday + 3 ! calculate correction ordinal = iso_week * 7 + iso_weekday - correction ! calculate ordinal day dat = o2d ( ordinal , iso_year ) ! convert ordinal to DAT (routine works with negative values or days past year end) end subroutine w2d","tags":"","loc":"proc/w2d.html"},{"title":"date_time – M_time","text":"public interface date_time Contents Module Procedures construct_from_dat Module Procedures private function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (:) Return Value type( date_time )","tags":"","loc":"interface/date_time.html"},{"title":"adjustc – M_time","text":"public pure function adjustc(string, length) NAME adjustc(3f) - [M_strings:WHITESPACE] center text\n   (LICENSE:PD) SYNOPSIS pure function adjustc(string[,length]) character(len=*),intent(in)  :: string\ninteger,intent(in),optional  :: length\ncharacter(len=:),allocatable :: adjustc DESCRIPTION Centers input text in a string of the length specified. Returns a\n   string of length LENGTH if LENGTH is present. Otherwise returns a\n   string of the length of the input string. OPTIONS string  input string to trim and center\n length  line length to center text in, optional. RETURNS adjustc  centered output string EXAMPLES Sample Program : program demo_adjustc use M_strings , only : adjustc ! using length of the input string write ( * , ' (a) ' ) ' ================================ ' write ( * , ' (a) ' ) adjustc ( ' centered string ' ) write ( * , ' (a) ' ) adjustc ( ' centered string ' ) write ( * , ' (a) ' ) adjustc ( ' centered string ' ) ! using explicit output string length write ( * , ' (a) ' ) repeat ( ' = ' , 50 ) write ( * , ' (a) ' ) adjustc ( ' this is a centered string ' , 50 ) write ( * , ' (a) ' ) repeat ( ' = ' , 50 ) end program demo_adjustc Expected output :\n\n \\ ================================ centered string centered string centered string \\ ================================================== this is a centered string \\ ================================================== AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string PROCEDURE   adjustc(3f)\n DESCRIPTION center text using implicit or explicit length VERSION     2.0, 20160711 AUTHOR      John S. Urban integer, intent(in), optional :: length Return Value character(len=:),allocatable Contents Variables ileft inlen Source Code adjustc Variables Type Visibility Attributes Name Initial integer, public :: ileft integer, public :: inlen Source Code pure function adjustc ( string , length ) !character(len=*),parameter::ident_32=\"@(#)M_strings::adjustc(3f): center text\" !> !! PROCEDURE   adjustc(3f) !! DESCRIPTION center text using implicit or explicit length !!##VERSION     2.0, 20160711 !! AUTHOR      John S. Urban !=================================================================================================================================== !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string ! input string to trim and center integer , intent ( in ), optional :: length ! line length to center text in character ( len = :), allocatable :: adjustc ! output string integer :: inlen integer :: ileft ! left edge of string if it is centered !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( length )) then ! optional length inlen = length ! length will be requested length if ( inlen . le . 0 ) then ! bad input length inlen = len ( string ) ! could not use input value, fall back to length of input string endif else ! output length was not explicitly specified, use input string length inlen = len ( string ) endif allocate ( character ( len = inlen ) :: adjustc ) ! create output at requested length adjustc ( 1 : inlen ) = ' ' ! initialize output string to all blanks !----------------------------------------------------------------------------------------------------------------------------------- ileft = ( inlen - len_trim ( adjustl ( string ))) / 2 ! find starting point to start input string to center it if ( ileft . gt . 0 ) then ! if string will fit centered in output adjustc ( ileft + 1 : inlen ) = adjustl ( string ) ! center the input text in the output string else ! input string will not fit centered in output string adjustc ( 1 : inlen ) = adjustl ( string ) ! copy as much of input to output as can endif end function adjustc","tags":"","loc":"proc/adjustc.html"},{"title":"compact – M_time","text":"public function compact(str, char) result(outstr) NAME compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing)\n(LICENSE:PD) SYNOPSIS function compact(STR,CHAR) result ( OUTSTR ) character ( len = * ), intent ( in ) :: STR character ( len = * ), intent ( in ), optional :: CHAR character ( len = len ( str )) :: OUTSTR DESCRIPTION COMPACT(3f) converts multiple spaces, tabs and control characters\n   (called “whitespace”) to a single character or nothing. Leading\n   whitespace is removed. OPTIONS STR input string to reduce or remove whitespace from CHAR By default the character that replaces adjacent whitespace is a space . If the optional CHAR parameter is supplied it will be used to replace the whitespace . If a null character is supplied for CHAR whitespace is removed . RETURNS OUTSTR  string of same length as input string but with all contiguous whitespace\n        reduced to a single space and leading whitespace removed EXAMPLES Sample Program : program demo_compact use M_strings , only : compact implicit none ! produces ' This is a test ' write ( * , * ) compact ( ' This     is      a     test ' ) ! produces ' Thisisatest ' write ( * , * ) compact ( ' This     is      a     test ' , char = '' ) ! produces ' This:is:a:test ' write ( * , * ) compact ( ' This     is      a     test ' , char = ' : ' ) ! note CHAR is used to replace the whitespace , but if CHAR is ! in the original string it is just copied write ( * , * ) compact ( ' A  AA    A   AAAAA ' , char = ' A ' ) ! produces ( original A characters are left as - is ) ' AAAAAAAAAAAA ' ! not ' A ' end program demo_compact Expected output > This is a test > Thisisatest > This : is : a : test > AAAAAAAAAAAA AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: char Return Value character(len=len) Contents Variables ch char_p i last_was_space nospace position_in_output Source Code compact Variables Type Visibility Attributes Name Initial character(len=1), public :: ch character(len=1), public :: char_p integer, public :: i logical, public :: last_was_space logical, public :: nospace integer, public :: position_in_output Source Code function compact ( str , char ) result ( outstr ) !character(len=*),parameter::ident_38=\"@(#)M_strings::compact(3f): Converts white-space to single spaces\" character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ), optional :: char character ( len = len ( str )) :: outstr character ( len = 1 ) :: ch integer :: i integer :: position_in_output logical :: last_was_space character ( len = 1 ) :: char_p logical :: nospace if ( present ( char )) then char_p = char if ( len ( char ). eq . 0 ) then nospace = . true . else nospace = . false . endif else char_p = ' ' nospace = . false . endif outstr = ' ' last_was_space = . false . position_in_output = 0 IFSPACE : do i = 1 , len_trim ( str ) ch = str ( i : i ) select case ( ichar ( ch )) case ( 0 : 32 , 127 ) ! space or tab character or control character if ( position_in_output . eq . 0 ) then ! still at beginning so ignore leading whitespace cycle IFSPACE elseif (. not . last_was_space ) then ! if have not already put out a space output one if (. not . nospace ) then position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = char_p endif endif last_was_space = . true . case (: - 1 , 33 : 126 , 128 :) ! not a space, quote, or control character so copy it position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = ch last_was_space = . false . end select end do IFSPACE end function compact","tags":"","loc":"proc/compact.html"},{"title":"d2s – M_time","text":"public function d2s(dvalue, fmt) result(outstr) NAME v2s ( 3 f ) - [ M_strings : NUMERIC ] return numeric string from a numeric value ( LICENSE : PD ) SYNOPSIS function v2s(value) result ( outstr ) integer | real | doubleprecision | logical , intent ( in ) :: value character ( len =:), allocatable :: outstr character ( len = * ), optional , intent ( in ) :: fmt DESCRIPTION v2s(3f) returns a representation of a numeric value as a\n   string when given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the strings using internal WRITE()\n   statements. Trailing zeros are removed from non-zero values, and the\n   string is left-justified. OPTIONS VALUE   input value to be converted to a string\nFMT     format can be explicitly given, but is limited to\n        generating a string of eighty or less characters. RETURNS OUTSTR  returned string representing input value, EXAMPLE Sample Program : program demo_v2s use M_strings , only : v2s write ( * , * ) 'The value of 3.0/4.0 is [' // v2s ( 3.0 / 4.0 ) // ']' write ( * , * ) 'The value of 1234    is [' // v2s ( 1234 ) // ']' write ( * , * ) 'The value of 0d0     is [' // v2s ( 0 d0 ) // ']' write ( * , * ) 'The value of .false. is [' // v2s (. false .) // ']' write ( * , * ) 'The value of .true. is  [' // v2s (. true .) // ']' end program demo_v2s Expected output The value of 3.0 / 4.0 is [ 0.75 ] The value of 1234 is [ 1234 ] The value of 0 d0 is [ 0 ] The value of . false . is [ F ] The value of . true . is [ T ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable Contents Variables string Source Code d2s Variables Type Visibility Attributes Name Initial character(len=80), public :: string Source Code function d2s ( dvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_45=\"@(#)M_strings::d2s(3fp): private function returns string given doubleprecision value\" doubleprecision , intent ( in ) :: dvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( dvalue , string , fmt = fmt ) else call value_to_string ( dvalue , string ) endif outstr = trim ( string ) end function d2s","tags":"","loc":"proc/d2s.html"},{"title":"decodebase – M_time","text":"public function decodebase(string, basein, out_baseten) NAME decodebase(3f) - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number\n   (LICENSE:PD) SYNOPSIS logical function decodebase(string,basein,out10)\n\n character(len=*),intent(in)  :: string\n integer,intent(in)           :: basein\n integer,intent(out)          :: out10 DESCRIPTION Convert a numeric string representing a whole number in base BASEIN\n   to base 10. The function returns FALSE if BASEIN is not in the range\n   [2..36] or if string STRING contains invalid characters in base BASEIN\n   or if result OUT10 is too big The letters A,B,…,Z represent 10,11,…,36 in the base > 10. OPTIONS string   input string. It represents a whole number in\n         the base specified by BASEIN unless BASEIN is set\n         to zero. When BASEIN is zero STRING is assumed to\n         be of the form BASE#VALUE where BASE represents\n         the function normally provided by BASEIN.\nbasein   base of input string; either 0 or from 2 to 36.\nout10    output value in base 10 EXAMPLE Sample program : program demo_decodebase use M_strings , only : codebase , decodebase implicit none integer :: ba , bd character ( len = 40 ) :: x , y integer :: r print *, ' BASE CONVERSION' write (*, '(\"Start   Base (2 to 36): \")' , advance = 'no' ); read *, bd write (*, '(\"Arrival Base (2 to 36): \")' , advance = 'no' ); read *, ba INFINITE : do print *, '' write (*, '(\"Enter number in start base: \")' , advance = 'no' ); read *, x if ( x . eq . '0' ) exit INFINITE if ( decodebase ( x , bd , r )) then if ( codebase ( r , ba , y )) then write (*, '(\"In base \",I2,\": \",A20)' ) ba , y else print *, 'Error in coding number.' endif else print *, 'Error in decoding number.' endif enddo INFINITE end program demo_decodebase AUTHOR John S. Urban\n\n   Ref.: \"Math matiques en Turbo-Pascal by\n          M. Ducamp and A. Reverchon (2),\n          Eyrolles, Paris, 1988\".\n\nbased on a F90 Version By J-P Moreau (www.jpmoreau.fr) LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: basein integer, intent(out) :: out_baseten Return Value logical Contents Variables XMAXREAL basein_local ch i ierr ipound j k long mult out_sign string_local y Source Code decodebase Variables Type Visibility Attributes Name Initial real, public, parameter :: XMAXREAL = real(huge(1)) integer, public :: basein_local character(len=1), public :: ch integer, public :: i integer, public :: ierr integer, public :: ipound integer, public :: j integer, public :: k integer, public :: long real, public :: mult integer, public :: out_sign character(len=len), public :: string_local real, public :: y Source Code logical function decodebase ( string , basein , out_baseten ) implicit none !character(len=*),parameter::ident_72=\"@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number\" character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: basein integer , intent ( out ) :: out_baseten character ( len = len ( string )) :: string_local integer :: long , i , j , k real :: y real :: mult character ( len = 1 ) :: ch real , parameter :: XMAXREAL = real ( huge ( 1 )) integer :: out_sign integer :: basein_local integer :: ipound integer :: ierr string_local = upper ( trim ( adjustl ( string ))) decodebase = . false . ipound = index ( string_local , '#' ) ! determine if in form [-]base#whole if ( basein . eq . 0. and . ipound . gt . 1 ) then ! split string into two values call string_to_value ( string_local (: ipound - 1 ), basein_local , ierr ) ! get the decimal value of the base string_local = string_local ( ipound + 1 :) ! now that base is known make string just the value if ( basein_local . ge . 0 ) then ! allow for a negative sign prefix out_sign = 1 else out_sign =- 1 endif basein_local = abs ( basein_local ) else ! assume string is a simple positive value basein_local = abs ( basein ) out_sign = 1 endif out_baseten = 0 y = 0.0 ALL : if ( basein_local < 2. or . basein_local > 36 ) then print * , '(*decodebase* ERROR: Base must be between 2 and 36. base=' , basein_local else ALL out_baseten = 0 ; y = 0.0 ; mult = 1.0 long = LEN_TRIM ( string_local ) do i = 1 , long k = long + 1 - i ch = string_local ( k : k ) if ( ch . eq . '-' . and . k . eq . 1 ) then out_sign =- 1 cycle endif if ( ch < '0' . or . ch > 'Z' . or .( ch > '9' . and . ch < 'A' )) then write ( * , * ) '*decodebase* ERROR: invalid character ' , ch exit ALL endif if ( ch <= '9' ) then j = IACHAR ( ch ) - IACHAR ( '0' ) else j = IACHAR ( ch ) - IACHAR ( 'A' ) + 10 endif if ( j >= basein_local ) then exit ALL endif y = y + mult * j if ( mult > XMAXREAL / basein_local ) then exit ALL endif mult = mult * basein_local enddo decodebase = . true . out_baseten = nint ( out_sign * y ) * sign ( 1 , basein ) endif ALL end function decodebase","tags":"","loc":"proc/decodebase.html"},{"title":"i2s – M_time","text":"public function i2s(ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable Contents Variables string Source Code i2s Variables Type Visibility Attributes Name Initial character(len=80), public :: string Source Code function i2s ( ivalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_47=\"@(#)M_strings::i2s(3fp): private function returns string given integer value\" integer , intent ( in ) :: ivalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( ivalue , string , fmt = fmt ) else call value_to_string ( ivalue , string ) endif outstr = trim ( string ) end function i2s","tags":"","loc":"proc/i2s.html"},{"title":"l2s – M_time","text":"public function l2s(lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable Contents Variables string Source Code l2s Variables Type Visibility Attributes Name Initial character(len=80), public :: string Source Code function l2s ( lvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_48=\"@(#)M_strings::l2s(3fp): private function returns string given logical value\" logical , intent ( in ) :: lvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( lvalue , string , fmt = fmt ) else call value_to_string ( lvalue , string ) endif outstr = trim ( string ) end function l2s","tags":"","loc":"proc/l2s.html"},{"title":"lower – M_time","text":"public pure elemental function lower(str, begin, end) result(string) NAME lower(3f) - [M_strings:CASE] changes a string to lowercase over specified range\n(LICENSE:PD) SYNOPSIS elemental pure function lower ( str , begin , end ) result ( string ) character ( * ) , intent ( in ) :: str integer , optional :: begin , end character ( len ( str )) :: string ! output string DESCRIPTION lower(string) returns a copy of the input string with all characters\n   converted to miniscule over the specified range, assuming ASCII\n   character sets are being used. If no range is specified the entire\n   string is converted to miniscule. OPTIONS str string to convert to miniscule begin optional starting position in \" str \" to begin converting to miniscule end optional ending position in \" str \" to stop converting to miniscule RESULTS lower  copy of the input string with all characters converted to miniscule\n       over optionally specified range. TRIVIA The terms \"uppercase\" and \"lowercase\" date back to the early days of\nthe mechanical printing press. Individual metal alloy casts of each\nneeded letter, or punctuation symbol, were meticulously added to a\npress block, by hand, before rolling out copies of a page. These\nmetal casts were stored and organized in wooden cases. The more\noften needed miniscule letters were placed closer to hand, in the\nlower cases of the work bench. The less often needed, capitalized,\nmajuscule letters, ended up in the harder to reach upper cases. EXAMPLE Sample program : program demo_lower use M_time , only : lower implicit none character ( len = : ) , allocatable :: s s = ' ABCDEFG abcdefg ' write ( * , * ) ' mixed-case input string is .... ' , s write ( * , * ) ' lower-case output string is ... ' , lower ( s ) end program demo_lower Expected output mixed - case input string is .... ABCDEFG abcdefg lower - case output string is ... abcdefg abcdefg AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character Contents Variables i ibegin iend Source Code lower Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ibegin integer, public :: iend Source Code elemental pure function lower ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_22=\"@(#)M_strings::lower(3f): Changes a string to lowercase over specified range\" character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = char ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower","tags":"","loc":"proc/lower.html"},{"title":"r2s – M_time","text":"public function r2s(rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable Contents Variables string Source Code r2s Variables Type Visibility Attributes Name Initial character(len=80), public :: string Source Code function r2s ( rvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_46=\"@(#)M_strings::r2s(3fp): private function returns string given real value\" real , intent ( in ) :: rvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( rvalue , string , fmt = fmt ) else call value_to_string ( rvalue , string ) endif outstr = trim ( string ) end function r2s","tags":"","loc":"proc/r2s.html"},{"title":"s2v – M_time","text":"public function s2v(chars, ierr, onerr) NAME s2v(3f) - [M_strings:NUMERIC] function returns doubleprecision numeric value from a string\n  (LICENSE:PD) SYNOPSIS function s2v ( string[,ierr][,onerr] ) character ( len = * ) :: string doubleprecision :: s2v integer , intent ( out ), optional :: ierr class ( * ), intent ( in ), optional :: onerr DESCRIPTION This function converts a string to a DOUBLEPRECISION numeric value. The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended to take\n   CHARACTER variables. The KIND= keyword is not supported on the extensions. OPTIONS string holds string assumed to represent a numeric value ierr If an error occurs the program is stopped if the optional parameter IERR is not present . If IERR returns a non - zero value an error occurred . onerr The value to return on error . A value of zero ( NaN ) is returned on error by default . RETURNS s2v EXAMPLE Sample Program : program demo_s2v use M_strings , only : s2v , int , real , dble implicit none character ( len = 8 ) :: s = ' 10.345 ' integer :: i character ( len = 14 ) , allocatable :: strings ( : ) doubleprecision :: dv integer :: errnum ! different strings representing INTEGER , REAL , and DOUBLEPRECISION strings = [ & & ' 10.345 ' , & & ' +10 ' , & & ' -3 ' , & & ' -4.94e-2 ' , & & ' 0.1 ' , & & ' 12345.678910d0 ' , & & ' ' , & ! Note : will return zero without an error message & ' 1 2 1 2 1 . 0 ' , & ! Note : spaces will be ignored & ' WHAT? ' ] ! Note : error messages will appear , zero returned ! a numeric value is returned , so it can be used in numeric expression write ( * , * ) ' 1/2 value of string is ' , s2v ( s ) / 2 . 0 d0 write ( * , * ) write ( * , * ) ' STRING            VALUE                    ERROR_NUMBER ' do i = 1 , size ( strings ) ! Note : not a good idea to use s2v ( 3 f ) in a WRITE ( 3 f ) statement , ! as it does I / O when errors occur , so called on a separate line dv = s2v ( strings ( i ) , errnum ) write ( * , * ) strings ( i ) // ' = ' , dv , errnum enddo write ( * , * ) \" Extended intrinsics \" write ( * , * ) ' given inputs: ' , s , strings ( : 8 ) write ( * , * ) ' INT(3f): ' , int ( s ) , int ( strings ( : 8 )) write ( * , * ) ' REAL(3f): ' , real ( s ) , real ( strings ( : 8 )) write ( * , * ) ' DBLE(3f): ' , dble ( s ) , dble ( strings ( : 8 )) write ( * , * ) \" That's all folks! \" end program demo_s2v Expected output > 1 / 2 value of string is 5 . 1725000000000003 > > STRING VALUE ERROR_NUMBER > 10 . 345 = 10 . 345000000000001 0 >+ 10 = 10 . 000000000000000 0 > - 3 = - 3 . 0000000000000000 0 > - 4 . 94 e - 2 = - 4 . 9399999999999999 E - 002 0 > 0 . 1 = 0 . 10000000000000001 0 > 12345 . 678910 d0 = 12345 . 678910000001 0 > = 0 . 0000000000000000 0 > 1 2 1 2 1 . 0 = 12121 . 000000000000 0 >* a2d * - cannot produce number from string [ WHAT ?] >* a2d * - [ Bad value during floating point read ] > WHAT ? = 0 . 0000000000000000 5010 > Extended intrinsics > given inputs : 10 . 345 10 . 345 + 10 - 3 - 4 . 94 e - 2 0 . 1 12345 . 678910 d0 1 2 1 2 1 . 0 > INT ( 3 f ) : 10 10 10 - 3 0 0 12345 0 12121 > REAL ( 3 f ) : 10 . 3450003 10 . 3450003 10 . 0000000 - 3 . 00000000 - 4 . 94000018 E - 02 > 0 . 100000001 12345 . 6787 0 . 00000000 12121 . 0000 > DBLE ( 3 f ) : 10 . 345000000000001 10 . 345000000000001 10 . 000000000000000 > - 3 . 0000000000000000 - 4 . 9399999999999999 E - 002 0 . 10000000000000001 > 12345 . 678910000001 0 . 0000000000000000 12121 . 000000000000 > That ' s all folks! AUTHOR John S. Urban LICENSE Public Domain PROCEDURE: DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs VERSION:     2.0, 20160704 AUTHOR:      John S. Urban Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, optional :: ierr class(*), intent(in), optional :: onerr Return Value doubleprecision Contents Variables ierr_local valu Source Code s2v Variables Type Visibility Attributes Name Initial integer, public :: ierr_local doubleprecision, public :: valu Source Code doubleprecision function s2v ( chars , ierr , onerr ) !  1989 John S. Urban !character(len=*),parameter::ident_43=\"@(#)M_strings::s2v(3f): returns doubleprecision number from string\" character ( len =* ), intent ( in ) :: chars integer , optional :: ierr doubleprecision :: valu integer :: ierr_local class ( * ), intent ( in ), optional :: onerr ierr_local = 0 if ( present ( onerr )) then call a2d ( chars , valu , ierr_local , onerr ) else call a2d ( chars , valu , ierr_local ) endif if ( present ( ierr )) then ! if error is not returned stop program on error ierr = ierr_local s2v = valu elseif ( ierr_local . ne . 0 ) then write ( * , * ) '*s2v* stopped while reading ' // trim ( chars ) stop 1 else s2v = valu endif end function s2v","tags":"","loc":"proc/s2v.html"},{"title":"transliterate – M_time","text":"public pure function transliterate(instr, old_set, new_set) result(outstr) NAME transliterate(3f) - [M_strings:EDITING] replace characters from old set with new set\n(LICENSE:PD) SYNOPSIS pure function transliterate(instr,old_set,new_set) result(outstr)\n\n character(len=*),intent(in)  :: instr\n character(len=*),intent(in)  :: old_set\n character(len=*),intent(in)  :: new_set\n character(len=len(instr))    :: outstr DESCRIPTION Translate, squeeze, and/or delete characters from the input string. OPTIONS instr input string to change old_set list of letters to change in INSTR if found Each character in the input string that matches a character in the old set is replaced . new_set list of letters to replace letters in OLD_SET with . If the new_set is the empty set the matched characters are deleted . If the new_set is shorter than the old set the last character in the new set is used to replace the remaining characters in the new set . RETURNS outstr   instr with substitutions applied EXAMPLES Sample Program : program demo_transliterate use M_strings , only : transliterate implicit none character ( len = 80 ) :: STRING STRING = ' aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ ' write ( * , ' (a) ' ) STRING ! convert a string to uppercase : write ( * , * ) TRANSLITERATE ( STRING , ' abcdefghijklmnopqrstuvwxyz ' , ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' ) ! change all miniscule letters to a colon ( \" : \" ) : write ( * , * ) TRANSLITERATE ( STRING , ' abcdefghijklmnopqrstuvwxyz ' , ' : ' ) ! delete all miniscule letters write ( * , * ) TRANSLITERATE ( STRING , ' abcdefghijklmnopqrstuvwxyz ' , '' ) end program demo_transliterate Expected output > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ > : A : B : C : D : E : F : G : H : I : J : K : L : M : N : O : P : Q : R : S : T : U : V : W : X : Y : Z > ABCDEFGHIJKLMNOPQRSTUVWXYZ AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value character(len=LEN) Contents Variables i10 ii jj Source Code transliterate Variables Type Visibility Attributes Name Initial integer, public :: i10 integer, public :: ii integer, public :: jj Source Code PURE FUNCTION transliterate ( instr , old_set , new_set ) RESULT ( outstr ) !character(len=*),parameter::ident_16=\"@(#)M_strings::transliterate(3f): replace characters from old set with new set\" !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input string to change CHARACTER ( LEN =* ), intent ( in ) :: old_set CHARACTER ( LEN =* ), intent ( in ) :: new_set !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN = LEN ( instr )) :: outstr ! output string to generate !----------------------------------------------------------------------------------------------------------------------------------- INTEGER :: i10 ! loop counter for stepping thru string INTEGER :: ii , jj !----------------------------------------------------------------------------------------------------------------------------------- jj = LEN ( new_set ) IF ( jj . NE . 0 ) THEN outstr = instr ! initially assume output string equals input string stepthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii . NE . 0 ) THEN if ( ii . le . jj ) then ! use corresponding character in new_set outstr ( i10 : i10 ) = new_set ( ii : ii ) else outstr ( i10 : i10 ) = new_set ( jj : jj ) ! new_set not as long as old_set; use last character in new_set endif ENDIF ENDDO stepthru else ! new_set is null string so delete characters in old_set outstr = ' ' hopthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii . EQ . 0 ) THEN ! only keep characters not in old_set jj = jj + 1 outstr ( jj : jj ) = instr ( i10 : i10 ) ENDIF ENDDO hopthru endif END FUNCTION transliterate","tags":"","loc":"proc/transliterate.html"},{"title":"upper – M_time","text":"public pure elemental function upper(str, begin, end) result(string) NAME upper(3f) - [M_strings:CASE] changes a string to uppercase\n (LICENSE:PD) SYNOPSIS elemental pure function upper ( str , begin , end ) result ( string ) character ( * ) , intent ( in ) :: str integer , optional , intent ( in ) :: begin , end character ( len ( str )) :: string ! output string DESCRIPTION upper(string) returns a copy of the input string with all characters\n   converted in the optionally specified range to uppercase, assuming\n   ASCII character sets are being used. If no range is specified the\n   entire string is converted to uppercase. OPTIONS str string to convert to uppercase begin optional starting position in \" str \" to begin converting to uppercase end optional ending position in \" str \" to stop converting to uppercase RESULTS upper  copy of the input string with all characters converted to uppercase\n        over optionally specified range. TRIVIA The terms “uppercase” and “lowercase” date back to the early days of\n   the mechanical printing press. Individual metal alloy casts of each\n   needed letter, or punctuation symbol, were meticulously added to a\n   press block, by hand, before rolling out copies of a page. These\n   metal casts were stored and organized in wooden cases. The more\n   often needed miniscule letters were placed closer to hand, in the\n   lower cases of the work bench. The less often needed, capitalized,\n   majuscule letters, ended up in the harder to reach upper cases. EXAMPLE Sample program : program demo_upper use M_time , only : upper implicit none character ( len = : ) , allocatable :: s s = ' ABCDEFG abcdefg ' write ( * , * ) ' mixed-case input string is .... ' , s write ( * , * ) ' upper-case output string is ... ' , upper ( s ) write ( * , * ) ' make first character uppercase  ... ' , upper ( ' this is a sentence. ' , 1 , 1 ) write ( * , ' (1x,a,*(a:,\"+\")) ' ) ' upper(3f) is elemental ==> ' , upper ( [ \" abc \" , \" def \" , \" ghi \" ] ) end program demo_upper Expected output mixed - case input string is .... ABCDEFG abcdefg upper - case output string is ... ABCDEFG ABCDEFG make first character uppercase ... This is a sentence . upper ( 3 f ) is elemental ==> ABC + DEF + GHI AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character Contents Variables i ibegin iend Source Code upper Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ibegin integer, public :: iend Source Code elemental pure function upper ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_21=\"@(#)M_strings::upper(3f): Changes a string to uppercase\" character ( * ), intent ( In ) :: str ! inpout string to convert to all uppercase integer , intent ( in ), optional :: begin , end character ( len ( str )) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: ibegin , iend string = str ! initialize output string to input string ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'a' : 'z' ) ! located miniscule letter string ( i : i ) = char ( iachar ( str ( i : i )) - 32 ) ! change miniscule letter to uppercase end select end do end function upper","tags":"","loc":"proc/upper.html"},{"title":"a2d – M_time","text":"public subroutine a2d(chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns doubleprecision value from string doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr Contents Variables basevalue fmt frmt intg ivalu local_chars msg nan_string pnd Source Code a2d Variables Type Visibility Attributes Name Initial integer, public :: basevalue character(len=*), public, parameter :: fmt = \"('(bn,g',i5,'.0)')\" character(len=15), public :: frmt integer, public :: intg integer, public :: ivalu character(len=:), public, allocatable :: local_chars character(len=256), public :: msg character(len=3), public, save :: nan_string = 'NaN' integer, public :: pnd Source Code subroutine a2d ( chars , valu , ierr , onerr ) !> !! subroutine returns doubleprecision value from string !character(len=*),parameter::ident_42=\"@(#)M_strings::a2d(3fp): subroutine returns double value from string\" !     1989,2016 John S. Urban. ! !  o  works with any g-format input, including integer, real, and exponential. !  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0. !  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data. !     IERR will still be non-zero in this case. !---------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: chars ! input string character ( len = :), allocatable :: local_chars doubleprecision , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) class ( * ), optional , intent ( in ) :: onerr !---------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), parameter :: fmt = \"('(bn,g',i5,'.0)')\" ! format used to build frmt character ( len = 15 ) :: frmt ! holds format built to read input string character ( len = 256 ) :: msg ! hold message from I/O errors integer :: intg integer :: pnd integer :: basevalue , ivalu character ( len = 3 ), save :: nan_string = 'NaN' !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error flag to zero local_chars = chars msg = '' if ( len ( local_chars ). eq . 0 ) local_chars = ' ' call substitute ( local_chars , ',' , '' ) ! remove any comma characters pnd = scan ( local_chars , '#:' ) if ( pnd . ne . 0 ) then write ( frmt , fmt ) pnd - 1 ! build format of form '(BN,Gn.0)' read ( local_chars (: pnd - 1 ), fmt = frmt , iostat = ierr , iomsg = msg ) basevalue ! try to read value from string if ( decodebase ( local_chars ( pnd + 1 :), basevalue , ivalu )) then valu = real ( ivalu , kind = kind ( 0.0d0 )) else valu = 0.0d0 ierr =- 1 endif else select case ( local_chars ( 1 : 1 )) case ( 'z' , 'Z' , 'h' , 'H' ) ! assume hexadecimal frmt = '(Z' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'b' , 'B' ) ! assume binary (base 2) frmt = '(B' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'o' , 'O' ) ! assume octal frmt = '(O' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case default write ( frmt , fmt ) len ( local_chars ) ! build format of form '(BN,Gn.0)' read ( local_chars , fmt = frmt , iostat = ierr , iomsg = msg ) valu ! try to read value from string end select endif if ( ierr . ne . 0 ) then ! if an error occurred ierr will be non-zero. if ( present ( onerr )) then select type ( onerr ) type is ( integer ) valu = onerr type is ( real ) valu = onerr type is ( doubleprecision ) valu = onerr end select else ! set return value to NaN read ( nan_string , '(g3.3)' ) valu endif if ( local_chars . ne . 'eod' ) then ! print warning message except for special value \"eod\" call stderr ( '*a2d* - cannot produce number from string [' // trim ( chars ) // ']' ) if ( msg . ne . '' ) then call stderr ( '*a2d* - [' // trim ( msg ) // ']' ) endif endif endif end subroutine a2d","tags":"","loc":"proc/a2d.html"},{"title":"a2i – M_time","text":"public subroutine a2i(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns integer value from string integer, intent(out) :: valu integer, intent(out) :: ierr Contents Variables valu8 Source Code a2i Variables Type Visibility Attributes Name Initial doubleprecision, public :: valu8 Source Code subroutine a2i ( chars , valu , ierr ) !> !! subroutine returns integer value from string !character(len=*),parameter::ident_41=\"@(#)M_strings::a2i(3fp): subroutine returns integer value from string\" character ( len =* ), intent ( in ) :: chars ! input string integer , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( valu8 . le . huge ( valu )) then if ( valu8 . le . huge ( valu )) then valu = int ( valu8 ) else !x!call stderr('sc','*a2i*','- value too large',valu8,'>',huge(valu)) call stderr ( '*a2i* - value too large' ) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2i","tags":"","loc":"proc/a2i.html"},{"title":"a2r – M_time","text":"public subroutine a2r(chars, valu, ierr) NAME string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric value from string\n  (LICENSE:PD) SYNOPSIS subroutine string_to_value(chars,valu,ierr)\n\n character(len=*),intent(in)              :: chars   ! input string\n integer|real|doubleprecision,intent(out) :: valu\n integer,intent(out)                      :: ierr DESCRIPTION returns a numeric value from a numeric character string. works with any g-format input, including integer, real, and\n   exponential. If the input string begins with “B”, “Z”, or “O”\n   and otherwise represents a positive whole number it is assumed to\n   be a binary, hexadecimal, or octal value. If the string contains\n   commas they are removed. If the string is of the form NN:MMM… or\n   NN#MMM then NN is assumed to be the base of the whole number. if an error occurs in the READ, IOSTAT is returned in IERR and\n   value is set to zero. if no error occurs, IERR=0. OPTIONS CHARS  input string to read numeric value from RETURNS VALU   numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION.\n   IERR   error flag (0 == no error) EXAMPLE Sample Program : program demo_string_to_value use M_strings , only : string_to_value character ( len = 80 ) :: string string = ' -40.5e-2 ' call string_to_value ( string , value , ierr ) write ( * , * ) ' value of string [ ' // trim ( string ) // ' ] is ' , value end program demo_string_to_value AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns real value from string real, intent(out) :: valu integer, intent(out) :: ierr Contents Variables valu8 Source Code a2r Variables Type Visibility Attributes Name Initial doubleprecision, public :: valu8 Source Code subroutine a2r ( chars , valu , ierr ) !> !! subroutine returns real value from string !character(len=*),parameter::ident_40=\"@(#)M_strings::a2r(3fp): subroutine returns real value from string\" character ( len =* ), intent ( in ) :: chars ! input string real , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( ierr . eq . 0 ) then if ( valu8 . le . huge ( valu )) then valu = real ( valu8 ) else !x!call stderr('*a2r* - value too large',valu8,'>',huge(valu)) call stderr ( '*a2r* - value too large' ) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2r","tags":"","loc":"proc/a2r.html"},{"title":"split – M_time","text":"public subroutine split(input_line, array, delimiters, order, nulls) NAME split(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters\n(LICENSE:PD) SYNOPSIS subroutine split(input_line,array,delimiters,order,nulls)\n\n character(len=*),intent(in)              :: input_line\n character(len=:),allocatable,intent(out) :: array(:)\n character(len=*),optional,intent(in)     :: delimiters\n character(len=*),optional,intent(in)     :: order\n character(len=*),optional,intent(in)     :: nulls DESCRIPTION SPLIT(3f) parses a string using specified delimiter characters and\n   store tokens into an allocatable array OPTIONS INPUT_LINE Input string to tokenize ARRAY Output array of tokens DELIMITERS List of delimiter characters . The default delimiters are the \"whitespace\" characters ( space , tab , new line , vertical tab , formfeed , carriage return , and null ). You may specify an alternate set of delimiter characters . Multi - character delimiters are not supported ( Each character in the DELIMITERS list is considered to be a delimiter ). Quoting of delimiter characters is not supported . ORDER SEQUENTIAL | REVERSE | RIGHT Order of output array . By default ARRAY contains the tokens having parsed the INPUT_LINE from left to right . If ORDER = 'RIGHT' or ORDER = 'REVERSE' the parsing goes from right to left . NULLS IGNORE | RETURN | IGNOREEND Treatment of null fields . By default adjacent delimiters in the input string do not create an empty string in the output array . if NULLS = 'return' adjacent delimiters create an empty element in the output ARRAY . If NULLS = 'ignoreend' then only trailing delimiters at the right of the string are ignored . EXAMPLES Sample program: program demo_split use M_strings , only : split character ( len =* ) , parameter :: & & line = ' aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc ' character ( len = : ) , allocatable :: array ( : ) ! output array of tokens write ( * , * ) ' INPUT LINE:[ ' // LINE // ' ] ' write ( * , ' (80(\"=\")) ' ) write ( * , * ) ' typical call: ' CALL split ( line , array ) write ( * , ' (i0,\" ==> \",a) ' )( i , trim ( array ( i )) , i = 1 , size ( array )) write ( * , * ) ' SIZE: ' , SIZE ( array ) write ( * , ' (80(\"-\")) ' ) write ( * , * ) ' custom list of delimiters (colon and vertical line): ' CALL split ( line , array , delimiters = ' :| ' , order = ' sequential ' , nulls = ' ignore ' ) write ( * , ' (i0,\" ==> \",a) ' )( i , trim ( array ( i )) , i = 1 , size ( array )) write ( * , * ) ' SIZE: ' , SIZE ( array ) write ( * , ' (80(\"-\")) ' ) write ( * , * ) & & ' custom list of delimiters, reverse array order and count null fields: ' CALL split ( line , array , delimiters = ' :| ' , order = ' reverse ' , nulls = ' return ' ) write ( * , ' (i0,\" ==> \",a) ' )( i , trim ( array ( i )) , i = 1 , size ( array )) write ( * , * ) ' SIZE: ' , SIZE ( array ) write ( * , ' (80(\"-\")) ' ) write ( * , * ) ' INPUT LINE:[ ' // LINE // ' ] ' write ( * , * ) & & ' default delimiters and reverse array order and return null fields: ' CALL split ( line , array , delimiters = '' , order = ' reverse ' , nulls = ' return ' ) write ( * , ' (i0,\" ==> \",a) ' )( i , trim ( array ( i )) , i = 1 , size ( array )) write ( * , * ) ' SIZE: ' , SIZE ( array ) end program demo_split Output > INPUT LINE :[ aBcdef ghijklmnop qrstuvwxyz 1 : | : 2 333 | 333 a B cc ] > =========================================================================== > typical call : > 1 ==> aBcdef > 2 ==> ghijklmnop > 3 ==> qrstuvwxyz > 4 ==> 1 : | : 2 > 5 ==> 333 | 333 > 6 ==> a > 7 ==> B > 8 ==> cc > SIZE : 8 > -------------------------------------------------------------------------- > custom list of delimiters ( colon and vertical line ) : > 1 ==> aBcdef ghijklmnop qrstuvwxyz 1 > 2 ==> 2 333 > 3 ==> 333 a B cc > SIZE : 3 > -------------------------------------------------------------------------- > custom list of delimiters , reverse array order and return null fields : > 1 ==> 333 a B cc > 2 ==> 2 333 > 3 ==> > 4 ==> > 5 ==> aBcdef ghijklmnop qrstuvwxyz 1 > SIZE : 5 > -------------------------------------------------------------------------- > INPUT LINE :[ aBcdef ghijklmnop qrstuvwxyz 1 : | : 2 333 | 333 a B cc ] > default delimiters and reverse array order and count null fields : > 1 ==> > 2 ==> > 3 ==> > 4 ==> cc > 5 ==> B > 6 ==> a > 7 ==> 333 | 333 > 8 ==> > 9 ==> > 10 ==> > 11 ==> > 12 ==> 1 : | : 2 > 13 ==> > 14 ==> qrstuvwxyz > 15 ==> ghijklmnop > 16 ==> > 17 ==> > 18 ==> aBcdef > 19 ==> > 20 ==> > SIZE : 20 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Contents Variables dlim i10 i20 i30 ibegin icol icount idlim ifound ii iiii ilen imax inotnull ireturn iterm n nlls ordr Source Code split Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: dlim integer, public :: i10 integer, public :: i20 integer, public :: i30 integer, public, allocatable :: ibegin (:) integer, public :: icol integer, public :: icount integer, public :: idlim integer, public :: ifound integer, public :: ii integer, public :: iiii integer, public :: ilen integer, public :: imax integer, public :: inotnull integer, public :: ireturn integer, public, allocatable :: iterm (:) integer, public :: n character(len=:), public, allocatable :: nlls character(len=:), public, allocatable :: ordr Source Code subroutine split ( input_line , array , delimiters , order , nulls ) !----------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_7=\"& !&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array\" !  John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- intrinsic index , min , present , len !----------------------------------------------------------------------------------------------------------------------------------- !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens !----------------------------------------------------------------------------------------------------------------------------------- integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token !----------------------------------------------------------------------------------------------------------------------------------- ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters . ne . '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter !----------------------------------------------------------------------------------------------------------------------------------- n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 !----------------------------------------------------------------------------------------------------------------------------------- ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found !----------------------------------------------------------------------------------------------------------------------------------- select case ( ilen ) !----------------------------------------------------------------------------------------------------------------------------------- case (: 0 ) ! command was totally blank !----------------------------------------------------------------------------------------------------------------------------------- case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )). eq . 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound . gt . 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol . gt . ilen ) then ! no text left exit INFINITE endif enddo INFINITE !----------------------------------------------------------------------------------------------------------------------------------- end select !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select !----------------------------------------------------------------------------------------------------------------------------------- do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ). lt . ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo !----------------------------------------------------------------------------------------------------------------------------------- end subroutine split","tags":"","loc":"proc/split.html"},{"title":"stderr – M_time","text":"public subroutine stderr(string) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name character(len=*) :: string Contents Source Code stderr Source Code subroutine stderr ( string ) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT character ( len =* ) :: string write ( ERROR_UNIT , '(a)' ) string end subroutine stderr","tags":"","loc":"proc/stderr.html"},{"title":"string_to_values – M_time","text":"public subroutine string_to_values(line, iread, values, inums, delims, ierr) NAME string_to_values(3f) - [M_strings:NUMERIC] read a string representing numbers into a numeric array\n  (LICENSE:PD) SYNOPSIS subroutine string_to_values(line,iread,values,inums,delims,ierr)\n\n    character(len=*) :: line\n    integer          :: iread\n    real             :: values(*)\n    integer          :: inums\n    character(len=*) :: delims\n    integer          :: ierr DESCRIPTION This routine can take a string representing a series of numbers and\n   convert it to a numeric array and return how many numbers were found. OPTIONS LINE     Input string containing numbers\n   IREAD    maximum number of values to try to read from input string RESULTS VALUES real array to be filled with numbers INUMS number of values successfully read ( before error occurs if one does ) DELIMS delimiter character ( s ) , usually a space . must not be a null string . If more than one character , a space must not be the last character or it will be ignored . IERR error flag ( 0 = no error , else column number string starts at that error occurred on ) . EXAMPLE Sample Program: program demo_string_to_values use M_strings , only : string_to_values character ( len = 80 ) :: s = ' 10 20e3;3.45 -400.3e-2;1234; 5678 ' integer , parameter :: isz = 10 real :: array ( isz ) call string_to_values ( s , 10 , array , inums , ' ;' , ierr ) call reportit () call string_to_values ( '10;2.3;3.1416' , isz , array , inums , ' ;' , ierr ) call reportit () contains subroutine reportit () write (*,*) 'string_to_values:' write (*,*) 'input string.............' , trim ( s ) write (*,*) 'number of values found...' , inums write (*,*) 'values...................' ,( array ( ii ), ii = 1 , inums ) end subroutine reportit end program demo_string_to_values Expected output string_to_values : input string ............. 10 20e3 ; 3 . 45 -400 . 3e-2 ; 1234 ; 5678 number of values found ... 6 values ................... 10 . 0000000 20000 . 0000 3 . 45000005 -4 . 00299978 1234 . 00000 5678 . 00000 string_to_values : input string ............. 10 20e3 ; 3 . 45 -400 . 3e-2 ; 1234 ; 5678 number of values found ... 3 values ................... 10 . 0000000 2 . 29999995 3 . 14159989 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: iread real, intent(inout) :: values (iread) integer, intent(out) :: inums character(len=*), intent(in) :: delims integer, intent(out) :: ierr Contents Variables delimiters_length delims_local i10 i20 i40 icol iend ier ilen istart rval Source Code string_to_values Variables Type Visibility Attributes Name Initial integer, public :: delimiters_length character(len=256), public :: delims_local integer, public :: i10 integer, public :: i20 integer, public :: i40 integer, public :: icol integer, public :: iend integer, public :: ier integer, public :: ilen integer, public :: istart real, public :: rval Source Code subroutine string_to_values ( line , iread , values , inums , delims , ierr ) implicit none !---------------------------------------------------------------------------------------------------------------------------------- !   1989,1997-12-31,2014 John S. Urban !   given a line of structure , string , string , string process each !   string as a numeric value and store into an array. !   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS. !   There is no direct checking for more values than can fit in VALUES. !   Quits if encounters any errors in read. !---------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_54=\"@(#)M_strings::string_to_values(3f): reads an array of numbers from a numeric string\" character ( len =* ), intent ( in ) :: line ! input string integer , intent ( in ) :: iread ! maximum number of values to try to read into values real , intent ( inout ) :: values ( iread ) ! real array to be filled with values integer , intent ( out ) :: inums ! number of values successfully read from string character ( len =* ), intent ( in ) :: delims ! allowed delimiters integer , intent ( out ) :: ierr ! 0 if no error, else column number undecipherable string starts at !---------------------------------------------------------------------------------------------------------------------------------- character ( len = 256 ) :: delims_local ! mutable copy of allowed delimiters integer :: istart , iend , ilen , icol integer :: i10 , i20 , i40 real :: rval integer :: ier integer :: delimiters_length !---------------------------------------------------------------------------------------------------------------------------------- delims_local = delims ! need a mutable copy of the delimiter list if ( delims_local . eq . '' ) then ! if delimiter list is null or all spaces make it a space delims_local = ' ' ! delimiter is a single space delimiters_length = 1 ! length of delimiter list else delimiters_length = len_trim ( delims ) ! length of variable WITH TRAILING WHITESPACE TRIMMED endif !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error code returned inums = 0 ! initialize count of values successfully returned istart = 0 !---------------------------------------------------------------------------------------------------------------------------------- ilen = 0 ! ilen will be the position of the right-most non-delimiter in the input line do i20 = len ( line ), 1 , - 1 ! loop from end of string to beginning to find right-most non-delimiter if ( index ( delims_local (: delimiters_length ), line ( i20 : i20 )). eq . 0 ) then ! found a non-delimiter ilen = i20 exit endif enddo if ( ilen . eq . 0 ) then ! command was totally composed of delimiters call stderr ( '*string_to_values* blank line passed as a list of numbers' ) return endif !---------------------------------------------------------------------------------------------------------------------------------- !     there is at least one non-delimiter sub-string !     ilen is the column position of the last non-delimiter character !     now, starting at beginning of string find next non-delimiter icol = 1 ! pointer to beginning of unprocessed part of LINE LOOP : dO i10 = 1 , iread , 1 ! each pass should find a value if ( icol . gt . ilen ) EXIT LOOP ! everything is done INFINITE : do if ( index ( delims_local (: delimiters_length ), line ( icol : icol )). eq . 0 ) then ! found non-delimiter istart = icol iend = 0 ! FIND END OF SUBSTRING do i40 = istart , ilen ! look at each character starting at left if ( index ( delims_local (: delimiters_length ), line ( i40 : i40 )). ne . 0 ) then ! determine if character is a delimiter iend = i40 ! found a delimiter. record where it was found EXIT ! found end of substring so leave loop endif enddo if ( iend . eq . 0 ) iend = ilen + 1 ! no delimiters found, so this substring goes to end of line iend = iend - 1 ! do not want to pass delimiter to be converted rval = 0.0 call string_to_value ( line ( istart : iend ), rval , ier ) ! call procedure to convert string to a numeric value if ( ier . eq . 0 ) then ! a substring was successfully converted to a numeric value values ( i10 ) = rval ! store numeric value in return array inums = inums + 1 ! increment number of values converted to a numeric value else ! an error occurred converting string to value ierr = istart ! return starting position of substring that could not be converted return endif icol = iend + 2 ! set to next character to look at CYCLE LOOP ! start looking for next value else ! this is a delimiter so keep looking for start of next string icol = icol + 1 ! increment pointer into LINE CYCLE INFINITE endif enddo INFINITE enddo LOOP !     error >>>>> more than iread numbers were in the line. end subroutine string_to_values","tags":"","loc":"proc/string_to_values.html"},{"title":"substitute – M_time","text":"public subroutine substitute(targetline, old, new, ierr, start, end) NAME substitute ( 3 f ) - [ M_strings : EDITING ] subroutine globally substitutes one substring for another in string ( LICENSE : PD ) SYNOPSIS subroutine substitute ( targetline , old , new , ierr , start , end ) character ( len =* ) :: targetline character ( len =* ) , intent ( in ) :: old character ( len =* ) , intent ( in ) :: new integer , intent ( out ) , optional :: ierr integer , intent ( in ) , optional :: start integer , intent ( in ) , optional :: end DESCRIPTION Globally substitute one substring for another in string. OPTIONS TARGETLINE input line to be changed . Must be long enough to hold altered output . OLD substring to find and replace NEW replacement for OLD substring IERR error code . If IER = - 1 bad directive , >= 0 then count of changes made . START sets the left margin to be scanned for OLD in TARGETLINE . END sets the right margin to be scanned for OLD in TARGETLINE . EXAMPLES Sample Program : program demo_substitute use M_time , only : substitute implicit none ! must be long enough to hold changed line character ( len = 80 ) :: targetline targetline = ' this is the input string ' write ( * , * ) ' ORIGINAL    : ' // trim ( targetline ) ! changes the input to ' THis is THe input string ' call substitute ( targetline , ' th ' , ' TH ' ) write ( * , * ) ' th => TH    : ' // trim ( targetline ) ! a null old substring means \" at beginning of line \" ! changes the input to ' BEFORE:this is the input string ' call substitute ( targetline , '' , ' BEFORE: ' ) write ( * , * ) ' \"\" => BEFORE: ' // trim ( targetline ) ! a null new string deletes occurrences of the old substring ! changes the input to ' ths s the nput strng ' call substitute ( targetline , ' i ' , '' ) write ( * , * ) ' i => \"\"     : ' // trim ( targetline ) end program demo_substitute Expected output ORIGINAL : this is the input string th => TH : THis is THe input string \"\" => BEFORE : BEFORE : THis is THe input string i => \"\" : BEFORE : THs s THe nput strng AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*) :: targetline character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(out), optional :: ierr integer, intent(in), optional :: start integer, intent(in), optional :: end Contents Variables dum1 ic ichar id ier1 il ind ir ladd len_new len_old maxlengthout ml mr original_input_length Source Code substitute Variables Type Visibility Attributes Name Initial character(len=len), public :: dum1 integer, public :: ic integer, public :: ichar integer, public :: id integer, public :: ier1 integer, public :: il integer, public :: ind integer, public :: ir integer, public :: ladd integer, public :: len_new integer, public :: len_old integer, public :: maxlengthout integer, public :: ml integer, public :: mr integer, public :: original_input_length Source Code subroutine substitute ( targetline , old , new , ierr , start , end ) !character(len=*),parameter::ident_11=\"@(#)M_strings::substitute(3f): Globally substitute one substring for another in string\" !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ) :: targetline ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made integer , intent ( in ), optional :: start ! start sets the left margin integer , intent ( in ), optional :: end ! end sets the right margin !----------------------------------------------------------------------------------------------------------------------------------- character ( len = len ( targetline )) :: dum1 ! scratch string buffers integer :: ml , mr , ier1 integer :: maxlengthout ! MAXIMUM LENGTH ALLOWED FOR NEW STRING integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: ir integer :: ind integer :: il integer :: id integer :: ic integer :: ichar !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( start )) then ! optional starting column ml = start else ml = 1 endif if ( present ( end )) then ! optional ending column mr = end else mr = len ( targetline ) endif !----------------------------------------------------------------------------------------------------------------------------------- ier1 = 0 ! initialize error flag/change count maxlengthout = len ( targetline ) ! max length of output string original_input_length = len_trim ( targetline ) ! get non-blank length of input line dum1 (:) = ' ' ! initialize string to build output in id = mr - ml ! check for window option !x! change to optional parameter(s) !----------------------------------------------------------------------------------------------------------------------------------- len_old = len ( old ) ! length of old substring to be replaced len_new = len ( new ) ! length of new substring to replace old substring if ( id . le . 0 ) then ! no window so change entire input string il = 1 ! il is left margin of window to change ir = maxlengthout ! ir is right margin of window to change dum1 (:) = ' ' ! begin with a blank line else ! if window is set il = ml ! use left margin ir = min0 ( mr , maxlengthout ) ! use right margin or rightmost dum1 = targetline (: il - 1 ) ! begin with what's below margin endif ! end of window settings !----------------------------------------------------------------------------------------------------------------------------------- if ( len_old . eq . 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichar = len_new + original_input_length if ( ichar . gt . maxlengthout ) then call stderr ( '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( len_new . gt . 0 ) then dum1 ( il :) = new (: len_new ) // targetline ( il : original_input_length ) else dum1 ( il :) = targetline ( il : original_input_length ) endif targetline ( 1 : maxlengthout ) = dum1 (: maxlengthout ) ier1 = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ier1 return endif !----------------------------------------------------------------------------------------------------------------------------------- ichar = il ! place to put characters into output string ic = il ! place looking at in input string loop : do ind = index ( targetline ( ic :), old (: len_old )) + ic - 1 ! try to find start of old string in remaining part of input in change window if ( ind . eq . ic - 1. or . ind . gt . ir ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif ier1 = ier1 + 1 ! found an old string to change, so increment count of changes if ( ind . gt . ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output if ( ichar - 1 + ladd . gt . maxlengthout ) then ier1 =- 1 exit loop endif dum1 ( ichar :) = targetline ( ic : ind - 1 ) ichar = ichar + ladd endif if ( ichar - 1 + len_new . gt . maxlengthout ) then ier1 =- 2 exit loop endif if ( len_new . ne . 0 ) then dum1 ( ichar :) = new (: len_new ) ichar = ichar + len_new endif ic = ind + len_old enddo loop !----------------------------------------------------------------------------------------------------------------------------------- select case ( ier1 ) case (: - 1 ) call stderr ( '*substitute* new line will be too long' ) case ( 0 ) ! there were no changes made to the window case default ladd = original_input_length - ic if ( ichar + ladd . gt . maxlengthout ) then call stderr ( '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( ic . lt . len ( targetline )) then dum1 ( ichar :) = targetline ( ic : max ( ic , original_input_length )) endif targetline = dum1 (: maxlengthout ) end select if ( present ( ierr )) ierr = ier1 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine substitute","tags":"","loc":"proc/substitute.html"},{"title":"trimzeros – M_time","text":"public subroutine trimzeros(string) NAME trimzeros(3fp) - [M_strings:NUMERIC] Delete trailing zeros from numeric decimal string\n(LICENSE:PD) SYNOPSIS subroutine trimzeros(str)\n\n character(len=*)  :: str DESCRIPTION TRIMZEROS(3f) deletes trailing zeros from a string representing a\n   number. If the resulting string would end in a decimal point, one\n   trailing zero is added. OPTIONS str   input string will be assumed to be a numeric value and have trailing\n      zeros removed EXAMPLES Sample program : program demo_trimzeros use M_strings , only : trimzeros character ( len = : ) , allocatable :: string write ( * , * ) trimzeros ( ' 123.450000000000 ' ) write ( * , * ) trimzeros ( ' 12345 ' ) write ( * , * ) trimzeros ( ' 12345. ' ) write ( * , * ) trimzeros ( ' 12345.00e3 ' ) end program demo_trimzeros AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*) :: string Contents Variables exp i ii ipos str Source Code trimzeros Variables Type Visibility Attributes Name Initial character(len=len), public :: exp integer, public :: i integer, public :: ii integer, public :: ipos character(len=len), public :: str Source Code subroutine trimzeros ( string ) !character(len=*),parameter::ident_50=\"@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string\" ! if zero needs added at end assumes input string has room character ( len =* ) :: string character ( len = len ( string ) + 2 ) :: str character ( len = len ( string )) :: exp ! the exponent string if present integer :: ipos ! where exponent letter appears if present integer :: i , ii str = string ! working copy of string ipos = scan ( str , 'eEdD' ) ! find end of real number if string uses exponent notation if ( ipos > 0 ) then ! letter was found exp = str ( ipos :) ! keep exponent string so it can be added back as a suffix str = str ( 1 : ipos - 1 ) ! just the real part, exponent removed will not have trailing zeros removed endif if ( index ( str , '.' ). eq . 0 ) then ! if no decimal character in original string add one to end of string ii = len_trim ( str ) str ( ii + 1 : ii + 1 ) = '.' ! add decimal to end of string endif do i = len_trim ( str ), 1 , - 1 ! scanning from end find a non-zero character select case ( str ( i : i )) case ( '0' ) ! found a trailing zero so keep trimming cycle case ( '.' ) ! found a decimal character at end of remaining string if ( i . le . 1 ) then str = '0' else str = str ( 1 : i - 1 ) endif exit case default str = str ( 1 : i ) ! found a non-zero character so trim string and exit exit end select end do if ( ipos > 0 ) then ! if originally had an exponent place it back on string = trim ( str ) // trim ( exp ) else string = str endif end subroutine trimzeros","tags":"","loc":"proc/trimzeros.html"},{"title":"value_to_string – M_time","text":"public subroutine value_to_string(gval, chars, length, err, fmt, trimz) NAME value_to_string ( 3 f ) - [ M_strings : NUMERIC ] return numeric string from a numeric value ( LICENSE : PD ) SYNOPSIS subroutine value_to_string(value,chars[,ilen,ierr,fmt,trimz])\n\n character(len=*) :: chars  ! minimum of 23 characters required\n !--------\n ! VALUE may be any <em> one </em> of the following types:\n doubleprecision,intent(in)               :: value\n real,intent(in)                          :: value\n integer,intent(in)                       :: value\n logical,intent(in)                       :: value\n !--------\n character(len=*),intent(out)             :: chars\n integer,intent(out),optional             :: ilen\n integer,optional                         :: ierr\n character(len=*),intent(in),optional     :: fmt\n logical,intent(in)                       :: trimz DESCRIPTION value_to_string(3f) returns a numeric representation of a numeric\n   value in a string given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the string using internal writes. It\n   then removes trailing zeros from non-zero values, and left-justifies\n   the string. OPTIONS VALUE input value to be converted to a string FMT You may specify a specific format that produces a string up to the length of CHARS ; optional. TRIMZ If a format is supplied the default is not to try to trim trailing zeros . Set TRIMZ to . true . to trim zeros from a string assumed to represent a simple numeric value . RETURNS CHARS returned string representing input value , must be at least 23 characters long ; or what is required by optional FMT if longer. ILEN position of last non - blank character in returned string ; optional. IERR If not zero , error occurred ; optional. EXAMPLE Sample program : program demo_value_to_string use M_strings , only : value_to_string implicit none character ( len = 80 ) :: string integer :: ilen call value_to_string ( 3 . 0 / 4 . 0 , string , ilen ) write ( * , * ) ' The value is [ ' , string ( : ilen ) , ' ] ' call value_to_string ( 3 . 0 / 4 . 0 , string , ilen , fmt = '' ) write ( * , * ) ' The value is [ ' , string ( : ilen ) , ' ] ' call value_to_string ( 3 . 0 / 4 . 0 , string , ilen , fmt = ' (\"THE VALUE IS \",g0) ' ) write ( * , * ) ' The value is [ ' , string ( : ilen ) , ' ] ' call value_to_string ( 1234 , string , ilen ) write ( * , * ) ' The value is [ ' , string ( : ilen ) , ' ] ' call value_to_string ( 1 . 0 d0 / 3 . 0 d0 , string , ilen ) write ( * , * ) ' The value is [ ' , string ( : ilen ) , ' ] ' end program demo_value_to_string Expected output The value is [ 0 . 75 ] The value is [ 0 . 7500000000 ] The value is [ THE VALUE IS . 750000000 ] The value is [ 1234 ] The value is [ 0 . 33333333333333331 ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: gval character(len=*), intent(out) :: chars integer, intent(out), optional :: length integer, optional :: err character(len=*), intent(in), optional :: fmt logical, intent(in), optional :: trimz Contents Variables err_local fmt_local msg Source Code value_to_string Variables Type Visibility Attributes Name Initial integer, public :: err_local character(len=:), public, allocatable :: fmt_local character(len=1024), public :: msg Source Code subroutine value_to_string ( gval , chars , length , err , fmt , trimz ) !character(len=*),parameter::ident_40=\"@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value\" class ( * ), intent ( in ) :: gval character ( len =* ), intent ( out ) :: chars integer , intent ( out ), optional :: length integer , optional :: err integer :: err_local character ( len =* ), optional , intent ( in ) :: fmt ! format to write value with logical , intent ( in ), optional :: trimz character ( len = :), allocatable :: fmt_local character ( len = 1024 ) :: msg !  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL) if ( present ( fmt )) then select type ( gval ) type is ( integer ) fmt_local = '(i0)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( real ) fmt_local = '(bz,g23.10e3)' fmt_local = '(bz,g0.8)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) fmt_local = '(bz,g0)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( logical ) fmt_local = '(l1)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval class default call stderr ( '*value_to_string* UNKNOWN TYPE' ) chars = ' ' end select if ( fmt . eq . '' ) then chars = adjustl ( chars ) call trimzeros ( chars ) endif else ! no explicit format option present err_local =- 1 select type ( gval ) type is ( integer ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( real ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( logical ) write ( chars , * , iostat = err_local , iomsg = msg ) gval class default chars = '' end select chars = adjustl ( chars ) if ( index ( chars , '.' ). ne . 0 ) call trimzeros ( chars ) endif if ( present ( trimz )) then if ( trimz ) then chars = adjustl ( chars ) call trimzeros ( chars ) endif endif if ( present ( length )) then length = len_trim ( chars ) endif if ( present ( err )) then err = err_local elseif ( err_local . ne . 0 ) then !x! cannot currently do I/O from a function being called from I/O !x!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']' chars = chars // ' *value_to_string* WARNING:[' // trim ( msg ) // ']' endif end subroutine value_to_string","tags":"","loc":"proc/value_to_string.html"},{"title":"string_to_value – M_time","text":"public interface string_to_value Contents Module Procedures a2d a2r a2i Module Procedures public subroutine a2d (chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns doubleprecision value from string doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr public subroutine a2r (chars, valu, ierr) returns a numeric value from a numeric character string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns real value from string real, intent(out) :: valu integer, intent(out) :: ierr public subroutine a2i (chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns integer value from string integer, intent(out) :: valu integer, intent(out) :: ierr","tags":"","loc":"interface/string_to_value.html"},{"title":"v2s – M_time","text":"public interface v2s Contents Module Procedures d2s r2s i2s l2s Module Procedures public function d2s (dvalue, fmt) result(outstr) v2s(3f) returns a representation of a numeric value as a\n   string when given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the strings using internal WRITE()\n   statements. Trailing zeros are removed from non-zero values, and the\n   string is left-justified. Read more… Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function r2s (rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function i2s (ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function l2s (lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable","tags":"","loc":"interface/v2s.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   sec2days(1f) - [TIME] Convert seconds to string of form dd-hh:mm:ss                                                          ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   sec2days nnnn[.xxx] [ -crop]| --version| --help                                                                              ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Given a numeric string representing seconds convert it to a string                                                           ' ,& '   of the form                                                                                                                  ' ,& '                                                                                                                                ' ,& '      dd-hh:mm:ss                                                                                                               ' ,& '                                                                                                                                ' ,& '   where dd is days, hh hours, mm minutes and ss seconds.                                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   nnnn[.xxx]  number of seconds to convert to string of form dd-hh:mm:ss.                                                      ' ,& '               nnnn may be interspersed with unit codes d,h,m,s. Spaces,                                                        ' ,& '               commas and case are ignored. Allowed aliases for the unit                                                        ' ,& '               codes are                                                                                                        ' ,& '                 d  days and day                                                                                                ' ,& '                 h  hours,hour,hrs, and hr                                                                                      ' ,& '                 m  minutes,minute and min                                                                                      ' ,& '                 s  seconds,second and sec                                                                                      ' ,& '                                                                                                                                ' ,& '   -crop       trim leading zero values from output                                                                             ' ,& '   -radix      character used as decimal separator                                                                              ' ,& '   --help      display this help and exit                                                                                       ' ,& '   --version   output version information and exit                                                                              ' ,& '                                                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& ' usage                                                                                                                          ' ,& '                                                                                                                                ' ,& '   sec2days 129860                                                                                                              ' ,& '   1-12:04:20                                                                                                                   ' ,& '   sec2days 1d2h3m4s                                                                                                            ' ,& '   1-02:03:04                                                                                                                   ' ,& '   sec2days 1.0 days 2 hours 3 minutes 4 seconds                                                                                ' ,& '   1-02:03:04                                                                                                                   ' ,& '   sec2days 1.5d                                                                                                                ' ,& '   1-12:00:00                                                                                                                   ' ,& '                                                                                                                                ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME sec2days ( 1 f ) - [ TIME ] Convert seconds to string of form dd - hh : mm : ss ( LICENSE : PD ) SYNOPSIS sec2days nnnn[.xxx] [ -crop]| --version| --help DESCRIPTION Given a numeric string representing seconds convert it to a string\nof the form\n\n   dd-hh:mm:ss\n\nwhere dd is days, hh hours, mm minutes and ss seconds. OPTIONS nnnn [. xxx ] number of seconds to convert to string of form dd - hh : mm : ss . nnnn may be interspersed with unit codes d , h , m , s . Spaces , commas and case are ignored . Allowed aliases for the unit codes are d days and day h hours , hour , hrs , and hr m minutes , minute and min s seconds , second and sec - crop trim leading zero values from output - radix character used as decimal separator -- help display this help and exit -- version output version information and exit EXAMPLE usage sec2days 129860\n1-12:04:20\nsec2days 1d2h3m4s\n1-02:03:04\nsec2days 1.0 days 2 hours 3 minutes 4 seconds\n1-02:03:04\nsec2days 1.5d\n1-12:00:00 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        sec2days(1f)>' ,& '@(#)DESCRIPTION:    convert seconds to string of form dd-hh:mm:ss>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        now(1f)>' ,& '@(#)DESCRIPTION:    Report a date in a variety of formats>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version~5.html"},{"title":"usage – M_time","text":"subroutine usage() Arguments None Contents Variables i ident text Source Code usage Variables Type Visibility Attributes Name Initial integer, public :: i character(len=*), public, parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character(len=80), public, allocatable :: text (:) Source Code subroutine usage () ! character ( len =* ), parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character ( len = 80 ), allocatable :: text (:) integer :: i ! NOTE: Without the type specification this constructor would have to specify all of the constants with the same character length. text = [ character ( len = len ( text ( 1 ))) :: & & 'NAME                                                                            ' ,& & '   now(1f)  - [TIME] print the date and time                                    ' ,& & '   (LICENSE:PD)                                                                 ' ,& & '                                                                                ' ,& & 'SYNOPSIS                                                                        ' ,& & '  now [Format [ -date date_str|-ued Unix_time|-jed Julian_Date|-dat date_vector]' ,& & '      [ -delta dd-hh:mm:ss]]|--help |--version|-test]                           ' ,& & '                                                                                ' ,& & 'DESCRIPTION                                                                     ' ,& & '   Report the current time or a Fortran date vector in a variety of formats.    ' ,& & '   Julian dates, Unix Epoch time, weekdays, monthnames, ordinal days,           ' ,& & '   AM/PM and iso-8601 week-numbering are supported by building a format         ' ,& & '   string containing the desired macros.                                        ' ,& & 'OPTIONS                                                                         ' ,& & '   Format  :                                                                    ' ,& & '     This string, containing macro names or keywords, creates the format used   ' ,& & '     to print the specified date.                                               ' ,& & '                                                                                ' ,& & '     The FORMAT string is expanded using the following macros:                  ' ,& & '                                                                                ' ,& & 'CALL FMTDATE_USAGE                                                              ' ,& & '                                                                                ' ,& & '   -dat date_vector  :                                                          ' ,& & '      A date vector is eight integers representing a date in the same manner as ' ,& & '      the Fortran DATE_AND_TIME(3f) function:                                   ' ,& & '          yyyy mm dd zone hh mm ss mss                                          ' ,& & '      only numeric time zones are supported.                                    ' ,& & '                                                                                ' ,& & '      When present, the specified date is used instead of the current time.     ' ,& & '                                                                                ' ,& & '   -uet Unix_Epoch_Time  :                                                      ' ,& & '      When present a value is used as the Unix Epoch Time. This date is         ' ,& & '      is then adjusted using any -delta value and then printed using            ' ,& & '      the specified format.                                                     ' ,& & '                                                                                ' ,& & '   -jed Julian_Date  :                                                          ' ,& & '      When present a value is used as the Julian Ephemeris Date.                ' ,& & '                                                                                ' ,& & '   -delta dd-hh:mm:ss  :                                                        ' ,& & '      Add the specified duration to the date.                                   ' ,& & '                                                                                ' ,& & '   -date date_str  :                                                            ' ,& & '      The guessdate(3f) routine is used to try to convert a date description    ' ,& & '      to a date vector. For the guess to work, dates must either be in the      ' ,& & '      form YYYY-MM-DD or the order of numeric values must be \"\"dd yy yyy\".      ' ,& & '      Only four-digit years are supported. Month names are preferred over       ' ,& & '      numeric values. See the guessdate(3f) documentation for further details.  ' ,& & '                                                                                ' ,& & '   -test :                                                                      ' ,& & '      To list allowed macros use the -test switch.                              ' ,& & '                                                                                ' ,& & '   When present, the specified date is used instead of the current time.        ' ,& & 'EXAMPLES                                                                        ' ,& & ' Sample commands:                                                               ' ,& & '                                                                                ' ,& & '  now                                                                           ' ,& & '    Friday, June 17th, 2016 03:22:53 PM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta  1-0:0:0  # Tomorrow                                               ' ,& & '    Sunday, June 19th, 2016 11:32:26 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta -1-0:0:0  # Yesterday                                              ' ,& & '    Friday, June 17th, 2016 11:32:43 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now long -delta  7-0:0:0  # Next week                                         ' ,& & '    Saturday, June 25th, 2016 11:32:57 AM UTC-04:00                             ' ,& & '                                                                                ' ,& & '  now The date is %Y/%M/%D %h:%m:%s  # user-specified formats using macros      ' ,& & '    The date is 2009/08/10 00:33:48                                             ' ,& & '                                                                                ' ,& & '  now Y/M/D h:m:s # user-specified format with no % character                   ' ,& & '    2009/08/10 00:33:48                                                         ' ,& & '                                                                                ' ,& & '  now year-month-day # user-specified format with no % with long keywords       ' ,& & '  2016-07-29                                                                    ' ,& & '                                                                                ' ,& & '  now -dat 2016 07 23 -240 1 01 00 00  # alternate date                         ' ,& & '  Saturday, July 23rd, 2016 1:01:00 AM UTC-4:00                                 ' ,& & '                                                                                ' ,& & '  now -uet  1469250060                 # alternate Unix Epoch date              ' ,& & '  now -date January 4th, 1999 10:20:30 # try to determine date from description.' ,& & '                                                                                ' ,& & '  now YEAR=%Y MONTH=%M DAY=%D          # YEAR=2009 MONTH=08 DAY=10              ' ,& & '                                                                                ' ,& & '  now HOUR=%h MINUTES=%m SECONDS=%s MILLISECONDS=%x                             ' ,& & '      HOUR=01 MINUTES=18 SECONDS=44 MILLISECONDS=946                            ' ,& & '                                                                                ' ,& & '  # double-quotes are tricky (double them) to put in literally in this program: ' ,& & '  now ''\"\"year-month-day\"\",\"\"hour-minute-second\"\"'' #  \"2017-04-23\",\"14-41-09\"  ' ,& & '                                                                                ' ,& & '  # quotes are easier to control using the single-letter macros(use %q and %Q): ' ,& & '  now QY-M-DQ,Qh:m:sQ                                                           ' ,& & '     \"2017-04-23\",\"14-41-09\"                                                    ' ,& & '                                                                                ' ,& & '  now -test       # Show formatting options, handy way to look up macro names   ' ,& & '                                                                                ' ,& & 'LIMITS                                                                          ' ,& & '  See the M_time module description. Basically, A Gregorian Calendar is         ' ,& & '  assumed, and Leap Seconds are not specifically accounted for.                 ' ,& & 'SEE ALSO                                                                        ' ,& & '   month(1), sec2days(1), days2sec(1), easter(1), paws(1), today(1), ttee(1)    ' ,& & 'AUTHOR                                                                          ' ,& & '   John S. Urban                                                                ' ,& & 'LICENSE                                                                         ' ,& & '   Public Domain                                                                ' ,& & '                                                                                ' ] do i = 1 , size ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 6 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo stop end subroutine usage","tags":"","loc":"proc/usage.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds                                                                ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   days2sec dd-hh:mm:ss | --version| --help                                                                                     ' ,& '   days2sec NNdNNhNNmNNs                                                                                                        ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss where dd is days, hh hours,                                                         ' ,& '   mm minutes and ss seconds convert it to seconds. Many utilities (ps(1),                                                      ' ,& '   for example) show times in this format to make it more intelligible;                                                         ' ,& '   but it generally easier to perform math on values represented in                                                             ' ,& '   seconds.                                                                                                                     ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   dd-hh:mm:ss  Given a string representing a duration of time in the                                                           ' ,& '                following forms:                                                                                                ' ,& '                                                                                                                                ' ,& '                  dd-hh:mm:ss                                                                                                   ' ,& '                     hh:mm:ss                                                                                                   ' ,& '                        mm:ss                                                                                                   ' ,& '                           ss                                                                                                   ' ,& '                                                                                                                                ' ,& '                convert it to seconds.                                                                                          ' ,& '                                                                                                                                ' ,& '                The numeric values may represent floating point numbers.                                                        ' ,& '                                                                                                                                ' ,& '                Spaces are ignored.                                                                                             ' ,& '                                                                                                                                ' ,& '    NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes;                                                    ' ,& '                  where s,m,h, or d represents seconds, minutes, hours                                                          ' ,& '                  or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are                                  ' ,& '                                                                                                                                ' ,& '                   w -  weeks,week,wk,wks                                                                                       ' ,& '                   d -  days,day                                                                                                ' ,& '                   m -  minutes,minute,min                                                                                      ' ,& '                   h -  hours,hour,hrs,hr                                                                                       ' ,& '                   s -  seconds,second,sec,secs                                                                                 ' ,& '                                                                                                                                ' ,& '                  The numeric values may represent floating point numbers.                                                      ' ,& '                                                                                                                                ' ,& '                  Spaces, commas  and case are ignored.                                                                         ' ,& '                                                                                                                                ' ,& '   --denominator  divide the result by this value. Default is one(1).                                                           ' ,& '   --help         display this help and exit                                                                                    ' ,& '   --version      output version information and exit                                                                           ' ,& '                                                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& '  Usage                                                                                                                         ' ,& '                                                                                                                                ' ,& '    days2sec 1-12:04:20                                                                                                         ' ,& '    129860                                                                                                                      ' ,& '    days2sec 1.5 days                                                                                                           ' ,& '    129600                                                                                                                      ' ,& '    days2sec 1.5 days 4hrs 30minutes                                                                                            ' ,& '    145800                                                                                                                      ' ,& '    days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED                                                                    ' ,& '    30                                                                                                                          ' ,& '    days2sec 1 1 1  # SPACES ARE IGNORED                                                                                        ' ,& '    111                                                                                                                         ' ,& 'SEE ALSO                                                                                                                        ' ,& '    sec2days(1)                                                                                                                 ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage~2.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME days2sec(1f) - [ TIME ] Convert [[ - ] dd - ][[ hh: ] mm: ] ss to seconds (LICENSE:PD) SYNOPSIS days2sec dd-hh:mm:ss | --version| --help\ndays2sec NNdNNhNNmNNs DESCRIPTION Given a duration in the form dd-hh : mm : ss where dd is days , hh hours , mm minutes and ss seconds convert it to seconds . Many utilities ( ps ( 1 ), for example ) show times in this format to make it more intelligible ; but it generally easier to perform math on values represented in seconds . OPTIONS dd-hh : mm : ss Given a string representing a duration of time in the following forms : dd-hh : mm : ss hh : mm : ss mm : ss ss convert it to seconds . The numeric values may represent floating point numbers . Spaces are ignored . NNdNNhNNmNNs Simple numeric values may also be used with unit suffixes ; where s , m , h , or d represents seconds , minutes , hours or days and w represents weeks . Allowed aliases for w , d , h , m , and s units are w - weeks , week , wk , wks d - days , day m - minutes , minute , min h - hours , hour , hrs , hr s - seconds , second , sec , secs The numeric values may represent floating point numbers . Spaces , commas and case are ignored . --denominator divide the result by this value . Default is one ( 1 ). --help display this help and exit --version output version information and exit EXAMPLE Usage days2sec 1-12:04:20\n 129860\n days2sec 1.5 days\n 129600\n days2sec 1.5 days 4hrs 30minutes\n 145800\n days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED\n 30\n days2sec 1 1 1  # SPACES ARE IGNORED\n 111 SEE ALSO sec2days(1) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        days2sec(1f)>' ,& '@(#)DESCRIPTION:    convert dd-hh:mm:ss string to seconds>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version~2.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       today(1f) - [TIME] output current time for uses such as file suffixes.                                                   ' ,& '       (LICENSE:PD)                                                                                                             ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       today format|--help|--version|--options                                                                                  ' ,& 'DESCRIPTION                                                                                                                     ' ,& '       Outputs the current date using the specified format. Typically used                                                      ' ,& '       to generate a string to be used in building filenames containing                                                         ' ,& '       date information.                                                                                                        ' ,& 'OPTIONS                                                                                                                         ' ,& '       format     any allowable format for the fmtdate(3) routine. Enter                                                        ' ,& '                  \"-\" to get a list on stdout. defaults to \"YMD\".                                                               ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --options  display allowed options for building a format                                                                 ' ,& 'EXAMPLE                                                                                                                         ' ,& '       Sample commands:                                                                                                         ' ,& '                                                                                                                                ' ,& '        cp myfile myfile.`today`                                                                                                ' ,& '        find . -ls > MANIFEST.`today epoch`                                                                                     ' ,& '        mkdir `today YMDhms`                                                                                                    ' ,& '        today yearmonthdayhourminutesecond                                                                                      ' ,& '        today --options                       # show formatting options                                                         ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage~3.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME today ( 1 f ) - [ TIME ] output current time for uses such as file suffixes . ( LICENSE : PD ) SYNOPSIS today format|--help|--version|--options DESCRIPTION Outputs the current date using the specified format. Typically used\n    to generate a string to be used in building filenames containing\n    date information. OPTIONS format any allowable format for the fmtdate ( 3 ) routine . Enter \" - \" to get a list on stdout . defaults to \" YMD \" . -- help display this help and exit -- version output version information and exit -- options display allowed options for building a format EXAMPLE Sample commands : cp myfile myfile . `today` find . - ls > MANIFEST . `today epoch` mkdir `today YMDhms` today yearmonthdayhourminutesecond today -- options # show formatting options AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        today(1f)>' ,& '@(#)DESCRIPTION:    output current time for uses such as file suffixes.>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version~3.html"},{"title":"main – M_time","text":"subroutine main() Uses M_time M_kracken95 Arguments None Contents Variables options Source Code main Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: options Source Code subroutine main () use M_time , only : now , fmtdate_usage use M_kracken95 , only : kracken , lget , sget ! add command-line parser module ! ident_1=\"@(#)today(1f): output current time for uses such as file suffixes.\" character ( len = :), allocatable :: options call kracken ( 'today' , '-help .F. -version .F. -options .F.' ) ! define command arguments,default values and crack command line call help_usage ( lget ( 'today_help' )) ! if -help option is present, display help text and exit call help_version ( lget ( 'today_version' )) ! if -version option is present, display version text and exit if ( lget ( 'today_options' )) then ! special option to list date format documentation call fmtdate_usage () ! see all formatting options else options = sget ( 'today_oo' ) ! get -oo STRING if ( options . eq . '' ) then ! if options are blank set a default write ( * , '(a)' ) now ( 'YMD' ) ! display current date using format from command line else write ( * , '(a)' ) now ( options ) ! display current date using format from command line endif endif end subroutine main","tags":"","loc":"proc/main.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Contents Variables help_text i ident stopit Source Code help_usage Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   month(1f) - [TIME] display a calendar                                                                                        ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   month [[ -year] NNNN] [ -month NN|month_name]                                                                                ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   month(1) displays a simple calendar. If no arguments are specified,                                                          ' ,& '   the current year is displayed.                                                                                               ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   -month      Display single month output. The month is numeric (1-12)                                                         ' ,& '               or a month name or blank. If blank the current month is assumed.                                                 ' ,& '                                                                                                                                ' ,& '   -year NNNN  Select the year to display. A year starts on Jan 1st.                                                            ' ,& '                                                                                                                                ' ,& '   -help       Display help text and exit.                                                                                      ' ,& '   -version    Display version information and exit.                                                                            ' ,& '                                                                                                                                ' ,& 'EXAMPLES                                                                                                                        ' ,& '      month -month 12                                                                                                           ' ,& '                                                                                                                                ' ,& '       >    December 2015                                                                                                       ' ,& '       >Mo Tu We Th Fr Sa Su                                                                                                    ' ,& '       >    1  2  3  4  5  6                                                                                                    ' ,& '       > 7  8  9 10 11 12 13                                                                                                    ' ,& '       >14 15 16 17 18 19 20                                                                                                    ' ,& '       >21 22 23 24 25 26 27                                                                                                    ' ,& '       >28 29 30 31                                                                                                             ' ,& '                                                                                                                                ' ,& '      month -month April # month names may be given instead of numbers                                                          ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","loc":"proc/help_usage~4.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME month ( 1 f ) - [ TIME ] display a calendar ( LICENSE : PD ) SYNOPSIS month [[ -year] NNNN] [ -month NN|month_name] DESCRIPTION month ( 1 ) displays a simple calendar . If no arguments are specified , the current year is displayed . OPTIONS - month Display single month output . The month is numeric ( 1 - 12 ) or a month name or blank . If blank the current month is assumed . - year NNNN Select the year to display . A year starts on Jan 1 st . - help Display help text and exit . - version Display version information and exit . EXAMPLES month -month 12\n\n    >    December 2015\n    >Mo Tu We Th Fr Sa Su\n    >    1  2  3  4  5  6\n    > 7  8  9 10 11 12 13\n    >14 15 16 17 18 19 20\n    >21 22 23 24 25 26 27\n    >28 29 30 31\n\n   month -month April # month names may be given instead of numbers AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Contents Variables help_text i ident stopit Source Code help_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        month(1f)>' ,& '@(#)DESCRIPTION:    displays simple calendar>' ,& '@(#)VERSION:        1.0, 2015-12-20>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","loc":"proc/help_version~4.html"},{"title":"showme – M_time","text":"subroutine showme() Uses M_time Arguments None Contents Source Code showme Source Code subroutine showme () use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine showme","tags":"","loc":"proc/showme.html"},{"title":"showme – M_time","text":"subroutine showme() Uses M_time Arguments None Contents None","tags":"","loc":"proc/showme~2.html"},{"title":"printit – M_time","text":"subroutine printit(iso_year, iso_week, iso_weekday) Arguments Type Intent Optional Attributes Name integer :: iso_year integer :: iso_week integer :: iso_weekday Contents Variables dat Source Code printit Variables Type Visibility Attributes Name Initial integer, public :: dat (8) Source Code subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO-8601 Week: 2016-W29-1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * , '(a,i0)' ) 'GIVEN:           ' write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) end subroutine printit","tags":"","loc":"proc/printit.html"},{"title":"M_time – M_time","text":"Uses M_time_duplicate iso_fortran_env Contents Variables dt_day dt_hour dt_minute dt_week realtime Functions d2j d2o d2u days2sec fmtdate j2d mo2d mo2v moon_fullness now o2d ordinal_seconds phase_of_moon sec2days u2d v2mo Subroutines Easter box_month d2w date_to_julian date_to_unix dow fmtdate_usage guessdate julian_to_date ordinal_to_date system_sleep unix_to_date w2d Variables Type Visibility Attributes Name Initial real(kind=realtime), public, parameter :: dt_day = 86400.0_dp real(kind=realtime), public, parameter :: dt_hour = 3600.0_dp real(kind=realtime), public, parameter :: dt_minute = 60.0_dp real(kind=realtime), public, parameter :: dt_week = dt_day*7.0_dp integer, public, parameter :: realtime = kind(0.0d0) Functions public function d2j (dat) result(julian) Given DAT date-time array returns Julian Date Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: dat (8) Return Value real(kind=realtime) public function d2o (dat) result(ordinal) Given a date in the form of a “DAT” array return the Ordinal Day,\n   (ie. “the day of the year”). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: dat (8) Return Value integer public function d2u (dat) result(unixtime) Converts a DAT date-time array to a Unix Epoch Time value. Typically\n   mathematical operations such as sums, sorting and comparison are\n   performed with simple UET numeric values, and then they are converted\n   back. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: dat (8) Return Value real(kind=realtime) public function days2sec (str) result(time) Given a string representing a duration of the form\n   “[-][[[dd-]hh:]mm:]ss”  or [NNd][NNh][NNm[]NNs][NNw]\n   return a value representing seconds. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value real(kind=realtime) public function fmtdate (values, format) result(timestr) The fmtdate(3f) procedure lets you reformat a DAT array in\n   many common formats using a special string containing macro names\n   beginning with ‘%’. To see the allowable macros call or see the\n   fmtdate_usage(3f) routine. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(8) :: values character(len=*), intent(in), optional :: format Return Value character(len=:),allocatable public function j2d (julian) result(dat) Converts a Julian Ephemeris Date to a DAT date-time array. Read more… Arguments Type Intent Optional Attributes Name real(kind=realtime), intent(in) :: julian Return Value integer(8) public function mo2d (month_name, year) result(dat) Given a Common Calendar month name, return the date as a “DAT” array\n   for the 1st day of the month. An optional year may be specified. The\n   year defaults to the current year. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: month_name integer, intent(in), optional :: year Return Value integer(8) public function mo2v (month_name) result(imonth) Given a string representing the name or abbreviation of a Gregorian\n   Calendar month return a number representing the position of the\n   month in the calendar starting with 1 for January and ending with\n   12 for December. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: month_name Return Value integer public function moon_fullness (datin) function moon_fullness(datin) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: datin (8) Return Value integer public function now (format) The now(3f) function is a call to the fmtdate(3f) function using the\n   current date and time. That is, it is a convenient way to print the\n   current date and time. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: format Return Value character(len=:),allocatable public function o2d (ordinal, year) result(dat) Given an Ordinal day of the year return a date in the form of a\n   “DAT” array. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ordinal integer, optional :: year Return Value integer(8) public function ordinal_seconds () Return number of seconds since beginning of current year. Read more… Arguments None Return Value integer public function phase_of_moon (datin) function phase_of_moon(datin) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: datin (8) Return Value character(len=:),allocatable public function sec2days (seconds, crop) result(dhms) Given a number of seconds convert it to a string of the form Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: seconds logical, intent(in), optional :: crop Return Value character(len=:),allocatable public function u2d (unixtime) result(dat) Given Unix Epoch Time returns DAT date-time array Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: unixtime Return Value integer(8) public function v2mo (imonth) result(month_name) Given a Common Calendar month number, return the name of the month\n   as a string. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: imonth Return Value character(len=:),allocatable Subroutines public subroutine Easter (year, dat) subroutine easter(year,dat) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(out) :: dat (8) public subroutine box_month (dat, calen) box_month(3f) uses a year and month from a date array to populate\n   a small character array with a calendar representing the month. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) character(len=wklen) :: calen (8) public subroutine d2w (dat, iso_year, iso_week, iso_weekday, iso_name) Given a “DAT” array defining a date and time, return the ISO-8601\n   Week in two formats – as three integer values defining the ISO year,\n   week of year and weekday; and as a string of the form “yyyy-Www-d”. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) integer, intent(out) :: iso_year integer, intent(out) :: iso_week integer, intent(out) :: iso_weekday character(len=10), intent(out) :: iso_name public subroutine date_to_julian (dat, julian, ierr) Converts a DAT date-time array to a Unix Epoch Time (UET) value.\n   UET is the number of seconds since 00:00 on January 1st, 1970, UTC. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) AUTHOR:    John S. Urban VERSION:   2.0 2022-01-16 REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 real(kind=realtime), intent(out) :: julian integer, intent(out) :: ierr public subroutine date_to_unix (dat, unixtime, ierr) Converts a DAT date-time array to a UET (Unix Epoch Time). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (8) real(kind=realtime), intent(out) :: unixtime integer, intent(out) :: ierr public subroutine dow (values, weekday, day, ierr) Given a date array DAT\n   return the day of the week as a number and a name, Mon=1. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: values (8) integer, intent(out), optional :: weekday character(len=*), intent(out), optional :: day integer, intent(out), optional :: ierr public subroutine fmtdate_usage (indent) The fmtdate_usage(3f) subroutine displays the formatting options\n   available for use in procedures such as fmtdate(3f) and now(3f).\n   It is typically used to produce up-to-date help text in commands\n   that use the M_time(3fm) module, so that the formatting information\n   only needs maintained in one place (this routine) and is easily\n   displayed so users can quickly obtain a description of the formatting\n   macros. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: indent public subroutine guessdate (datestring, dat, ier) Read in strings and except for looking for month names remove\n   non-numeric characters and try to convert a string assumed to represent\n   a date to a date-time array. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: datestring integer, intent(out) :: dat (8) integer, optional :: ier public subroutine julian_to_date (julian, dat, ierr) Converts a Unix Epoch Time (UET) value to a DAT date-time array.\n   UET is the number of seconds since 00:00 on January 1st, 1970, UTC. Read more… Arguments Type Intent Optional Attributes Name real(kind=realtime), intent(in) :: julian integer, intent(out) :: dat (8) integer, intent(out) :: ierr public subroutine ordinal_to_date (yyyy, ddd, dat) When given a valid year, YYYY, and day of the year, DDD, returns the\n   date as a DAT date array Read more… Arguments Type Intent Optional Attributes Name integer :: yyyy integer :: ddd integer :: dat (8) public subroutine system_sleep (seconds) The system_sleep(3f) routine uses the intrinsic ISO_C_BINDING\n   interface to call the C sleep(3c) procedure or usleep(3c)\n   routine. Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: seconds public subroutine unix_to_date (unixtime, dat, ierr) Converts a Unix Epoch Time (UET) to a DAT date-time array. Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: unixtime integer, intent(out) :: dat (8) integer, intent(out) :: ierr public subroutine w2d (iso_year, iso_week, iso_weekday, dat) Given an ISO-8601 week return a “DAT” array defining a date and time,\n   The ISO-8601 is supplied as three integer values defining the ISO\n   year, week of year and weekday. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: iso_year integer, intent(in) :: iso_week integer, intent(in) :: iso_weekday integer, intent(out) :: dat (8)","tags":"","loc":"module/m_time.html"},{"title":"M_time_oop – M_time","text":"NAME M_time_oop ( 3 fm ) - [ M_time :: INTRO :: OOPS ] OOP interface for M_time ( 3 fm ) ( LICENSE : PD ) SYNOPSIS use M_time_oop, only : date_time use M_time_oop , only : operator ( + ), operator ( - ), operator ( > ), operator ( < ) use M_time_oop , only : operator ( <= ), operator ( >= ), operator ( == ), operator ( /= ) TYPE ( date_time ) :: mydate mydate % year mydate % month mydate % day mydate % tz mydate % hour mydate % minute mydate % second mydate % millisecond call mydate %init () mydate % format ( '' ) mydate % ordinal () mydate % weekday () mydate % epoch () mydate % julian () dat = mydate % datout () mydate % delta ( year = NN , month = NN , day = NN , tz = NN , hour = NN , minute = NN , second = NN , millisecond = NN , week = NN , duration = ' DD - HH : MM : SS . XX ' ) DESCRIPTION An object-oriented interface to the M_time module. The following\nexample program demonstrates and documents the interface EXAMPLE sample program program demo_M_time_oop ! ! This is an example using the object - oriented class / type model ! This is essentially the same functionality as the procedures ! in the procedural module M_time ( 3f m ), but allows for Object ! Oriented syntax : ! use M_time_oop , only : date_time !! use M_time_oop , only : operator ( + ), operator ( - ), operator ( > ), operator ( < ) !! use M_time_oop , only : operator ( <= ), operator ( >= ), operator ( == ), operator ( /= ) implicit none integer , parameter :: dp = kind ( 0.0 d0 ) integer :: dat ( 8 ) TYPE ( date_time ) :: event TYPE ( date_time ) :: otherdate TYPE ( date_time ) :: answer character ( len =* ), parameter :: iso_fmt = ' % Y -% M -% DT % h :% m :% s . % x % z ' ! DIFFERENT INITIALIZATION STYLES ! ( Still debating on how best to do this ) write ( * , * ) write ( * , ' ( a ) ')' Various initialization styles ' ! DEFINE type ( date_time ) WITH CONSTRUCTOR otherdate = date_time () print * , ' DEFAULT CONSTRUCTOR % format () ' , & & otherdate % format () print * , ' DEFAULT CONSTRUCTOR % format ( \"\" ) ' , & & otherdate % format ( \"\" ) print * , ' DEFAULT CONSTRUCTOR % format ( user - specified ) ' , & & otherdate % format ( iso_fmt ) print * , ' DEFAULT CONSTRUCTOR % format ( \"USA\" ) ' , & & otherdate % format ( \"USA\" ) otherdate = date_time ( 1492 , 10 , 12 , 0 , 0 , 0 , 0 , 0 ) print * , ' DEFAULT CONSTRUCTOR setting values ' , & & otherdate % format () otherdate = date_time ( 2016 , 6 , 11 ) print * , ' DEFAULT CONSTRUCTOR with partial values ' , & & otherdate % format () otherdate = date_time ( year = 2016 , month = 6 , day = 11 , tz = -240 , & & hour = 21 , minute = 09 , second = 11 , millisecond = 500 ) print * , ' DEFAULT CONSTRUCTOR with values by name ' , & & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 , 0 , 0 , 0 , 0 , 0 ]) print * , ' CONSTRUCTOR with a dat array ' , & & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 ]) print * , ' CONSTRUCTOR with a partial dat array ' , & & otherdate % format () ! the init () method supports several methods ! initialize to current time using INIT call otherdate %init () ! initialize to current time using INIT call otherdate %init ( type = \"now\" ) ! initialize to beginning of Unix Epoch Time call otherdate %init ( type = \"epoch\" ) ! Note ! currently , DATE_TIME DATE array is set to Unix Epoch ! start USING LOCAL TIMEZONE ! whereas default constructor is using default of Unix Epoch ! start using Z time ( GMT or UTC time ) ! initialize with a DAT array using INIT , ! compatible with DATE_AND_TIME VALUES ( 8 ) call otherdate %init ( dat = [1970,1,1,0,0,0,0,0] ) ! using INIT with ordered values call otherdate %init ( 2016 , 6 , 11 , -300 , 23 , 1 , 0 , 0 ) ! using INIT with names call otherdate %init ( year = 2016,month=6,day=11,&\n    & tz=-300,hour=23,minute=1,second=0,millisecond=0 ) ! ! take current date and exercise the OOP interface ! initialize to current time using INIT call event %init () write ( * , * ) write ( * , * ) ' Print members of type ( DATE_TIME ) ' ! show derived type write ( * , 404 ) ' EVENT = ' , event 404 format ( 1 x , a , i0 , * ( \",\" , i0 : )) ! MEMBERS ( basic time values are all integers ) ! print members of type write ( * , 101 ) ' % year Year ................... ' , event % year write ( * , 101 ) ' % month Month .................. ' , event % month write ( * , 101 ) ' % day Day .................... ' , event % day write ( * , 101 ) ' % tz Timezone ............... ' , event % tz write ( * , 101 ) ' % hour Hour ................... ' , event % hour write ( * , 101 ) ' % minute Minute ................. ' , event % minute write ( * , 101 ) ' % second Second ................. ' , event % second write ( * , 101 ) ' % millisecond Millisecond ............ ' , event % millisecond ! PRINT METHODS OF TYPE write ( * , * ) ' Print methods of type ( DATE_TIME ) ' write ( * , 101 ) ' % ordinal Ordinal day of year .... ' , event % ordinal () write ( * , 101 ) ' % weekday Weekday ................ ' , event % weekday () 101 format ( 1 x , a , i0 ) ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY write ( * , 202 ) ' % epoch Unix epoch time ........ ' , event % epoch () write ( * , 202 ) ' % julian Julian date ............ ' , event % julian () 202 format ( 1 x , a , g0 ) ! FORMATTED STRINGS ( many strings possible . ! Takes the same format string as fmtdate ( 3f )) write ( * , * ) write ( * , ' ( a ) ')' Formatted Strings ( % format ( \"STRING\" ) & & -- see fmtdate ( 3f ) for format descriptions ' ! abbreviated month name % l Dec write ( * , 303 ) ' Short month ............ ' , & & event % format ( \"%l\" ) ! ! full month name % L December write ( * , 303 ) ' Month .................. ' , & & event % format ( \"%L\" ) ! ! first three characters of weekday % w Sat write ( * , 303 ) ' Short week ............. ' , & & event % format ( \"%w\" ) ! ! weekday name % W Saturday write ( * , 303 ) ' Week .................. ' , & & event % format ( \"%W\" ) ! ! with no percent ( % ) characters write ( * , 303 ) ' Calendar Time ......... ' , & & event % format ( \"Y-M-D h:m:s.x z\" ) ! ! keywords with no percent ( % ) characters write ( * , 303 ) ' Calendar Time ......... ' , & & event % format ( ' \"year-month-day & & hour : minute : second . millisecond timezone \"') ! write ( * , * ) event % format ( ' Longer format .......... & & \"%W, %L %d, %Y %H:%m:%s %N\" ' ) ! a nice friendly format ! 303 format ( 1 x , a , '\"' , a , '\"' ) ! convert date_time to integer array ! ( maybe to use with module M_TIME base procedures ) dat = event % datout () write ( * , * ) write ( * , 404 ) ' DAT = ' , dat ! OVERLOADED OPERATORS ( add and subtract ) ! a date_time object can have seconds added answer = event + 1 * 86400.0 _dp ! ! a nice friendly format write ( * , * ) answer % format ( ' TOMORROW = \"%W, %L %d, %Y %H:%m:%s %N\" ' ) ! ! a date_time object can have seconds subtracted answer = event -1 * 86400.0 _dp ! a nice friendly format write ( * , * ) answer % format ( ' YESTERDAY = \"%W, %L %d, %Y %H:%m:%s %N\" ' ) ! ! if both operands are DATE_TIME objects a subtraction ! finds the time in seconds between the two dates write ( * , * ) ' DIFFERENCE ( subtracting one date_time from another ) = ' , & & answer - event ! OVERLOADED OPERATORS ( logical comparisons ) ! NOTE COMPARISONS ARE PERFORMED BY ! CONVERTING TIMES TO INTEGER SECONDS write ( * , * ) ' > ' , event . eq . event , event . lt . event , event . gt . event & & , event . le . event , event . ge . event , event . ne . event ! write ( * , * ) ' > ' , event . eq . answer , event . lt . answer , event . gt . answer & & , event . le . answer , event . ge . answer , event . ne . answer ! write ( * , * ) ' > ' , answer . eq . event , answer . lt . event , answer . gt . event & & , answer . le . event , answer . ge . event , answer . ne . event ! % DELTA easily lets you change dates by common increments write ( * , * ) write ( * , 404 ) ' % DELTA tests starting with date ' , event % delta () ! write ( * , * ) event % format ( \"                             & &% W , % L % d , % Y % H :% m :% s % N \") write ( * , * ) ' Remember years and months are not constant units ' answer = event % delta ( year = 1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = -1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( month = 24 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( month = -24 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( week = 1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( week = -1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( day = 1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( day = -1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = 4 ) write ( * , * ) answer % format ( & ! & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = -4 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( minute = 180 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( minute = -180 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( second = 1800 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( second = -1800 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( millisecond = 10000 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( millisecond = -10000 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = 3 , month = 2 , day = 100 , hour = 200 , & & week = -1 , minute = 300 , second = 1000 , millisecond = -10000 ) write ( * , * ) answer % format ( & ! & \"FOR %%DELTA(year=3,month=2,day=100,hour=200,& & week = -1 , minute = 300 , second = 1000 , millisecond = 100000 ) & & % W , % L % d , % Y % H :% m :% s % N \") answer = event % delta ( duration = \"1-20:30:40.50\" ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(DURATION='1-20:30:40.50')& & % W , % L % d , % Y % H :% m :% s % N \") end program demo_M_time_oop Sample output: Various initialization styes\n   DEFAULT CONSTRUCTOR %format()               1970-01-01T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR %format(“”)             1970-01-01T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR %format(user-specified) 1970-01-01T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR %format(“USA”)   Thursday, January 1st, 1970 12:00:00 AM\n   DEFAULT CONSTRUCTOR setting values          1492-10-12T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR with partial values     2016-06-11T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR with values by name     2016-06-11T21:09:11.500-04:00\n   CONSTRUCTOR with a dat array                1776-07-04T00:00:00.000+00:00\n   CONSTRUCTOR with a partial dat array        1776-07-04T20:00:00.000-04:00 Print members of type(DATE_TIME)\n   EVENT=2020,10,24,-240,21,49,54,105\n   %year        Year................... 2020\n   %month       Month.................. 10\n   %day         Day.................... 24\n   %tz          Timezone............... -240\n   %hour        Hour................... 21\n   %minute      Minute................. 49\n   %second      Second................. 54\n   %millisecond Millisecond............ 105\n   Print methods of type(DATE_TIME)\n   %ordinal     Ordinal day of year.... 298\n   %weekday     Weekday................ 6\n   %epoch      Unix epoch time........ 1603590594.1049695\n   %julian     Julian date............ 2459147.5763206594 Formatted Strings (%format(“STRING”)\n   – see fmtdate(3f) for format descriptions\n   Short month............ “Oct”\n   Month.................. “October”\n   Short week............. “Sat”\n   Week .................. “Saturday”\n   Calendar Time ......... “2020-10-24 21:49:54.105 -04:00”\n   Calendar Time ......... “”2020-10-24 21:49:54.105 -0400””\n   Longer format.......... “Saturday, October 24th, 2020 9:49:54 PM” DAT=2020,10,24,-240,21,49,54,105\n   TOMORROW=”Sunday, October 25th, 2020 9:49:54 PM”\n   YESTERDAY=”Friday, October 23rd, 2020 9:49:54 PM”\n   DIFFERENCE (subtracting one date_time from another)=  -86400.000000000000 T F F T T F\n F F T F T T\n F T F T F T %DELTA tests starting with date 2020,10,24,-240,21,49,54,105\n                                Saturday, October 24th, 2020 9:49:54 PM\n   Remember years and months are not constant units\n   FOR %DELTA(YEAR=+1)            Sunday, October 24th, 2021 9:49:54 PM\n   FOR %DELTA(YEAR=-1)            Thursday, October 24th, 2019 9:49:54 PM\n   FOR %DELTA(MONTH=+24)          Wednesday, October 26th, 2022 9:49:54 PM\n   FOR %DELTA(MONTH=-24)          Wednesday, October 24th, 2018 9:49:54 PM\n   FOR %DELTA(WEEK=+1)            Saturday, October 31st, 2020 9:49:54 PM\n   FOR %DELTA(WEEK=-1)            Saturday, October 17th, 2020 9:49:54 PM\n   FOR %DELTA(DAY=+1)             Sunday, October 25th, 2020 9:49:54 PM\n   FOR %DELTA(DAY=-1)             Friday, October 23rd, 2020 9:49:54 PM\n   FOR %DELTA(HOUR=+4)            Sunday, October 25th, 2020 1:49:54 AM\n   FOR %DELTA(HOUR=-4)            Saturday, October 24th, 2020 5:49:54 PM\n   FOR %DELTA(MINUTE=+180)        Sunday, October 25th, 2020 12:49:54 AM\n   FOR %DELTA(MINUTE=-180)        Saturday, October 24th, 2020 6:49:54 PM\n   FOR %DELTA(SECOND=+1800)       Saturday, October 24th, 2020 10:19:54 PM\n   FOR %DELTA(SECOND=-1800)       Saturday, October 24th, 2020 9:19:54 PM\n   FOR %DELTA(MILLISECOND=+10000) Saturday, October 24th, 2020 9:50:04 PM\n   FOR %DELTA(MILLISECOND=-10000) Saturday, October 24th, 2020 9:49:44 PM\n   FOR %DELTA(year=3,month=2,day=100,hour=200,week=-1,minute=300,\n   second=1000,millisecond=100000) Thursday, April 4th, 2024 11:06:24 AM\n   FOR %DELTA(DURATION=‘1-20:30:40.50’) Monday, October 26th, 2020 6:20:34 PM\nsubmodule (M_time) M_time_oop\nend submodule M_time_oop Uses M_time_duplicate M_time Contents Variables dp Interfaces date_time Derived Types date_time Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(0.0d0) Interfaces public interface date_time private function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (:) Return Value type( date_time ) Derived Types type, public :: date_time Constructor private  function construct_from_dat (dat) Type-Bound Procedures procedure, public :: datout => dt2d_ procedure, public :: delta procedure, public :: epoch => epoch_ procedure, public :: format procedure, public :: init => init_dt procedure, public :: julian => julian_ generic, public :: operator(+) => plus_seconds generic, public :: operator(-) => minus_seconds generic, public :: operator(-) => minus_date_time generic, public :: operator(/=) => ne generic, public :: operator(<) => lt generic, public :: operator(<=) => le generic, public :: operator(==) => eq generic, public :: operator(>) => gt generic, public :: operator(>=) => ge procedure, public :: ordinal procedure, public :: weekday","tags":"","loc":"module/m_time_oop.html"},{"title":"M_time_duplicate – M_time","text":"Contents Interfaces string_to_value v2s Functions adjustc compact d2s decodebase i2s l2s lower r2s s2v transliterate upper Subroutines a2d a2i a2r split stderr string_to_values substitute trimzeros value_to_string Interfaces public interface string_to_value public subroutine a2d (chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns doubleprecision value from string doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr public subroutine a2r (chars, valu, ierr) returns a numeric value from a numeric character string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns real value from string real, intent(out) :: valu integer, intent(out) :: ierr public subroutine a2i (chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns integer value from string integer, intent(out) :: valu integer, intent(out) :: ierr public interface v2s public function d2s (dvalue, fmt) result(outstr) v2s(3f) returns a representation of a numeric value as a\n   string when given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the strings using internal WRITE()\n   statements. Trailing zeros are removed from non-zero values, and the\n   string is left-justified. Read more… Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function r2s (rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function i2s (ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function l2s (lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable Functions public pure function adjustc (string, length) pure function adjustc(string[,length]) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string PROCEDURE   adjustc(3f)\n DESCRIPTION center text using implicit or explicit length VERSION     2.0, 20160711 AUTHOR      John S. Urban integer, intent(in), optional :: length Return Value character(len=:),allocatable public function compact (str, char) result(outstr) COMPACT(3f) converts multiple spaces, tabs and control characters\n   (called “whitespace”) to a single character or nothing. Leading\n   whitespace is removed. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: char Return Value character(len=len) public function d2s (dvalue, fmt) result(outstr) v2s(3f) returns a representation of a numeric value as a\n   string when given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the strings using internal WRITE()\n   statements. Trailing zeros are removed from non-zero values, and the\n   string is left-justified. Read more… Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function decodebase (string, basein, out_baseten) decodebase(3f) - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number\n   (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: basein integer, intent(out) :: out_baseten Return Value logical public function i2s (ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function l2s (lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public pure elemental function lower (str, begin, end) result(string) lower(string) returns a copy of the input string with all characters\n   converted to miniscule over the specified range, assuming ASCII\n   character sets are being used. If no range is specified the entire\n   string is converted to miniscule. Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character public function r2s (rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:),allocatable public function s2v (chars, ierr, onerr) This function converts a string to a DOUBLEPRECISION numeric value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, optional :: ierr class(*), intent(in), optional :: onerr Return Value doubleprecision public pure function transliterate (instr, old_set, new_set) result(outstr) Translate, squeeze, and/or delete characters from the input string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value character(len=LEN) public pure elemental function upper (str, begin, end) result(string) upper(3f) - [M_strings:CASE] changes a string to uppercase\n (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character, intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character Subroutines public subroutine a2d (chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns doubleprecision value from string doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr public subroutine a2i (chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns integer value from string integer, intent(out) :: valu integer, intent(out) :: ierr public subroutine a2r (chars, valu, ierr) returns a numeric value from a numeric character string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns real value from string real, intent(out) :: valu integer, intent(out) :: ierr public subroutine split (input_line, array, delimiters, order, nulls) SPLIT(3f) parses a string using specified delimiter characters and\n   store tokens into an allocatable array Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls public subroutine stderr (string) Arguments Type Intent Optional Attributes Name character(len=*) :: string public subroutine string_to_values (line, iread, values, inums, delims, ierr) This routine can take a string representing a series of numbers and\n   convert it to a numeric array and return how many numbers were found. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: iread real, intent(inout) :: values (iread) integer, intent(out) :: inums character(len=*), intent(in) :: delims integer, intent(out) :: ierr public subroutine substitute (targetline, old, new, ierr, start, end) Globally substitute one substring for another in string. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: targetline character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(out), optional :: ierr integer, intent(in), optional :: start integer, intent(in), optional :: end public subroutine trimzeros (string) TRIMZEROS(3f) deletes trailing zeros from a string representing a\n   number. If the resulting string would end in a decimal point, one\n   trailing zero is added. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: string public subroutine value_to_string (gval, chars, length, err, fmt, trimz) value_to_string(3f) returns a numeric representation of a numeric\n   value in a string given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the string using internal writes. It\n   then removes trailing zeros from non-zero values, and left-justifies\n   the string. Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: gval character(len=*), intent(out) :: chars integer, intent(out), optional :: length integer, optional :: err character(len=*), intent(in), optional :: fmt logical, intent(in), optional :: trimz","tags":"","loc":"module/m_time_duplicate.html"},{"title":"demo_sec2days – M_time","text":"Uses M_time M_kracken95 M_strings Contents Variables ident line radix strlocal Subroutines help_usage help_version Source Code demo_sec2days Variables Type Attributes Name Initial character(len=*), parameter :: ident = \"@(#)sec2days(1f): convert seconds to string of form dd-hh:mm:ss\" character(len=IPvalue) :: line character(len=:), allocatable :: radix character(len=:), allocatable :: strlocal Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) usage Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program demo_sec2days use M_kracken95 , only : kracken , lget , sget , IPvalue use M_time , only : sec2days use M_strings , only : substitute implicit none character ( len =* ), parameter :: ident = \"@(#)sec2days(1f): convert seconds to string of form dd-hh:mm:ss\" character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: radix character ( len = IPvalue ) :: line call kracken ( 'sec2days' , ' -oo -crop .F -radix . -help .F. -version .F.' ) ! parse command line call help_usage ( lget ( 'sec2days_help' )) ! display help information and stop if true call help_version ( lget ( 'sec2days_version' )) ! display version information and stop if true radix = trim ( sget ( 'sec2days_radix' )) line = sget ( 'sec2days_oo' ) if ( radix . ne . '.' ) then call substitute ( line , '.' , ' ' ) call substitute ( line , radix , '.' ) endif strlocal = sec2days ( trim ( line ), lget ( 'sec2days_crop' )) ! get command line option and convert to dd-hh:mm:ss string write ( * , '(a)' ) strlocal contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   sec2days(1f) - [TIME] Convert seconds to string of form dd-hh:mm:ss                                                          ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   sec2days nnnn[.xxx] [ -crop]| --version| --help                                                                              ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Given a numeric string representing seconds convert it to a string                                                           ' ,& '   of the form                                                                                                                  ' ,& '                                                                                                                                ' ,& '      dd-hh:mm:ss                                                                                                               ' ,& '                                                                                                                                ' ,& '   where dd is days, hh hours, mm minutes and ss seconds.                                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   nnnn[.xxx]  number of seconds to convert to string of form dd-hh:mm:ss.                                                      ' ,& '               nnnn may be interspersed with unit codes d,h,m,s. Spaces,                                                        ' ,& '               commas and case are ignored. Allowed aliases for the unit                                                        ' ,& '               codes are                                                                                                        ' ,& '                 d  days and day                                                                                                ' ,& '                 h  hours,hour,hrs, and hr                                                                                      ' ,& '                 m  minutes,minute and min                                                                                      ' ,& '                 s  seconds,second and sec                                                                                      ' ,& '                                                                                                                                ' ,& '   -crop       trim leading zero values from output                                                                             ' ,& '   -radix      character used as decimal separator                                                                              ' ,& '   --help      display this help and exit                                                                                       ' ,& '   --version   output version information and exit                                                                              ' ,& '                                                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& ' usage                                                                                                                          ' ,& '                                                                                                                                ' ,& '   sec2days 129860                                                                                                              ' ,& '   1-12:04:20                                                                                                                   ' ,& '   sec2days 1d2h3m4s                                                                                                            ' ,& '   1-02:03:04                                                                                                                   ' ,& '   sec2days 1.0 days 2 hours 3 minutes 4 seconds                                                                                ' ,& '   1-02:03:04                                                                                                                   ' ,& '   sec2days 1.5d                                                                                                                ' ,& '   1-12:00:00                                                                                                                   ' ,& '                                                                                                                                ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    sec2days(1f) - [TIME] Convert seconds to string of form dd-hh:mm:ss !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    sec2days nnnn[.xxx] [ -crop]| --version| --help !! !!##DESCRIPTION !!    Given a numeric string representing seconds convert it to a string !!    of the form !! !!       dd-hh:mm:ss !! !!    where dd is days, hh hours, mm minutes and ss seconds. !! !!##OPTIONS !!    nnnn[.xxx]  number of seconds to convert to string of form dd-hh:mm:ss. !!                nnnn may be interspersed with unit codes d,h,m,s. Spaces, !!                commas and case are ignored. Allowed aliases for the unit !!                codes are !!                  d  days and day !!                  h  hours,hour,hrs, and hr !!                  m  minutes,minute and min !!                  s  seconds,second and sec !! !!    -crop       trim leading zero values from output !!    -radix      character used as decimal separator !!    --help      display this help and exit !!    --version   output version information and exit !! !!##EXAMPLE !! !!  usage !! !!    sec2days 129860 !!    1-12:04:20 !!    sec2days 1d2h3m4s !!    1-02:03:04 !!    sec2days 1.0 days 2 hours 3 minutes 4 seconds !!    1-02:03:04 !!    sec2days 1.5d !!    1-12:00:00 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        sec2days(1f)>' ,& '@(#)DESCRIPTION:    convert seconds to string of form dd-hh:mm:ss>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_sec2days","tags":"","loc":"program/demo_sec2days.html"},{"title":"display_date – M_time","text":"Uses M_time M_kracken95 m_strings Contents Variables dat duration ident ierr inums output rdat Subroutines help_version usage Source Code display_date Variables Type Attributes Name Initial integer :: dat (8) = 0 real(kind=realtime) :: duration = 0 character(len=*), parameter :: ident = \"@(#)now(1f): writes timestamp using specified syntax\" integer :: ierr integer :: inums character(len=:), allocatable :: output real :: rdat (8) = 0 Subroutines subroutine help_version (l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version subroutine usage () Arguments None Source Code program display_date use M_kracken95 , only : kracken , lget , retrev , sget , dget ! command line parameter cracking module use M_time , only : now , fmtdate_usage , fmtdate , days2sec , d2u , u2d , realtime , guessdate , j2d use m_strings , only : string_to_values , isdigit , isspace , switch implicit none character ( len =* ), parameter :: ident = \"@(#)now(1f): writes timestamp using specified syntax\" integer :: dat ( 8 ) = 0 real :: rdat ( 8 ) = 0 real ( kind = realtime ) :: duration = 0 character ( len = :), allocatable :: output !character(len=1),allocatable   :: chars(:) integer :: ierr , inums !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - call kracken ( 'now' , ' -help .F. -version .F. -dat -date -jed -uet -test .false. -delta' ) ! crack command line call help_version ( lget ( 'now_version' )) ! display version number if --version is present !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_help' )) then ! display help text and exit if --help is present call usage () stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_test' )) then ! try each format type call fmtdate_usage ( 3 ) stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( sget ( 'now_uet' ). ne . ' ' ) then dat = u2d ( dget ( 'now_uet' )) ! convert command option to UET number, convert to dat elseif ( sget ( 'now_jed' ). ne . ' ' ) then dat = j2d ( dget ( 'now_jed' )) ! convert command option to JED number, convert to dat elseif ( sget ( 'now_dat' ). ne . ' ' ) then dat = u2d () ! initialize DAT with current date and time to get time zone dat = [ dat ( 1 ), 1 , 1 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! default is Jan 1st in current year and timezone 00:00:00 call string_to_values ( sget ( 'now_dat' ), size ( dat ), rdat , inums , ' ,:/' , ierr ) ! convert string to array and overlay default values dat ( 1 : inums ) = nint ( rdat ( 1 : inums )) ! if -date is all integer digits and whitespace and +- and only one - (for UTC value) then use it directly to load a DAT !chars=switch(trim(sget('now_dat'))) !if( all(isdigit(chars).or.isspace(chars).or.chars.eq.'-'.or.chars.eq.'+' ) .and. count(chars.eq.'-').le.1 )then !else !   write(*,*)'*now* error: invalid characters in -dat input '//trim(sget('now_dat')) !endif elseif ( sget ( 'now_date' ). ne . ' ' ) then ! convert command option to date string and try to guess date call guessdate ( sget ( 'now_date' ), dat ) else ! create DAT for current time dat = u2d () ! current time endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - duration = days2sec ( sget ( 'now_delta' )) ! convert string to duration in seconds dat = u2d ( d2u ( dat ) + duration ) ! convert DAT to UET, add duration, place back in DAT !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - output = fmtdate ( dat , sget ( 'now_oo' )) ! create output string by applying format !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - write ( * , '(a)' ) trim ( output ) ! write output !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - contains !----------------------------------------------------------------------------------------------------------------------------------- subroutine usage () ! character ( len =* ), parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character ( len = 80 ), allocatable :: text (:) integer :: i ! NOTE: Without the type specification this constructor would have to specify all of the constants with the same character length. text = [ character ( len = len ( text ( 1 ))) :: & & 'NAME                                                                            ' ,& & '   now(1f)  - [TIME] print the date and time                                    ' ,& & '   (LICENSE:PD)                                                                 ' ,& & '                                                                                ' ,& & 'SYNOPSIS                                                                        ' ,& & '  now [Format [ -date date_str|-ued Unix_time|-jed Julian_Date|-dat date_vector]' ,& & '      [ -delta dd-hh:mm:ss]]|--help |--version|-test]                           ' ,& & '                                                                                ' ,& & 'DESCRIPTION                                                                     ' ,& & '   Report the current time or a Fortran date vector in a variety of formats.    ' ,& & '   Julian dates, Unix Epoch time, weekdays, monthnames, ordinal days,           ' ,& & '   AM/PM and iso-8601 week-numbering are supported by building a format         ' ,& & '   string containing the desired macros.                                        ' ,& & 'OPTIONS                                                                         ' ,& & '   Format  :                                                                    ' ,& & '     This string, containing macro names or keywords, creates the format used   ' ,& & '     to print the specified date.                                               ' ,& & '                                                                                ' ,& & '     The FORMAT string is expanded using the following macros:                  ' ,& & '                                                                                ' ,& & 'CALL FMTDATE_USAGE                                                              ' ,& & '                                                                                ' ,& & '   -dat date_vector  :                                                          ' ,& & '      A date vector is eight integers representing a date in the same manner as ' ,& & '      the Fortran DATE_AND_TIME(3f) function:                                   ' ,& & '          yyyy mm dd zone hh mm ss mss                                          ' ,& & '      only numeric time zones are supported.                                    ' ,& & '                                                                                ' ,& & '      When present, the specified date is used instead of the current time.     ' ,& & '                                                                                ' ,& & '   -uet Unix_Epoch_Time  :                                                      ' ,& & '      When present a value is used as the Unix Epoch Time. This date is         ' ,& & '      is then adjusted using any -delta value and then printed using            ' ,& & '      the specified format.                                                     ' ,& & '                                                                                ' ,& & '   -jed Julian_Date  :                                                          ' ,& & '      When present a value is used as the Julian Ephemeris Date.                ' ,& & '                                                                                ' ,& & '   -delta dd-hh:mm:ss  :                                                        ' ,& & '      Add the specified duration to the date.                                   ' ,& & '                                                                                ' ,& & '   -date date_str  :                                                            ' ,& & '      The guessdate(3f) routine is used to try to convert a date description    ' ,& & '      to a date vector. For the guess to work, dates must either be in the      ' ,& & '      form YYYY-MM-DD or the order of numeric values must be \"\"dd yy yyy\".      ' ,& & '      Only four-digit years are supported. Month names are preferred over       ' ,& & '      numeric values. See the guessdate(3f) documentation for further details.  ' ,& & '                                                                                ' ,& & '   -test :                                                                      ' ,& & '      To list allowed macros use the -test switch.                              ' ,& & '                                                                                ' ,& & '   When present, the specified date is used instead of the current time.        ' ,& & 'EXAMPLES                                                                        ' ,& & ' Sample commands:                                                               ' ,& & '                                                                                ' ,& & '  now                                                                           ' ,& & '    Friday, June 17th, 2016 03:22:53 PM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta  1-0:0:0  # Tomorrow                                               ' ,& & '    Sunday, June 19th, 2016 11:32:26 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta -1-0:0:0  # Yesterday                                              ' ,& & '    Friday, June 17th, 2016 11:32:43 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now long -delta  7-0:0:0  # Next week                                         ' ,& & '    Saturday, June 25th, 2016 11:32:57 AM UTC-04:00                             ' ,& & '                                                                                ' ,& & '  now The date is %Y/%M/%D %h:%m:%s  # user-specified formats using macros      ' ,& & '    The date is 2009/08/10 00:33:48                                             ' ,& & '                                                                                ' ,& & '  now Y/M/D h:m:s # user-specified format with no % character                   ' ,& & '    2009/08/10 00:33:48                                                         ' ,& & '                                                                                ' ,& & '  now year-month-day # user-specified format with no % with long keywords       ' ,& & '  2016-07-29                                                                    ' ,& & '                                                                                ' ,& & '  now -dat 2016 07 23 -240 1 01 00 00  # alternate date                         ' ,& & '  Saturday, July 23rd, 2016 1:01:00 AM UTC-4:00                                 ' ,& & '                                                                                ' ,& & '  now -uet  1469250060                 # alternate Unix Epoch date              ' ,& & '  now -date January 4th, 1999 10:20:30 # try to determine date from description.' ,& & '                                                                                ' ,& & '  now YEAR=%Y MONTH=%M DAY=%D          # YEAR=2009 MONTH=08 DAY=10              ' ,& & '                                                                                ' ,& & '  now HOUR=%h MINUTES=%m SECONDS=%s MILLISECONDS=%x                             ' ,& & '      HOUR=01 MINUTES=18 SECONDS=44 MILLISECONDS=946                            ' ,& & '                                                                                ' ,& & '  # double-quotes are tricky (double them) to put in literally in this program: ' ,& & '  now ''\"\"year-month-day\"\",\"\"hour-minute-second\"\"'' #  \"2017-04-23\",\"14-41-09\"  ' ,& & '                                                                                ' ,& & '  # quotes are easier to control using the single-letter macros(use %q and %Q): ' ,& & '  now QY-M-DQ,Qh:m:sQ                                                           ' ,& & '     \"2017-04-23\",\"14-41-09\"                                                    ' ,& & '                                                                                ' ,& & '  now -test       # Show formatting options, handy way to look up macro names   ' ,& & '                                                                                ' ,& & 'LIMITS                                                                          ' ,& & '  See the M_time module description. Basically, A Gregorian Calendar is         ' ,& & '  assumed, and Leap Seconds are not specifically accounted for.                 ' ,& & 'SEE ALSO                                                                        ' ,& & '   month(1), sec2days(1), days2sec(1), easter(1), paws(1), today(1), ttee(1)    ' ,& & 'AUTHOR                                                                          ' ,& & '   John S. Urban                                                                ' ,& & 'LICENSE                                                                         ' ,& & '   Public Domain                                                                ' ,& & '                                                                                ' ] do i = 1 , size ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 6 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo stop end subroutine usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        now(1f)>' ,& '@(#)DESCRIPTION:    Report a date in a variety of formats>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program display_date","tags":"","loc":"program/display_date.html"},{"title":"demo_days2sec – M_time","text":"Uses M_time M_kracken95 M_strings Contents Variables ident printline Subroutines help_usage help_version Source Code demo_days2sec Variables Type Attributes Name Initial character(len=*), parameter :: ident = \"@(#)days2sec(1): given string of form dd-hh:mm:ss convert to seconds\" character(len=:), allocatable :: printline Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Usage Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program demo_days2sec use M_kracken95 , only : kracken , sget , lget , rget use M_time , only : days2sec use M_strings , only : v2s implicit none character ( len =* ), parameter :: ident = \"@(#)days2sec(1): given string of form dd-hh:mm:ss convert to seconds\" character ( len = :), allocatable :: printline call kracken ( 'days2sec' , ' -oo -help .F. -version .F. -denominator 1' ) ! parse command line call help_usage ( lget ( 'days2sec_help' )) ! display help information and stop if true call help_version ( lget ( 'days2sec_version' )) ! display version information and stop if true ! get value from command line with SGET, convert to seconds with DAYS2SEC, and make into a nicer value string with V2S printline = v2s ( days2sec ( sget ( 'days2sec_oo' )) / rget ( 'days2sec_denominator' )) ! not in write statement so error message will print write ( * , '(a)' ) printline contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds                                                                ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   days2sec dd-hh:mm:ss | --version| --help                                                                                     ' ,& '   days2sec NNdNNhNNmNNs                                                                                                        ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss where dd is days, hh hours,                                                         ' ,& '   mm minutes and ss seconds convert it to seconds. Many utilities (ps(1),                                                      ' ,& '   for example) show times in this format to make it more intelligible;                                                         ' ,& '   but it generally easier to perform math on values represented in                                                             ' ,& '   seconds.                                                                                                                     ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   dd-hh:mm:ss  Given a string representing a duration of time in the                                                           ' ,& '                following forms:                                                                                                ' ,& '                                                                                                                                ' ,& '                  dd-hh:mm:ss                                                                                                   ' ,& '                     hh:mm:ss                                                                                                   ' ,& '                        mm:ss                                                                                                   ' ,& '                           ss                                                                                                   ' ,& '                                                                                                                                ' ,& '                convert it to seconds.                                                                                          ' ,& '                                                                                                                                ' ,& '                The numeric values may represent floating point numbers.                                                        ' ,& '                                                                                                                                ' ,& '                Spaces are ignored.                                                                                             ' ,& '                                                                                                                                ' ,& '    NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes;                                                    ' ,& '                  where s,m,h, or d represents seconds, minutes, hours                                                          ' ,& '                  or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are                                  ' ,& '                                                                                                                                ' ,& '                   w -  weeks,week,wk,wks                                                                                       ' ,& '                   d -  days,day                                                                                                ' ,& '                   m -  minutes,minute,min                                                                                      ' ,& '                   h -  hours,hour,hrs,hr                                                                                       ' ,& '                   s -  seconds,second,sec,secs                                                                                 ' ,& '                                                                                                                                ' ,& '                  The numeric values may represent floating point numbers.                                                      ' ,& '                                                                                                                                ' ,& '                  Spaces, commas  and case are ignored.                                                                         ' ,& '                                                                                                                                ' ,& '   --denominator  divide the result by this value. Default is one(1).                                                           ' ,& '   --help         display this help and exit                                                                                    ' ,& '   --version      output version information and exit                                                                           ' ,& '                                                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& '  Usage                                                                                                                         ' ,& '                                                                                                                                ' ,& '    days2sec 1-12:04:20                                                                                                         ' ,& '    129860                                                                                                                      ' ,& '    days2sec 1.5 days                                                                                                           ' ,& '    129600                                                                                                                      ' ,& '    days2sec 1.5 days 4hrs 30minutes                                                                                            ' ,& '    145800                                                                                                                      ' ,& '    days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED                                                                    ' ,& '    30                                                                                                                          ' ,& '    days2sec 1 1 1  # SPACES ARE IGNORED                                                                                        ' ,& '    111                                                                                                                         ' ,& 'SEE ALSO                                                                                                                        ' ,& '    sec2days(1)                                                                                                                 ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    days2sec dd-hh:mm:ss | --version| --help !!    days2sec NNdNNhNNmNNs !! !!##DESCRIPTION !!    Given a duration in the form dd-hh:mm:ss where dd is days, hh hours, !!    mm minutes and ss seconds convert it to seconds. Many utilities (ps(1), !!    for example) show times in this format to make it more intelligible; !!    but it generally easier to perform math on values represented in !!    seconds. !! !!##OPTIONS !!    dd-hh:mm:ss  Given a string representing a duration of time in the !!                 following forms: !! !!                   dd-hh:mm:ss !!                      hh:mm:ss !!                         mm:ss !!                            ss !! !!                 convert it to seconds. !! !!                 The numeric values may represent floating point numbers. !! !!                 Spaces are ignored. !! !!     NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes; !!                   where s,m,h, or d represents seconds, minutes, hours !!                   or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are !! !!                    w -  weeks,week,wk,wks !!                    d -  days,day !!                    m -  minutes,minute,min !!                    h -  hours,hour,hrs,hr !!                    s -  seconds,second,sec,secs !! !!                   The numeric values may represent floating point numbers. !! !!                   Spaces, commas  and case are ignored. !! !!    --denominator  divide the result by this value. Default is one(1). !!    --help         display this help and exit !!    --version      output version information and exit !! !!##EXAMPLE !! !!   Usage !! !!     days2sec 1-12:04:20 !!     129860 !!     days2sec 1.5 days !!     129600 !!     days2sec 1.5 days 4hrs 30minutes !!     145800 !!     days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED !!     30 !!     days2sec 1 1 1  # SPACES ARE IGNORED !!     111 !!##SEE ALSO !!     sec2days(1) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        days2sec(1f)>' ,& '@(#)DESCRIPTION:    convert dd-hh:mm:ss string to seconds>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_days2sec","tags":"","loc":"program/demo_days2sec.html"},{"title":"today – M_time","text":"Contents Subroutines help_usage help_version main Source Code today Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version subroutine main () Arguments None Source Code program today implicit none call main () contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       today(1f) - [TIME] output current time for uses such as file suffixes.                                                   ' ,& '       (LICENSE:PD)                                                                                                             ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       today format|--help|--version|--options                                                                                  ' ,& 'DESCRIPTION                                                                                                                     ' ,& '       Outputs the current date using the specified format. Typically used                                                      ' ,& '       to generate a string to be used in building filenames containing                                                         ' ,& '       date information.                                                                                                        ' ,& 'OPTIONS                                                                                                                         ' ,& '       format     any allowable format for the fmtdate(3) routine. Enter                                                        ' ,& '                  \"-\" to get a list on stdout. defaults to \"YMD\".                                                               ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --options  display allowed options for building a format                                                                 ' ,& 'EXAMPLE                                                                                                                         ' ,& '       Sample commands:                                                                                                         ' ,& '                                                                                                                                ' ,& '        cp myfile myfile.`today`                                                                                                ' ,& '        find . -ls > MANIFEST.`today epoch`                                                                                     ' ,& '        mkdir `today YMDhms`                                                                                                    ' ,& '        today yearmonthdayhourminutesecond                                                                                      ' ,& '        today --options                       # show formatting options                                                         ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        today(1f) - [TIME] output current time for uses such as file suffixes. !!        (LICENSE:PD) !!##SYNOPSIS !! !!        today format|--help|--version|--options !!##DESCRIPTION !!        Outputs the current date using the specified format. Typically used !!        to generate a string to be used in building filenames containing !!        date information. !!##OPTIONS !!        format     any allowable format for the fmtdate(3) routine. Enter !!                   \"-\" to get a list on stdout. defaults to \"YMD\". !!        --help     display this help and exit !!        --version  output version information and exit !!        --options  display allowed options for building a format !!##EXAMPLE !! !!        Sample commands: !! !!         cp myfile myfile.`today` !!         find . -ls > MANIFEST.`today epoch` !!         mkdir `today YMDhms` !!         today yearmonthdayhourminutesecond !!         today --options                       # show formatting options !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        today(1f)>' ,& '@(#)DESCRIPTION:    output current time for uses such as file suffixes.>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version subroutine main () use M_time , only : now , fmtdate_usage use M_kracken95 , only : kracken , lget , sget ! add command-line parser module ! ident_1=\"@(#)today(1f): output current time for uses such as file suffixes.\" character ( len = :), allocatable :: options call kracken ( 'today' , '-help .F. -version .F. -options .F.' ) ! define command arguments,default values and crack command line call help_usage ( lget ( 'today_help' )) ! if -help option is present, display help text and exit call help_version ( lget ( 'today_version' )) ! if -version option is present, display version text and exit if ( lget ( 'today_options' )) then ! special option to list date format documentation call fmtdate_usage () ! see all formatting options else options = sget ( 'today_oo' ) ! get -oo STRING if ( options . eq . '' ) then ! if options are blank set a default write ( * , '(a)' ) now ( 'YMD' ) ! display current date using format from command line else write ( * , '(a)' ) now ( options ) ! display current date using format from command line endif endif end subroutine main end program today","tags":"","loc":"program/today.html"},{"title":"month_exe – M_time","text":"Uses M_time M_kracken95 Contents Variables c calen calenyear cscr dat_values ident month r Subroutines help_usage help_version Source Code month_exe Variables Type Attributes Name Initial integer :: c character(len=21) :: calen (8) = '                    ' character :: calenyear (8*4) = '                      ' character(len=21) :: cscr integer :: dat_values (8) character(len=*), parameter :: ident = \"@(#)month(1f):print calendar\" integer :: month integer :: r Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program month_exe use M_kracken95 , only : kracken , iget , lget , sget ! command line parsing use M_time , only : box_month , mo2v ! date and time implicit none character ( len =* ), parameter :: ident = \"@(#)month(1f):print calendar\" character ( len = 21 ) :: calen ( 8 ) = '                    ' ! character array to hold month character ( len = ( 21 + 2 ) * 3 ) :: calenyear ( 8 * 4 ) = '                      ' ! character array to hold year integer :: month ! values of command line options integer :: dat_values ( 8 ) ! date array integer :: r , c ! row and column for month in one-year calendar character ( len = 21 ) :: cscr call date_and_time ( values = dat_values ) ! get current time and date call kracken ( 'month' , ' -year -month 0 -help .f. -version .f.' ) ! crack command line arguments call help_usage ( lget ( 'month_help' )) ! print help information and stop if requested call help_version ( lget ( 'month_version' )) ! print version information and stop if requested !----------------------------------------------------------------------------------------------------------------------------------- ! use user-specified year date instead of current year. Try reading year from two places (-oo and -year) on command line if ( sget ( 'month_year' ). ne . ' ' ) then ! check -year option for a year value dat_values ( 1 ) = iget ( 'month_year' ) ! if value was specified use it elseif ( sget ( 'month_oo' ). ne . ' ' ) then dat_values ( 1 ) = iget ( 'month_oo' ) ! check -oo option for a year value if did not find -year VALUE endif !write(*,*)'YEAR=',dat_values(1) !----------------------------------------------------------------------------------------------------------------------------------- cscr = sget ( 'month_month' ) ! get month as string so can see if name or number or blank if ( cscr . ne . '' ) then select case ( cscr ( 1 : 1 )) case ( 'A' : 'Z' , 'a' : 'z' ) ! assume month name instead of month number month = mo2v ( trim ( cscr )) case default ! month is number month = iget ( 'month_month' ) end select else ! keyword given but no value, default to current month month = dat_values ( 2 ) endif !----------------------------------------------------------------------------------------------------------------------------------- if ( month . eq . 0 ) then ! no month specified, display an entire year do r = 1 , 4 ! display year in four rows do c = 1 , 3 ! three months per row dat_values ( 2 ) = c + ( r - 1 ) * 3 call box_month ( dat_values , calen ) calenyear ( 8 * r - 7 : 8 * r )( 23 * c - 22 : 23 * c ) = calen ! copy month into large year array enddo enddo write ( * , '(a)' ) calenyear else ! do a month dat_values ( 2 ) = month call box_month ( dat_values , calen ) write ( * , '(a)' ) calen endif !----------------------------------------------------------------------------------------------------------------------------------- contains !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   month(1f) - [TIME] display a calendar                                                                                        ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   month [[ -year] NNNN] [ -month NN|month_name]                                                                                ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   month(1) displays a simple calendar. If no arguments are specified,                                                          ' ,& '   the current year is displayed.                                                                                               ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   -month      Display single month output. The month is numeric (1-12)                                                         ' ,& '               or a month name or blank. If blank the current month is assumed.                                                 ' ,& '                                                                                                                                ' ,& '   -year NNNN  Select the year to display. A year starts on Jan 1st.                                                            ' ,& '                                                                                                                                ' ,& '   -help       Display help text and exit.                                                                                      ' ,& '   -version    Display version information and exit.                                                                            ' ,& '                                                                                                                                ' ,& 'EXAMPLES                                                                                                                        ' ,& '      month -month 12                                                                                                           ' ,& '                                                                                                                                ' ,& '       >    December 2015                                                                                                       ' ,& '       >Mo Tu We Th Fr Sa Su                                                                                                    ' ,& '       >    1  2  3  4  5  6                                                                                                    ' ,& '       > 7  8  9 10 11 12 13                                                                                                    ' ,& '       >14 15 16 17 18 19 20                                                                                                    ' ,& '       >21 22 23 24 25 26 27                                                                                                    ' ,& '       >28 29 30 31                                                                                                             ' ,& '                                                                                                                                ' ,& '      month -month April # month names may be given instead of numbers                                                          ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    month(1f) - [TIME] display a calendar !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    month [[ -year] NNNN] [ -month NN|month_name] !! !!##DESCRIPTION !!    month(1) displays a simple calendar. If no arguments are specified, !!    the current year is displayed. !! !!##OPTIONS !!    -month      Display single month output. The month is numeric (1-12) !!                or a month name or blank. If blank the current month is assumed. !! !!    -year NNNN  Select the year to display. A year starts on Jan 1st. !! !!    -help       Display help text and exit. !!    -version    Display version information and exit. !! !!##EXAMPLES !! !!       month -month 12 !! !!        >    December 2015 !!        >Mo Tu We Th Fr Sa Su !!        >    1  2  3  4  5  6 !!        > 7  8  9 10 11 12 13 !!        >14 15 16 17 18 19 20 !!        >21 22 23 24 25 26 27 !!        >28 29 30 31 !! !!       month -month April # month names may be given instead of numbers !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        month(1f)>' ,& '@(#)DESCRIPTION:    displays simple calendar>' ,& '@(#)VERSION:        1.0, 2015-12-20>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- end program month_exe","tags":"","loc":"program/month_exe.html"},{"title":"demo_moon_fullness – M_time","text":"Uses M_time Contents Variables dat Source Code demo_moon_fullness Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_moon_fullness use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' )& & 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_moon_fullness","tags":"","loc":"program/demo_moon_fullness.html"},{"title":"demo_mo2v – M_time","text":"Uses M_time Contents Source Code demo_mo2v Source Code program demo_mo2v use M_time , only : mo2v implicit none write ( * , * ) mo2v ( \"April\" ) write ( * , * ) mo2v ( 'Apr' ) ! NOTE: still matches September, as \"SE\" was enough write ( * , * ) mo2v ( 'sexember' ) write ( * , * ) mo2v ( 'unknown' ) ! returns -1 end program demo_mo2v","tags":"","loc":"program/demo_mo2v.html"},{"title":"demo_ordinal_to_date – M_time","text":"Uses M_time Contents Variables dat dd ddd ios mm yy yyyy Source Code demo_ordinal_to_date Variables Type Attributes Name Initial integer :: dat (8) integer :: dd integer :: ddd integer :: ios integer :: mm integer :: yy integer :: yyyy Source Code program demo_ordinal_to_date use M_time , only : ordinal_to_date implicit none INTEGER :: yyyy , ddd , mm , dd , yy integer :: dat ( 8 ) integer :: ios INFINITE : do write ( * , '(a)' , advance = 'no' )& & 'Enter year YYYY and ordinal day of year DD ' read ( * , * , iostat = ios ) yyyy , ddd if ( ios . ne . 0 ) exit INFINITE ! recover month and day from year and day number. call ordinal_to_date ( yyyy , ddd , dat ) yy = dat ( 1 ) mm = dat ( 2 ) dd = dat ( 3 ) write ( * , '(*(g0))' ) 'For Year ' , yyyy , ' and Ordinal day ' , ddd , & & ' Month is ' , mm , ' and Day of Month is ' , dd , & & ' and Year is ' , yy enddo INFINITE end program demo_ordinal_to_date","tags":"","loc":"program/demo_ordinal_to_date.html"},{"title":"demo_d2w – M_time","text":"Uses M_time Contents Variables dat iso_name iso_week iso_weekday iso_year Source Code demo_d2w Variables Type Attributes Name Initial integer :: dat (8) character(len=10) :: iso_name integer :: iso_week integer :: iso_weekday integer :: iso_year Source Code program demo_d2w use M_time , only : d2w implicit none integer :: dat ( 8 ) ! input date array integer :: iso_year , iso_week , iso_weekday character ( len = 10 ) :: iso_name call date_and_time ( values = dat ) call d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) write ( * , '(\"ISO-8601 Week:   \",a)' ) iso_name write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday end program demo_d2w","tags":"","loc":"program/demo_d2w.html"},{"title":"demo_phase_of_moon – M_time","text":"Uses M_time Contents Variables dat Source Code demo_phase_of_moon Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_phase_of_moon use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' ) 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_phase_of_moon","tags":"","loc":"program/demo_phase_of_moon.html"},{"title":"demo_o2d – M_time","text":"Uses M_time Contents Variables year Source Code demo_o2d Variables Type Attributes Name Initial integer :: year Source Code program demo_o2d use M_time , only : o2d , fmtdate implicit none integer :: year do year = 2004 , 2008 write ( * , * )& & '100th day of ' , year , ' is ' , fmtdate ( o2d ( 100 , year )) enddo write ( * , * ) '100th day of this year is ' , fmtdate ( o2d ( 100 )) end program demo_o2d","tags":"","loc":"program/demo_o2d.html"},{"title":"demo_sec2days – M_time","text":"Uses M_time Contents Variables dp Source Code demo_sec2days Variables Type Attributes Name Initial integer, parameter :: dp = kind(0.0d0) Source Code program demo_sec2days use M_time , only : sec2days implicit none integer , parameter :: dp = kind ( 0.0d0 ) write ( * , * ) sec2days ( 129860 ) write ( * , * ) sec2days ( 8000 0.0_dp ) write ( * , * ) sec2days ( 8000 0.0 , crop = . true .) write ( * , * ) sec2days ( '1 day 2.0hr 100 min 300.0seconds' ) end program demo_sec2days","tags":"","loc":"program/demo_sec2days~2.html"},{"title":"demo_fmtdate_usage – M_time","text":"Uses M_time Contents Source Code demo_fmtdate_usage Source Code program demo_fmtdate_usage use M_time , only : fmtdate_usage implicit none call fmtdate_usage () ! see all formatting options end program demo_fmtdate_usage","tags":"","loc":"program/demo_fmtdate_usage.html"},{"title":"demo_ordinal_seconds – M_time","text":"Uses M_time Contents Variables iend ios istart paws Source Code demo_ordinal_seconds Variables Type Attributes Name Initial integer :: iend integer :: ios integer :: istart character(len=1) :: paws Source Code program demo_ordinal_seconds use M_time , only : ordinal_seconds implicit none character ( len = 1 ) :: paws integer :: ios integer :: istart , iend istart = ordinal_seconds () write ( * , '(a)' , advance = 'no' ) 'now pause. Enter return to continue ...' read ( * , '(a)' , iostat = ios ) paws iend = ordinal_seconds () write ( * , * ) 'that took ' , iend - istart , 'seconds' write ( * , * ) istart , iend end program demo_ordinal_seconds","tags":"","loc":"program/demo_ordinal_seconds.html"},{"title":"demo_d2u – M_time","text":"Uses M_time Contents Variables dat Source Code demo_d2u Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2u use M_time , only : d2u implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Unix Epoch time is ' , d2u ( dat ) end program demo_d2u","tags":"","loc":"program/demo_d2u.html"},{"title":"demo_julian_to_date – M_time","text":"Uses M_time Contents Variables dat dp ierr juliandate Source Code demo_julian_to_date Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr real(kind=realtime) :: juliandate Source Code program demo_julian_to_date use M_time , only : julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr ! set sample Julian Date juliandate = 245758 9.129_dp ! create DAT array for this date call julian_to_date ( juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call julian_to_date ( juliandate - 1.0_dp , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call julian_to_date ( juliandate + 1.0_dp , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_julian_to_date","tags":"","loc":"program/demo_julian_to_date.html"},{"title":"demo_system_sleep – M_time","text":"Uses M_time Contents Variables i Source Code demo_system_sleep Variables Type Attributes Name Initial integer :: i Source Code program demo_system_sleep use M_time , only : system_sleep , now implicit none integer :: i ! write ( * , '(a)' ) \"Time before integer call is: \" , now () call system_sleep ( 4 ) write ( * , '(a)' ) \"Time after  integer call is: \" , now () ! write ( * , '(a)' ) \"Time before real call is: \" , now () call system_sleep ( 4.0 ) write ( * , '(a)' ) \"Time after  real call is: \" , now () ! write ( * , '(a)' ) \"Time before loop is: \" , now () do i = 1 , 1000 call system_sleep ( 4.0 / 100 0.0 ) enddo write ( * , '(a)' ) \"Time after loop  is: \" , now () ! end program demo_system_sleep","tags":"","loc":"program/demo_system_sleep.html"},{"title":"demo_fmtdate – M_time","text":"Uses M_time Contents Variables dat Subroutines showme Source Code demo_fmtdate Variables Type Attributes Name Initial integer :: dat (8) Subroutines subroutine showme () Arguments None Source Code program demo_fmtdate use M_time , only : fmtdate implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , * ) fmtdate ( dat , \"current date: %w, %l %d, %Y %H:%m:%s %N\" ) call showme () contains subroutine showme () use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine showme end program demo_fmtdate","tags":"","loc":"program/demo_fmtdate.html"},{"title":"demo_dow – M_time","text":"Uses M_time Contents Variables dat day ierr weekday Source Code demo_dow Variables Type Attributes Name Initial integer :: dat (8) character(len=9) :: day integer :: ierr integer :: weekday Source Code program demo_dow use M_time , only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) call dow ( dat , weekday , day , ierr ) write ( * , '(a,i0)' ) 'weekday=' , weekday write ( * , '(a,a)' ) 'day=' , trim ( day ) write ( * , '(a,i0)' ) 'ierr=' , ierr end program demo_dow","tags":"","loc":"program/demo_dow.html"},{"title":"demo_v2mo – M_time","text":"Uses M_time Contents Variables i Source Code demo_v2mo Variables Type Attributes Name Initial integer :: i Source Code program demo_v2mo use M_time , only : v2mo implicit none integer :: i write ( * , * )( v2mo ( i ), i = 1 , 13 ) end program demo_v2mo","tags":"","loc":"program/demo_v2mo.html"},{"title":"demo_d2j – M_time","text":"Uses M_time Contents Variables dat Source Code demo_d2j Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2j use M_time , only : d2j implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Julian Date is ' , d2j ( dat ) end program demo_d2j","tags":"","loc":"program/demo_d2j.html"},{"title":"demo_days2sec – M_time","text":"Uses M_time Contents Source Code demo_days2sec Source Code program demo_days2sec use M_time , only : days2sec implicit none write ( * , * ) days2sec ( '1-12:04:20' ) write ( * , * ) 'one second ' , days2sec ( '1' ) write ( * , * ) 'one minute ' , days2sec ( '1:00' ) write ( * , * ) 'one hour ' , days2sec ( '1:00:00' ) write ( * , * ) 'one day ' , days2sec ( '1-00:00:00' ) write ( * , * ) nint ( days2sec ( ' 1-12:04:20              ' )) . eq . 129860 write ( * , * ) nint ( days2sec ( ' 1.5 days                ' )) . eq . 129600 write ( * , * ) nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) . eq . 145800 write ( * , * ) nint ( days2sec ( ' 1.5d                    ' )) . eq . 129600 write ( * , * ) nint ( days2sec ( ' 1d2h3m4s                ' )) . eq . 93784 ! duplicates write ( * , * ) nint ( days2sec ( ' 1d1d1d                  ' )) . eq . 259200 ! negative values write ( * , * ) nint ( days2sec ( ' 4d-12h                  ' )) . eq . 302400 end program demo_days2sec","tags":"","loc":"program/demo_days2sec~2.html"},{"title":"demo_date_to_unix – M_time","text":"Uses M_time Contents Variables dat ierr unixtime Source Code demo_date_to_unix Variables Type Attributes Name Initial integer :: dat (8) integer :: ierr real(kind=realtime) :: unixtime Source Code program demo_date_to_unix use M_time , only : date_to_unix , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: unixtime integer :: ierr call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat call date_to_unix ( dat , unixtime , ierr ) write ( * , * ) 'Unix Epoch time is ' , unixtime write ( * , * ) 'ierr is ' , ierr end program demo_date_to_unix","tags":"","loc":"program/demo_date_to_unix.html"},{"title":"demo_M_time_oop – M_time","text":"Uses M_time_oop use M_time_oop,only : operator(+),operator(-),operator(>),operator(<)\nuse M_time_oop,only : operator(<=),operator(>=),operator(==),operator(/=) Contents Variables answer dat dp event iso_fmt otherdate Source Code demo_M_time_oop Variables Type Attributes Name Initial type( date_time ) :: answer integer :: dat (8) integer, parameter :: dp = kind(0.0d0) type( date_time ) :: event character(len=*), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' type( date_time ) :: otherdate Source Code program demo_M_time_oop ! ! This is an example using the object-oriented class/type model ! This is essentially the same functionality as the procedures ! in the procedural module M_time(3fm), but allows for Object ! Oriented syntax: ! use M_time_oop , only : date_time !!use M_time_oop,only : operator(+),operator(-),operator(>),operator(<) !!use M_time_oop,only : operator(<=),operator(>=),operator(==),operator(/=) implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer :: dat ( 8 ) TYPE ( date_time ) :: event TYPE ( date_time ) :: otherdate TYPE ( date_time ) :: answer character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' ! DIFFERENT INITIALIZATION STYLES ! (Still debating on how best to do this) write ( * , * ) write ( * , '(a)' ) 'Various initialization styles' ! DEFINE type(date_time) WITH CONSTRUCTOR otherdate = date_time () print * , 'DEFAULT CONSTRUCTOR %format()               ' ,& & otherdate % format () print * , 'DEFAULT CONSTRUCTOR %format(\"\")             ' ,& & otherdate % format ( \"\" ) print * , 'DEFAULT CONSTRUCTOR %format(user-specified) ' ,& & otherdate % format ( iso_fmt ) print * , 'DEFAULT CONSTRUCTOR %format(\"USA\")          ' ,& & otherdate % format ( \"USA\" ) otherdate = date_time ( 1492 , 10 , 12 , 0 , 0 , 0 , 0 , 0 ) print * , 'DEFAULT CONSTRUCTOR setting values          ' ,& & otherdate % format () otherdate = date_time ( 2016 , 6 , 11 ) print * , 'DEFAULT CONSTRUCTOR with partial values     ' ,& & otherdate % format () otherdate = date_time ( year = 2016 , month = 6 , day = 11 , tz =- 240 ,& & hour = 21 , minute = 09 , second = 11 , millisecond = 500 ) print * , 'DEFAULT CONSTRUCTOR with values by name     ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 , 0 , 0 , 0 , 0 , 0 ]) print * , 'CONSTRUCTOR with a dat array                ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 ]) print * , 'CONSTRUCTOR with a partial dat array        ' ,& & otherdate % format () ! the init() method supports several methods ! initialize to current time using INIT call otherdate % init () ! initialize to current time using INIT call otherdate % init ( type = \"now\" ) ! initialize to beginning of Unix Epoch Time call otherdate % init ( type = \"epoch\" ) ! Note ! currently, DATE_TIME DATE array is set to Unix Epoch ! start USING LOCAL TIMEZONE ! whereas default constructor is using default of Unix Epoch ! start using Z time (GMT or UTC time) ! initialize with a DAT array using INIT, ! compatible with DATE_AND_TIME VALUES(8) call otherdate % init ( dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) ! using INIT with ordered values call otherdate % init ( 2016 , 6 , 11 , - 300 , 23 , 1 , 0 , 0 ) ! using INIT with names call otherdate % init ( year = 2016 , month = 6 , day = 11 ,& & tz =- 300 , hour = 23 , minute = 1 , second = 0 , millisecond = 0 ) ! ! take current date and exercise the OOP interface ! initialize to current time using INIT call event % init () write ( * , * ) write ( * , * ) 'Print members of type(DATE_TIME)' ! show derived type write ( * , 404 ) 'EVENT=' , event 404 format ( 1 x , a , i0 , * ( \",\" , i0 :)) ! MEMBERS ( basic time values are all integers) ! print members of type write ( * , 101 ) '%year        Year................... ' , event % year write ( * , 101 ) '%month       Month.................. ' , event % month write ( * , 101 ) '%day         Day.................... ' , event % day write ( * , 101 ) '%tz          Timezone............... ' , event % tz write ( * , 101 ) '%hour        Hour................... ' , event % hour write ( * , 101 ) '%minute      Minute................. ' , event % minute write ( * , 101 ) '%second      Second................. ' , event % second write ( * , 101 ) '%millisecond Millisecond............ ' , event % millisecond ! PRINT METHODS OF TYPE write ( * , * ) 'Print methods of type(DATE_TIME)' write ( * , 101 ) '%ordinal     Ordinal day of year.... ' , event % ordinal () write ( * , 101 ) '%weekday     Weekday................ ' , event % weekday () 101 format ( 1 x , a , i0 ) ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY write ( * , 202 ) '%epoch      Unix epoch time........ ' , event % epoch () write ( * , 202 ) '%julian     Julian date............ ' , event % julian () 202 format ( 1 x , a , g0 ) ! FORMATTED STRINGS (many strings possible. ! Takes the same format string as fmtdate(3f)) write ( * , * ) write ( * , '(a)' ) ' Formatted Strings (%format(\"STRING\") & & -- see fmtdate(3f) for format descriptions' ! abbreviated month name             %l  Dec write ( * , 303 ) 'Short month............ ' ,& & event % format ( \"%l\" ) ! ! full month name                    %L  December write ( * , 303 ) 'Month.................. ' ,& & event % format ( \"%L\" ) ! ! first three characters of weekday  %w  Sat write ( * , 303 ) 'Short week............. ' ,& & event % format ( \"%w\" ) ! ! weekday name                       %W  Saturday write ( * , 303 ) 'Week .................. ' ,& & event % format ( \"%W\" ) ! ! with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( \"Y-M-D h:m:s.x z\" ) ! ! keywords with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( '\"year-month-day & & hour:minute:second.millisecond timezone\"' ) ! write ( * , * ) event % format ( 'Longer format.......... & &\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! a nice friendly format ! 303 format ( 1 x , a , '\"' , a , '\"' ) ! convert date_time to integer array ! (maybe to use with module M_TIME base procedures) dat = event % datout () write ( * , * ) write ( * , 404 ) 'DAT=' , dat ! OVERLOADED OPERATORS (add and subtract) ! a date_time object can have seconds added answer = event + 1 * 8640 0.0_dp ! ! a nice friendly format write ( * , * ) answer % format ( 'TOMORROW=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! a date_time object can have seconds subtracted answer = event - 1 * 8640 0.0_dp ! a nice friendly format write ( * , * ) answer % format ( 'YESTERDAY=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! if both operands are DATE_TIME objects a subtraction ! finds the time in seconds between the two dates write ( * , * ) 'DIFFERENCE (subtracting one date_time from another)=' ,& & answer - event ! OVERLOADED OPERATORS (logical comparisons) ! NOTE COMPARISONS ARE PERFORMED BY ! CONVERTING TIMES TO INTEGER SECONDS write ( * , * ) '> ' , event . eq . event , event . lt . event , event . gt . event & & , event . le . event , event . ge . event , event . ne . event ! write ( * , * ) '> ' , event . eq . answer , event . lt . answer , event . gt . answer & & , event . le . answer , event . ge . answer , event . ne . answer ! write ( * , * ) '> ' , answer . eq . event , answer . lt . event , answer . gt . event & & , answer . le . event , answer . ge . event , answer . ne . event ! %DELTA easily lets you change dates by common increments write ( * , * ) write ( * , 404 ) '%DELTA tests starting with date ' , event % delta () ! write ( * , * ) event % format ( \"                             & &%W, %L %d, %Y %H:%m:%s %N\" ) write ( * , * ) 'Remember years and months are not constant units' answer = event % delta ( year = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( month = 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( month =- 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( week = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( week =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( day = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( day =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = 4 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour =- 4 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( minute = 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( minute =- 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( second = 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( second =- 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( millisecond = 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( millisecond =- 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = 3 , month = 2 , day = 100 , hour = 200 ,& & week =- 1 , minute = 300 , second = 1000 , millisecond =- 10000 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(year=3,month=2,day=100,hour=200,& &week=-1,minute=300,second=1000,millisecond=100000)& & %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( duration = \"1-20:30:40.50\" ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DURATION='1-20:30:40.50')& & %W, %L %d, %Y %H:%m:%s %N\" ) end program demo_M_time_oop","tags":"","loc":"program/demo_m_time_oop.html"},{"title":"demo_u2d – M_time","text":"Uses M_time Contents Variables dat dp today Source Code demo_u2d Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) real(kind=realtime) :: today Source Code program demo_u2d use M_time , only : u2d , d2u , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) ! get the date using intrinsic call date_and_time ( values = dat ) ! convert today to Julian Date today = d2u ( dat ) write ( * , * ) 'Today=' , fmtdate ( u2d ( today )) ! subtract day write ( * , * ) 'Yesterday=' , fmtdate ( u2d ( today - 8640 0.0_dp )) ! add day write ( * , * ) 'Tomorrow=' , fmtdate ( u2d ( today + 8640 0.0_dp )) end program demo_u2d","tags":"","loc":"program/demo_u2d.html"},{"title":"demo_unix_to_date – M_time","text":"Uses M_time Contents Variables DAY dat dp ierr unixtime Source Code demo_unix_to_date Variables Type Attributes Name Initial real(kind=realtime), parameter :: DAY = 86400.0_dp integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr real(kind=realtime) :: unixtime Source Code program demo_unix_to_date use M_time , only : unix_to_date , u2d , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: unixtime ! seconds in a day real ( kind = realtime ), parameter :: DAY = 8640 0.0_dp integer :: dat ( 8 ) integer :: ierr ! sample Unix Epoch time unixtime = 146893903 8.4639933_dp ! create DAT array for today call unix_to_date ( unixtime , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call unix_to_date ( unixtime - DAY , dat , ierr ) ! subtract day and print write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call unix_to_date ( unixtime + DAY , dat , ierr ) ! add day print write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_unix_to_date","tags":"","loc":"program/demo_unix_to_date.html"},{"title":"demo_d2o – M_time","text":"Uses M_time Contents Variables dat Source Code demo_d2o Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2o use M_time , only : d2o implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Day of year is:' , d2o ( dat ) ! year,month,day,timezone,hour,minute,seconds,milliseconds dat = [ 2020 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2021 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2022 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2023 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2024 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) end program demo_d2o","tags":"","loc":"program/demo_d2o.html"},{"title":"demo_mo2d – M_time","text":"Uses M_time Contents Source Code demo_mo2d Source Code program demo_mo2d use M_time , only : mo2d implicit none write ( * , '(*(i0:,\":\"))' ) mo2d ( 'March' ) end program demo_mo2d","tags":"","loc":"program/demo_mo2d.html"},{"title":"demo_j2d – M_time","text":"Uses M_time Contents Variables dat dp today Source Code demo_j2d Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) real(kind=realtime) :: today Source Code program demo_j2d use M_time , only : j2d , d2j , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2j ( dat ) ! convert today to Julian Date write ( * , * ) 'Today=' , fmtdate ( j2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) 'Yesterday=' , fmtdate ( j2d ( today - 1.0_dp )) write ( * , * ) 'Tomorrow=' , fmtdate ( j2d ( today + 1.0_dp )) end program demo_j2d","tags":"","loc":"program/demo_j2d.html"},{"title":"demo_easter – M_time","text":"Uses M_time Contents Variables dat year Source Code demo_easter Variables Type Attributes Name Initial integer :: dat (8) integer :: year Source Code program demo_easter use M_time , only : easter , fmtdate implicit none integer :: year integer :: dat ( 8 ) ! year,month,day,tz,hour,minute,second,millisecond call date_and_time ( values = dat ) ! get current year year = dat ( 1 ) call easter ( year , dat ) write ( * , * ) fmtdate ( dat ,& \"Easter day: the %d day of %L in the year of our Lord %Y\" ) end program demo_easter","tags":"","loc":"program/demo_easter.html"},{"title":"demo_now – M_time","text":"Uses M_time Contents Subroutines showme Source Code demo_now Subroutines subroutine showme () Arguments None Source Code program demo_now use M_time , only : now implicit none write ( * , * ) now ( \"The current date is %w, %l %d, %Y %H:%m:%s %N\" ) call showme () contains subroutine showme () ! see all formatting options use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine end program demo_now","tags":"","loc":"program/demo_now.html"},{"title":"demo_box_month – M_time","text":"Uses M_time Contents Variables calendar dat Source Code demo_box_month Variables Type Attributes Name Initial character(len=21) :: calendar (8) integer :: dat (8) Source Code program demo_box_month use M_time , only : box_month implicit none integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) call date_and_time ( values = dat ) call box_month ( dat , calendar ) write ( * , '(a)' ) calendar end program demo_box_month","tags":"","loc":"program/demo_box_month.html"},{"title":"demo_w2d – M_time","text":"Uses M_time Contents Subroutines printit Source Code demo_w2d Subroutines subroutine printit (iso_year, iso_week, iso_weekday) Arguments Type Intent Optional Attributes Name integer :: iso_year integer :: iso_week integer :: iso_weekday Source Code program demo_w2d use M_time , only : w2d , fmtdate implicit none write ( * , '(a)' )& & 'Given Monday 29 December 2008 is written \"2009-W01-1\"' call printit ( 2009 , 1 , 1 ) write ( * , '(a)' )& & 'Given Sunday 3 January 2010 is written \"2009-W53-7\"' call printit ( 2009 , 53 , 7 ) write ( * , '(a)' )& & 'Given the Gregorian date Sun 31 December 2006 & &is written 2006-W52-7' call printit ( 2006 , 52 , 7 ) write ( * , '(a)' )& & 'Given 27 September 2008 is 2008-W39-6' call printit ( 2008 , 39 , 6 ) contains subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO-8601 Week: 2016-W29-1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * , '(a,i0)' ) 'GIVEN:           ' write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) end subroutine printit end program demo_w2d","tags":"","loc":"program/demo_w2d.html"},{"title":"demo_date_to_julian – M_time","text":"Uses M_time Contents Variables dat ierr juliandate Source Code demo_date_to_julian Variables Type Attributes Name Initial integer :: dat (8) integer :: ierr real(kind=realtime) :: juliandate Source Code program demo_date_to_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: juliandate integer :: ierr ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , * ) 'Julian Date is ' , juliandate write ( * , * ) 'ierr is ' , ierr end program demo_date_to_julian","tags":"","loc":"program/demo_date_to_julian.html"},{"title":"demo_guessdate – M_time","text":"Uses M_time Contents Variables answer dat datestrings i Source Code demo_guessdate Variables Type Attributes Name Initial character(len=:), allocatable :: answer integer :: dat (8) character(len=20), allocatable :: datestrings (:) integer :: i Source Code program demo_guessdate use M_time , only : guessdate , fmtdate implicit none character ( len = 20 ), allocatable :: datestrings (:) character ( len = :), allocatable :: answer integer :: dat ( 8 ) integer :: i datestrings = [ & & 'January 9th, 2001   ' ,& & ' Tue Jul 19 2016    ' ,& & ' 21/12/2016         ' ,& & ' 4th of Jul 2004    ' ] do i = 1 , size ( datestrings ) write ( * , '(a)' ) repeat ( '-' , 80 ) write ( * , * ) 'TRYING ' , datestrings ( i ) call guessdate ( datestrings ( i ), dat ) write ( * , * ) 'DAT ARRAY ' , dat answer = fmtdate ( dat ) write ( * , * ) 'FOR ' // datestrings ( i ) // ' GOT ' // trim ( answer ) enddo end program demo_guessdate","tags":"","loc":"program/demo_guessdate.html"},{"title":"runtest – M_time","text":"Uses M_msg M_verify M_time Contents Source Code runtest Source Code program runtest use M_msg use M_verify use M_verify , only : unit_check , unit_check_start , unit_check_good , unit_check_bad , unit_check_done use M_verify , only : unit_check_level use M_time implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_time () contains end program runtest","tags":"","loc":"program/runtest.html"},{"title":"M_time.F90 – M_time","text":"Contents Modules M_time Source Code M_time.F90 Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_time use M_time_duplicate use , intrinsic :: iso_fortran_env , only : int64 implicit none ! ident_1=\"@(#)M_time::M_time(3f): date and time function module\" private !----------------------------------------------------------------------------------------------------------------------------------- ! version: 6E61627255202E53206E686F4A-2022-03-18 !----------------------------------------------------------------------------------------------------------------------------------- ! UNIT TESTS ! EPOCH TIME (UT starts at 0000 on 1 Jan. 1970) public date_to_unix !(dat,UNIXTIME,IERR)                 ! Convert date array to Unix Time public unix_to_date !(unixtime,DAT,IERR)                 ! Convert Unix Time to date array public d2u !(dat) result (UNIXTIME)             ! Convert date array to Unix Time public u2d !(unixtime) result (DAT)             ! Convert Unix Time to date array ! JULIAN public julian_to_date !(julian,DAT,IERR)                   ! Convert Julian Date to date array public date_to_julian !(dat,JULIAN,IERR)                   ! Convert date array to Julian Date public d2j !(dat) result (JULIAN)               ! Convert date array to Julian Date public j2d !(julian) result (DAT)               ! Convert Julian Date to date array ! DAY OF WEEK public dow !(dat,[WEEKDAY],[DAY],IERR)          ! Convert date array to day of the week as number(Mon=1) and name ! WEEK OF YEAR public d2w !(dat,ISO_YEAR,ISO_WEEK,ISO_WEEKDAY,ISO_NAME)  ! Calculate iso-8601 Week-numbering year date yyyy-Www-d public w2d !(iso_year,iso_week,iso_weekday,DAT)           ! given iso-8601 Week-numbering year date yyyy-Www-d calculate date ! ORDINAL DAY public d2o !(dat) result(ORDINAL)               ! given date array return ordinal day of year, Jan 1st=1 public o2d !(ordinal) result(DAT)               ! given ordinal day of year return date array, Jan 1st=1 public ordinal_to_date !(year,ordinal_day,DAT)              ! given ordinal day of year return date array, Jan 1st=1 public ordinal_seconds !()                                  ! seconds since the beginning of current year ! PRINTING DATES public fmtdate !(dat,format) result (TIMESTR)       ! Convert date array to string using format public fmtdate_usage !(indent)                            ! display macros recognized by fmtdate(3f) public now !(format) result (NOW)               ! return string representing current time given format public box_month !(dat,CALEN)                         ! print specified month into character array ! PRINTING DURATIONS public sec2days !(seconds) result (dhms)             ! converts seconds to string D-HH:MM:SS public days2sec !(str) result (seconds)              ! converts string D-HH:MM:SS to seconds from small to large ! MONTH NAME public mo2v !(month_name) result (MONTH_NUMBER)  ! given month name return month number public v2mo !(month_number) result (MONTH_NAME)  ! given month number return month name public mo2d !(month_name) result (DAT)           ! given month name and year return date array for 1st day of month ! ASTROLOGICAL public easter !(year,dat)                          ! calculate month and day Easter falls on for given year public moon_fullness !(datin) result(FULLNESS)            ! percentage of moon phase from new to full public phase_of_moon !(datin) result(PHASE)               ! return name for phase of moon for given date !x! public ephemeris      !(dat,planet,DD,DM,DC,AH,AM)         ! ephemeris position of planets for adjusting an equatorial telescope ! READING DATES public guessdate !(anot,dat)                          ! Converts a date string to a date array, in various formats ! C INTERFACE public system_sleep !(wait_seconds)                      ! Call sleep(3c) private call_sleep private call_usleep !----------------------------------------------------------------------------------------------------------------------------------- integer , parameter :: dp = kind ( 0.0d0 ) integer , parameter , public :: realtime = kind ( 0.0d0 ) ! type for unix epoch time and julian days !----------------------------------------------------------------------------------------------------------------------------------- ! INTERNAL real ( kind = realtime ), parameter , private :: SECDAY = 8640 0.0_dp ! 24:00:00 hours as seconds !----------------------------------------------------------------------------------------------------------------------------------- !  integer,parameter       :: igreg_1582=15+31*(10+12*1582)   ! ASSUMES: Gregorian Calendar was adopted 15 Oct. 1582 (588829) !  integer,parameter       :: igreg_1752=03+31*( 9+12*1752)   ! ASSUMES: Gregorian Calendar was adopted 3 Sep. 1752 (652026) !  integer,save            :: igreg=igreg_1582 !----------------------------------------------------------------------------------------------------------------------------------- ! CONVENIENT CONSTANTS FOR USE WITH + AND - OPERATORS real ( kind = realtime ), public , parameter :: dt_minute = 6 0.0_dp ! one minute in seconds real ( kind = realtime ), public , parameter :: dt_hour = 360 0.0_dp ! one hour in seconds real ( kind = realtime ), public , parameter :: dt_day = 8640 0.0_dp ! 24:00:00 hours in seconds real ( kind = realtime ), public , parameter :: dt_week = dt_day * 7.0_dp ! one week in seconds !----------------------------------------------------------------------------------------------------------------------------------- contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    date_to_julian(3f) - [M_time:JULIAN] converts DAT date-time array to !!    Julian Date !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine date_to_julian(dat,juliandate,ierr) !! !!     integer,intent(in)               :: dat(8) !!     real(kind=realtime),intent(out)  :: juliandate !!     integer,intent(out)              :: ierr !! !!##DESCRIPTION !!   Converts a DAT date-time array to a Unix Epoch Time (UET) value. !!   UET is the number of seconds since 00:00 on January 1st, 1970, UTC. !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!           dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !! !!##RETURNS !!    juliandate  A Julian Ephemeris Date (JED) is the number of days since !!                noon (not midnight) on January 1st, 4713 BC. !!    ierr        Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_date_to_julian !!     use M_time, only : date_to_julian,realtime !!     implicit none !!     integer             :: dat(8) !!     real(kind=realtime) :: juliandate !!     integer             :: ierr !!        ! generate DAT array !!        call date_and_time(values=dat) !!        ! show DAT array !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        ! convert DAT to Julian Date !!        call date_to_julian(dat,juliandate,ierr) !!        write(*,*)'Julian Date is ',juliandate !!        write(*,*)'ierr is ',ierr !!     end program demo_date_to_julian !! !!    results: !! !!     Today is:2016:7:19:-240:11:3:13:821 !!     Julian Date is    2457589.1272432986 !!     ierr is            0 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine date_to_julian ( dat , julian , ierr ) !----------------------------------------------------------------------------------------------------------------------------------- !> !! AUTHOR:    John S. Urban !!##VERSION:   2.0 2022-01-16 !! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 ! * There is no year zero ! * Julian Date must be non-negative ! * Julian Date starts at noon; while Civil Calendar date starts at midnight !----------------------------------------------------------------------------------------------------------------------------------- ! ident_2=\"@(#)M_time::date_to_julian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date\" integer , intent ( in ) :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) real ( kind = realtime ), intent ( out ) :: julian ! Julian Date (non-negative, but may be non-integer) integer , intent ( out ) :: ierr ! Error return: 0 =successful execution,-1=invalid year,-2=invalid month,-3=invalid day ! -4=invalid date (29th Feb, non leap-year) integer :: year , month , day , utc , hour , minute real ( kind = realtime ) :: second integer :: A , Y , M , JDN !----------------------------------------------------------------------------------------------------------------------------------- year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0_dp ! Second   ! correction for time zone and milliseconds !----------------------------------------------------------------------------------------------------------------------------------- julian = - HUGE ( 99999 ) ! this is the date if an error occurs and IERR is < 0 !----------------------------------------------------------------------------------------------------------------------------------- if ( year == 0 . or . year . lt . - 4713 ) then ierr =- 1 return endif !----------------------------------------------------------------------------------------------------------------------------------- !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or February, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian Calendar date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0_dp + dble ( minute ) / 144 0.0_dp + second / 8640 0.0_dp !----------------------------------------------------------------------------------------------------------------------------------- if ( julian . lt . 0.0_dp ) then ! Julian Day must be non-negative ierr = 1 else ierr = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine date_to_julian !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    julian_to_date(3f) - [M_time:JULIAN] converts a JED(Julian Ephemeris !!    Date) to a DAT date-time array. !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine julian_to_date(julian,dat,ierr) !! !!     real(kind=realtime),intent(in) :: julian !!     integer,intent(out)            :: dat(8) !!     integer,intent(out)            :: ierr !! !!##DESCRIPTION !!   Converts a Unix Epoch Time (UET) value to a DAT date-time array. !!   UET is the number of seconds since 00:00 on January 1st, 1970, UTC. !! !!##OPTIONS !!     julian  Julian Date (days) !!     dat     Integer array holding a \"DAT\" array, similar in structure !!             to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!              dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !! !!##RETURNS !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since 00:00:00 on !!              January 1st, 1970, UTC. !!    ierr      Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!     Sample program: !! !!      program demo_julian_to_date !!      use M_time, only : julian_to_date, fmtdate, realtime !!      implicit none !!      integer,parameter :: dp=kind(0.0d0) !!      real(kind=realtime)     :: juliandate !!      integer                 :: dat(8) !!      integer                 :: ierr !!         ! set sample Julian Date !!         juliandate=2457589.129_dp !!         ! create DAT array for this date !!         call julian_to_date(juliandate,dat,ierr) !!         write(*,*)'Sample Date=',fmtdate(dat) !!         ! go back one day !!         call julian_to_date(juliandate-1.0_dp,dat,ierr) !!         write(*,*)'Day Before =',fmtdate(dat) !!         ! go forward one day !!         call julian_to_date(juliandate+1.0_dp,dat,ierr) !!         write(*,*)'Day After  =',fmtdate(dat) !!      end program demo_julian_to_date !! !!     Results: !! !!      Sample Date=Tuesday, July 19th, 2016 11:05:45 AM UTC-04:00 !!      Day Before =Monday, July 18th, 2016 11:05:45 AM UTC-04:00 !!      Day After  =Wednesday, July 20th, 2016 11:05:45 AM UTC-04:00 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine julian_to_date ( julian , dat , ierr ) ! ident_3=\"@(#)M_time::julian_to_date(3f): Converts Julian Date to DAT date-time array\" real ( kind = realtime ), intent ( in ) :: julian ! Julian Date (non-negative) integer , intent ( out ) :: dat ( 8 ) integer , intent ( out ) :: ierr ! 0 for successful execution, otherwise 1 integer :: tz real ( kind = realtime ) :: second integer :: year integer :: month integer :: day integer :: hour integer :: minute integer :: jalpha , ja , jb , jc , jd , je , ijul if ( julian . lt . 0.0_dp ) then ! Negative Julian Date not allowed ierr = 1 return else ierr = 0 endif tz = get_timezone () ijul = idint ( julian ) ! Integral Julian Date second = sngl (( julian - dble ( ijul )) * secday ) ! Seconds from beginning of Jul. Day second = second + ( tz * 60 ) if ( second . ge .( secday / 2.0_dp )) then ! In next calendar day ijul = ijul + 1 second = second - ( secday / 2.0_dp ) ! Adjust from noon to midnight else ! In same calendar day second = second + ( secday / 2.0_dp ) ! Adjust from noon to midnight endif if ( second . ge . secday ) then ! Final check to prevent time 24:00:00 ijul = ijul + 1 second = second - secday endif minute = int ( second / 6 0.0_dp ) ! Integral minutes from beginning of day second = second - dble ( minute * 60 ) ! Seconds from beginning of minute hour = minute / 60 ! Integral hours from beginning of day minute = minute - hour * 60 ! Integral minutes from beginning of hour !--------------------------------------------- jalpha = idint (( dble ( ijul - 1867216 ) - 0.25_dp ) / 3652 4.25_dp ) ! Correction for Gregorian Calendar ja = ijul + 1 + jalpha - idint ( 0.25_dp * dble ( jalpha )) !--------------------------------------------- jb = ja + 1524 jc = idint ( 668 0.0_dp + ( dble ( jb - 2439870 ) - 12 2.1_dp ) / 36 5.25_dp ) jd = 365 * jc + idint ( 0.25_dp * dble ( jc )) je = idint ( dble ( jb - jd ) / 3 0.6001_dp ) day = jb - jd - idint ( 3 0.6001_dp * dble ( je )) month = je - 1 if ( month . gt . 12 ) then month = month - 12 endif year = jc - 4715 if ( month . gt . 2 ) then year = year - 1 endif if ( year . le . 0 ) then year = year - 1 endif dat = [ year , month , day , tz , hour , minute , int ( second ), int (( second - int ( second )) * 100 0.0 )] ierr = 0 end subroutine julian_to_date !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    date_to_unix(3f) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix !!    Epoch Time !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine date_to_unix(dat,unixtime,ierr) !! !!     integer,intent(in)               :: dat(8) !!     real(kind=realtime),intent(out)  :: unixtime !!     integer,intent(out)              :: ierr !! !!##DESCRIPTION !!   Converts a DAT date-time array to a UET (Unix Epoch Time). !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!              dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !!##RETURNS !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since !!              00:00:00 on January 1st, 1970, UTC. !!    ierr      Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!     Sample program: !! !!      program demo_date_to_unix !!      use M_time, only : date_to_unix, realtime !!      implicit none !!      integer             :: dat(8) !!      real(kind=realtime) :: unixtime !!      integer             :: ierr !!         call date_and_time(values=dat) !!         write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!         call date_to_unix(dat,unixtime,ierr) !!         write(*,*)'Unix Epoch time is ',unixtime !!         write(*,*)'ierr is ',ierr !!      end program demo_date_to_unix !! !!     results: !! !!      Today is:2016:7:18:-240:23:44:20:434 !!      Unix Epoch time is    1468899860.4340105 !!      ierr is            0 !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine date_to_unix ( dat , unixtime , ierr ) ! ident_4=\"@(#)M_time::date_to_unix(3f): Convert DAT date-time array to Unix Epoch Time\" integer , intent ( in ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME real ( kind = realtime ), intent ( out ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! return 0 on success, otherwise 1 real ( kind = realtime ) :: julian real ( kind = realtime ), save :: julian_at_epoch logical , save :: first = . true . integer , parameter :: ref ( 8 ) = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Convert zero of Unix Epoch Time to Julian Date and save call date_to_julian ( ref , julian_at_epoch , ierr ) if ( ierr . ne . 0 ) return ! Error first = . false . endif !----------------------------------------------------------------------------------------------------------------------------------- call date_to_julian ( dat , julian , ierr ) if ( ierr . ne . 0 ) return ! Error unixtime = ( julian - julian_at_epoch ) * secday end subroutine date_to_unix !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unix_to_date(3f) - [M_time:UNIX_EPOCH] converts Unix Epoch Time to !!    DAT date-time !!    array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unix_to_date(unixtime,dat,ierr) !! !!     real(kind=realtime),intent(in) :: unixtime !!     integer,intent(out)            :: dat(8) !!     integer,intent(out)            :: ierr !! !!##DESCRIPTION !!   Converts a Unix Epoch Time (UET) to a DAT date-time array. !! !!##OPTIONS !! !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since !!              00:00:00 on January 1st, 1970, UTC; of type !!              real(kind=realtime). !! !!##RETURNS !!     dat      Integer array holding a \"DAT\" array, similar in structure !!              to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!               dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !! !!    ierr      Error code. If 0 no error occurred. !! !!##EXAMPLE !! !!     Sample program: !! !!      program demo_unix_to_date !!      use M_time, only : unix_to_date, u2d, fmtdate, realtime !!      implicit none !!      integer,parameter :: dp=kind(0.0d0) !!      real(kind=realtime)           :: unixtime !!      ! seconds in a day !!      real(kind=realtime),parameter :: DAY=86400.0_dp !!      integer                       :: dat(8) !!      integer                       :: ierr !!         ! sample Unix Epoch time !!         unixtime=1468939038.4639933_dp !!         ! create DAT array for today !!         call unix_to_date(unixtime,dat,ierr) !!         write(*,*)'Sample Date=',fmtdate(dat) !!         ! go back one day !!         call unix_to_date(unixtime-DAY,dat,ierr) !!         ! subtract day and print !!         write(*,*)'Day Before =',fmtdate(dat) !!         ! go forward one day !!         call unix_to_date(unixtime+DAY,dat,ierr) !!         ! add day print !!         write(*,*)'Day After  =',fmtdate(dat) !!      end program demo_unix_to_date !! !!    Results: !! !!     Sample Date=Tuesday, July 19th, 2016 10:37:18 AM !!     Day Before =Monday, July 18th, 2016 10:37:18 AM !!     Day After  =Wednesday, July 20th, 2016 10:37:18 AM !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine unix_to_date ( unixtime , dat , ierr ) ! ident_5=\"@(#)M_time::unix_to_date(3f): Converts Unix Time to DAT date-time array\" class ( * ), intent ( in ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: dat ( 8 ) ! date and time array integer , intent ( out ) :: ierr ! 0 for successful execution, otherwise 1 real ( kind = realtime ) :: julian ! Unix time converted to a Julian Date real ( kind = realtime ) :: local_unixtime real ( kind = realtime ), save :: Unix_Origin_as_Julian ! start of Unix Time as Julian Date logical , save :: first = . TRUE . integer , parameter :: ref ( 8 ) = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] !  Notice that the value UNIXTIME can be any of several types ( INTEGER,REAL,REAL(KIND=REALTIME)) select type ( unixtime ) type is ( integer ); local_unixtime = dble ( unixtime ) type is ( real ); local_unixtime = dble ( unixtime ) ! typically not precise enough for UET values. type is ( real ( kind = realtime )); local_unixtime = unixtime end select !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Initialize calculated constants on first call call date_to_julian ( ref , Unix_Origin_as_Julian , ierr ) ! Compute start of Unix Time as a Julian Date if ( ierr . ne . 0 ) return ! Error first = . FALSE . endif !----------------------------------------------------------------------------------------------------------------------------------- julian = ( local_unixtime / secday ) + Unix_Origin_as_Julian ! convert seconds from Unix Epoch to Julian Date call julian_to_date ( julian , dat , ierr ) ! calculate date-time array from Julian Date !dat(4)=get_timezone()                                          ! need to get time zone end subroutine unix_to_date !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    d2o(3f) - [M_time:ORDINAL_DAY] converts DAT date-time array to Ordinal day !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function d2o(dat) result (ordinal) !! !!     integer,intent(in),optional :: dat(8) !!     integer                     :: ordinal !! !!##DESCRIPTION !!   Given a date in the form of a \"DAT\" array return the Ordinal Day, !!   (ie. \"the day of the year\"). !! !!##OPTIONS !!     dat  Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!              dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !!##RETURNS !!     ordinal  The day of the year calculated for the given input date, !!              where Jan 1st=1. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_d2o !!     use M_time, only : d2o !!     implicit none !!     integer :: dat(8) !!        call date_and_time(values=dat) !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        write(*,*)'Day of year is:',d2o(dat) !! !!        ! year,month,day,timezone,hour,minute,seconds,milliseconds !!        dat=[2020,12,31,-240,12,0,0,0] !!        write(*,*)dat(1),' Days in year is:',d2o(dat) !! !!        dat=[2021,12,31,-240,12,0,0,0] !!        write(*,*)dat(1),' Days in year is:',d2o(dat) !! !!        dat=[2022,12,31,-240,12,0,0,0] !!        write(*,*)dat(1),' Days in year is:',d2o(dat) !! !!        dat=[2023,12,31,-240,12,0,0,0] !!        write(*,*)dat(1),' Days in year is:',d2o(dat) !! !!        dat=[2024,12,31,-240,12,0,0,0] !!        write(*,*)dat(1),' Days in year is:',d2o(dat) !! !!     end program demo_d2o !! !!    results: !! !!     Today is:2016:7:19:-240:20:1:19:829 !!     Day of year is:         201 !!            2020  Days in year is:         366 !!            2021  Days in year is:         365 !!            2022  Days in year is:         365 !!            2023  Days in year is:         365 !!            2024  Days in year is:         366 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function d2o ( dat ) result ( ordinal ) ! ident_6=\"@(#)M_time::d2o(3f): Converts DAT date-time array to Ordinal day\" ! JSU 2015-12-13 integer , intent ( in ), optional :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME integer :: dat_local ( 8 ) integer :: ordinal ! the returned number of days real ( kind = realtime ) :: unixtime ! Unix time (seconds) real ( kind = realtime ) :: unix_first_day integer :: ierr ! return 0 on success, otherwise 1 from date_to_unix(3f) integer :: temp_dat ( 8 ) if ( present ( dat )) then dat_local = dat else dat_local = getnow () endif call date_to_unix ( dat_local , unixtime , ierr ) ! convert date to Unix Epoch Time if ( ierr . ne . 0 ) then call stderr ( '*d2o* bad date array' ) ordinal =- 1 ! initialize to bad value else temp_dat = [ dat_local ( 1 ), 1 , 1 , dat_local ( 4 ), 0 , 0 , 0 , 0 ] call date_to_unix ( temp_dat , unix_first_day , ierr ) ordinal = int (( unixtime - unix_first_day ) / secday ) + 1 endif end function d2o !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    ordinal_seconds(3f) - [M_time:ORDINAL_DAY] seconds since beginning of year !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function ordinal_seconds() !! !!     integer :: ordinal_seconds !!##DESCRIPTION !!   Return number of seconds since beginning of current year. !! !!   Before using this routine consider the consequences if the application !!   is running at the moment a new year begins. !! !!##EXAMPLE !! !!    sample program !! !!     program demo_ordinal_seconds !!     use M_time, only : ordinal_seconds !!     implicit none !!     character(len=1) :: paws !!     integer          :: ios !!     integer          :: istart, iend !!     istart=ordinal_seconds() !!     write(*,'(a)',advance='no')'now pause. Enter return to continue ...' !!     read(*,'(a)',iostat=ios) paws !!     iend=ordinal_seconds() !!     write(*,*)'that took ',iend-istart,'seconds' !!     write(*,*)istart,iend !!     end program demo_ordinal_seconds !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain integer function ordinal_seconds () ! ident_7=\"@(#)M_time::ordinal_seconds(3f): seconds since beginning of year\" integer :: vtime ( 8 ) integer :: year , month , day , hour , minutes , seconds , timezone , milliseconds integer :: ordinal_day_of_year equivalence ( vtime ( 1 ), year ) equivalence ( vtime ( 2 ), month ) equivalence ( vtime ( 3 ), day ) equivalence ( vtime ( 4 ), timezone ) equivalence ( vtime ( 5 ), hour ) equivalence ( vtime ( 6 ), minutes ) equivalence ( vtime ( 7 ), seconds ) equivalence ( vtime ( 8 ), milliseconds ) vtime = getnow () ordinal_day_of_year = d2o ( vtime ) ordinal_seconds = ordinal_day_of_year * 24 * 60 * 60 + hour * 60 * 60 + minutes * 60 + seconds end function ordinal_seconds !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    ordinal_to_date(3f) - [M_time:ORDINAL_DAY] when given a valid year and !!    day of the year returns the DAT array for the date !!    (LICENSE:PD) !!##SYNOPSIS !! !!      subroutine ordinal_to_date(yyyy, ddd, dat) !! !!       integer, intent(in)   :: yyyy !!       integer, intent(in)   :: ddd !!       integer, intent(out)  :: dat !!##DESCRIPTION !!   When given a valid year, YYYY, and day of the year, DDD, returns the !!   date as a DAT date array !!##OPTIONS !!       yyyy  known year !!       ddd   known ordinal day of the year !!##RETURNS !!       dat   DAT array describing the date !!##EXAMPLE !! !!    Sample program: !! !!     program demo_ordinal_to_date !!     use M_time, only : ordinal_to_date !!     implicit none !!     INTEGER            :: yyyy, ddd, mm, dd, yy !!     integer            :: dat(8) !!     integer            :: ios !!       INFINITE: do !!          write(*,'(a)',advance='no')& !!          & 'Enter year YYYY and ordinal day of year DD ' !!          read(*,*,iostat=ios)yyyy,ddd !!          if(ios.ne.0)exit INFINITE !!          ! recover month and day from year and day number. !!          call ordinal_to_date(yyyy, ddd, dat) !!          yy=dat(1) !!          mm=dat(2) !!          dd=dat(3) !!          write(*,'(*(g0))')'For Year ',yyyy,' and Ordinal day ',ddd,  & !!          &         ' Month is ',mm,' and Day of Month is ',dd, & !!          &         ' and Year is ',yy !!        enddo INFINITE !!     end program demo_ordinal_to_date subroutine ordinal_to_date ( yyyy , ddd , dat ) !x!use M_time, only : d2j,j2d, realtime ! ident_8=\"@(#)M_time::ordinal_to_date(3f): given a valid year and day of the year returns the DAT array for the date\" integer :: yyyy integer :: ddd integer :: dat ( 8 ) integer :: temp_dat ( 8 ) !dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] ! find Julian day for first day of given year and add ordinal day -1 and convert back to a DAT temp_dat = [ yyyy , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] dat = j2d ( d2j ( temp_dat ) + real ( ddd - 1 , kind = realtime ) ) end subroutine ordinal_to_date !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    o2d(3f) - [M_time:ORDINAL_DAY] converts Ordinal day to DAT date-time array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function o2d(ordinal,[year]) result (dat) !! !!     integer,intent(in) :: ordinal  ! the day of the year !!     integer,optional   :: year     ! year !!     integer            :: dat(8)   ! date time array !! !!##DESCRIPTION !!   Given an Ordinal day of the year return a date in the form of a !!   \"DAT\" array. !! !!##OPTIONS !!     ordinal  The day of the year for the given year, where Jan 1st=1. !! !!     year     An optional year for the ordinal day. If not present the !!              current year is assumed. !! !!##RETURNS !!     dat   Integer array holding a \"DAT\" array, similar in structure !!           to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!              dat=[ year,month,day,timezone,hour,& !!               & minutes,seconds,milliseconds] !! !!           The timezone value is from the current time on the current !!           platform. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_o2d !!     use M_time, only : o2d,fmtdate !!     implicit none !!     integer :: year !!        do year=2004,2008 !!           write(*,*)& !!           & '100th day of ',year,' is ',fmtdate(o2d(100,year)) !!        enddo !!        write(*,*)'100th day of this year is ',fmtdate(o2d(100)) !!     end program demo_o2d !! !!    results: !! !!     100th day of 2004 is Friday, April 9th, 2004 ... !!     00:00:00 PM UTC-02:40 !!     100th day of 2005 is Sunday, April 10th, 2005 ... !!     00:00:00 PM UTC-02:40 !!     100th day of 2006 is Monday, April 10th, 2006 ... !!     00:00:00 PM UTC-02:40 !!     100th day of 2007 is Tuesday, April 10th, 2007 ... !!     00:00:00 PM UTC-02:40 !!     100th day of 2008 is Wednesday, April 9th, 2008 ... !!     00:00:00 PM UTC-02:40 !!     100th day of this year is Saturday, April 9th, 2016 ... !!     00:00:00 PM UTC-02:40 !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function o2d ( ordinal , year ) result ( dat ) ! ident_9=\"@(#)M_time::o2d(3f): Converts ordinal day to DAT date-time array\" integer :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME integer , intent ( in ) :: ordinal ! the returned number of days integer , optional :: year real ( kind = realtime ) :: unixtime ! Unix time (seconds) integer :: ierr ! return 0 on success, otherwise 1 from date_to_unix(3f) if ( present ( year )) then dat = [ year , 1 , ordinal , get_timezone (), 0 , 0 , 0 , 0 ] ! initialize DAT with parameters and set timezone, set HH:MM:SS.XX to zero else dat = getnow () ! set year and timezone to current values dat = [ dat ( 1 ), 1 , ordinal , dat ( 4 ), 0 , 0 , 0 , 0 ] ! apply ordinal parameter to January of current year, set HH:MM:SS.XX to zero endif ierr = 0 call date_to_unix ( dat , unixtime , ierr ) ! convert date to Unix Epoch Time if ( ierr . ne . 0 ) then call stderr ( '*o2d* bad date array' ) else dat = u2d ( unixtime ) endif end function o2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    v2mo(3f) - [M_time:MONTH_NAME] returns the month name of a Common !!    month number !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function v2mo(imonth) result(month_name) !! !!     integer,intent(in)           :: imonth      ! month number (1-12) !!     character(len=:),allocatable :: month_name  ! month name !! !!##DESCRIPTION !!   Given a Common Calendar month number, return the name of the month !!   as a string. !! !!##OPTIONS !!    imonth      Common month number (1-12). If out of the allowable range !!                the month name returned will be 'UNKNOWN'. !!##RETURNS !!    month_name  A string representing a month name or the word 'UNKNOWN' !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_v2mo !!     use M_time, only : v2mo !!     implicit none !!     integer :: i !!        write(*,*)(v2mo(i),i=1,13) !!     end program demo_v2mo !! !!    results: !! !!     January !!     February !!     March !!     April !!     May !!     June !!     July !!     August !!     September !!     October !!     November !!     December !!     UNKNOWN. !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function v2mo ( imonth ) result ( month_name ) ! ident_10=\"@(#)M_time::v2mo(3f): returns the month name of a Common month number\" ! JSU 2015-12-13 character ( len = :), allocatable :: month_name ! string containing month name or abbreviation. integer , intent ( in ) :: imonth ! the number of the month(1-12) character ( len =* ), parameter :: names ( 12 ) = [ & & 'January  ' , 'February ' , 'March    ' , 'April    ' , 'May      ' , 'June     ' , & & 'July     ' , 'August   ' , 'September' , 'October  ' , 'November ' , 'December ' ] select case ( imonth ) case ( 1 : 12 ); month_name = trim ( names ( imonth )) case default ; month_name = 'UNKNOWN' end select end function v2mo !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    mo2d(3f) - [M_time:MONTH_NAME] given month name return DAT date-time !!    array for beginning of that month in specified year !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!       function mo2d(month_name,year) result (dat) !! !!        character(len=*),intent(in) :: month_name !!        integer,intent(in),optional :: year !!        integer                     :: dat(8) !! !!##DESCRIPTION !!   Given a Common Calendar month name, return the date as a \"DAT\" array !!   for the 1st day of the month. An optional year may be specified. The !!   year defaults to the current year. !! !!##OPTIONS !!    month_name  A string representing a Common Calendar month name. !!    year        Optional year. Defaults to current year !!##RETURNS !!    dat         An integer array that has the same structure as the array !!                returned by the Fortran intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_mo2d !!     use M_time, only : mo2d !!     implicit none !!        write(*,'(*(i0:,\":\"))')mo2d('March') !!     end program demo_mo2d !! !!    results: !! !!       2016:3:1:-240:0:0:0:0 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function mo2d ( month_name , year ) result ( dat ) ! ident_11=\"@(#)M_time::mo2d(3f): month name to DAT date-time array for 1st of that month in specified year\" character ( len =* ), intent ( in ) :: month_name integer , intent ( in ), optional :: year integer :: dat ( 8 ) dat = getnow () if ( present ( year )) then dat ( 1 ) = year endif dat ( 2 ) = mo2v ( month_name ) ! convert given month name to a number if ( dat ( 2 ). le . 0 ) then call stderr ( '*mo2d* bad month name ' // trim ( month_name )) dat ( 2 ) = 1 endif dat ( 3 ) = 1 ! set day to first of month dat ( 5 ) = 0 ! set hour to zero dat ( 6 ) = 0 ! set minutes to zero dat ( 7 ) = 0 ! set seconds to zero dat ( 8 ) = 0 ! set milliseconds to zero end function mo2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    mo2v(3f) - [M_time:MONTH_NAME] given month name return month number !!    (1-12) of that month !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function mo2v(month_name) result(imonth) !! !!      character(len=*),intent(in):: month_name ! month name !!      integer                    :: imonth     ! month number !! !!##DESCRIPTION !!   Given a string representing the name or abbreviation of a Gregorian !!   Calendar month return a number representing the position of the !!   month in the calendar starting with 1 for January and ending with !!   12 for December. !! !!##OPTIONS !!    month_name  name or abbreviation of month. Case is ignored !!                Once enough characters are found to uniquely identify a !!                month the rest of the name is ignored. !!##RETURNS !!    imonth      month number returned. If the name is not recognized a -1 !!                is returned. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_mo2v !!     use M_time, only : mo2v !!     implicit none !!        write(*,*)mo2v(\"April\") !!        write(*,*)mo2v('Apr') !!        ! NOTE: still matches September, as \"SE\" was enough !!        write(*,*)mo2v('sexember') !!        write(*,*)mo2v('unknown')  ! returns -1 !!     end program demo_mo2v !! !!    results: !! !!       >  4 !!       >  4 !!       >  9 !!       > -1 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function mo2v ( month_name ) result ( imonth ) ! ident_12=\"@(#)M_time::mo2v(3f): given month name return month number (1-12) of that month\" ! JSU 2015-12-13 character ( len =* ), intent ( in ) :: month_name ! string containing month name or abbreviation. integer :: imonth ! the number of the month(1-12), or -1 if the name could not be recognized. character ( len = 3 ) :: string string = upper ( month_name ) ! Case is ignored; test string now guaranteed to have three characters imonth = 0 FIND : select case ( string ( 1 : 1 )) ! The month name has to match up to the unique beginning of a month name, and the rest is ignored. case ( 'F' ); imonth = 2 ! February case ( 'S' ); imonth = 9 ! September case ( 'O' ); imonth = 10 ! October case ( 'N' ); imonth = 11 ! November case ( 'D' ); imonth = 12 ! December case default select case ( string ( 1 : 2 )) case ( 'JA' ); imonth = 1 ! JAnuary case ( 'AP' ); imonth = 4 ! APril case ( 'AU' ); imonth = 8 ! AUgust case default select case ( string ( 1 : 3 )) case ( 'MAR' ); imonth = 3 ! MARch case ( 'MAY' ); imonth = 5 ! MAY case ( 'JUN' ); imonth = 6 ! JUNe case ( 'JUL' ); imonth = 7 ! JULy case default imonth =- 1 end select end select end select FIND end function mo2v !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    now(3f) - [M_time:DATE_PRINTING] return string representing current !!    time given format !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function now(format) RESULT (timestr) !! !!     character(len=*),intent(in)     :: format  ! input format string !!     character(len=:),allocatable    :: timestr ! formatted date !! !!##DESCRIPTION !!   The now(3f) function is a call to the fmtdate(3f) function using the !!   current date and time. That is, it is a convenient way to print the !!   current date and time. !! !!##OPTIONS !!     format      string describing how to format the current date and time. !!                 For a complete description of the formatting macros !!                 supported see fmtdate_usage(3f). !!##RETURNS !!     timestr     formatted output string representing date !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_now !!     use M_time, only : now !!     implicit none !!        write(*,*)now(\"The current date is %w, %l %d, %Y %H:%m:%s %N\") !!        call showme() !!     contains !!     subroutine showme() ! see all formatting options !!     use M_time, only : fmtdate_usage !!        call fmtdate_usage() ! see all formatting options !!     end subroutine !!     end program demo_now !! !!    results: !! !!       The current date is Sun, Jul 17th, 2016 01:21:35 PM !!        :: !!        :: description of all formatting options will appear here !!        :: !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function now ( format ) ! ident_13=\"@(#)M_time::now(3f): return string representing current time given format\" ! JSU 2015-10-24 character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: now integer :: values ( 8 ) !----------------------------------------------------------------------------------------------------------------------------------- values = getnow () if ( present ( format )) then now = fmtdate ( values , format ) else now = trim ( fmtdate ( values )) endif end function now !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    fmtdate(3f) - [M_time:DATE_PRINTING] given DAT date-time array return !!    date as string using specified format !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function fmtdate(values,format) RESULT (timestr) !! !!     integer,dimension(8),intent(in)      :: values !!     character(len=*),intent(in),optional :: format !!     character(len=:),allocatable         :: timestr !! !!##DESCRIPTION !!   The fmtdate(3f) procedure lets you reformat a DAT array in !!   many common formats using a special string containing macro names !!   beginning with '%'. To see the allowable macros call or see the !!   fmtdate_usage(3f) routine. !! !!##OPTIONS !!     values   date in a \"DAT\" array, which is the same format as !!              the values returned by the intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!     format   string describing how to format the \"DAT\" array. !!              For a complete description of the formatting macros !!              supported see fmtdate_usage(3f). !!##RETURNS !!     timestr  formatted output string representing date !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_fmtdate !!     use M_time, only : fmtdate !!     implicit none !!     integer :: dat(8) !!        call date_and_time(values=dat) !!        write(*,*)fmtdate(dat,\"current date: %w, %l %d, %Y %H:%m:%s %N\") !!        call showme() !!     contains !!     subroutine showme() !!        use M_time, only : fmtdate_usage !!        call fmtdate_usage() ! see all formatting options !!     end subroutine showme !!     end program demo_fmtdate !! !!    results: !! !!       The current date is Sun, Jul 17th, 2016 01:21:35 PM !!        :: !!        :: An up-to-date description of all the !!        :: formatting options will appear here !!        :: !! !!##AUTHOR !!    John S. Urban, 2015-12-19 !!##LICENSE !!    Public Domain function fmtdate ( values , format ) RESULT ( timestr ) ! ident_14=\"@(#)M_time::fmtdate(3f): given DAT date-time array return date as string using format\" ! JSU 2015-10-24 integer , dimension ( 8 ), intent ( in ) :: values ! numeric time values as DATE_AND_TIME(3f) intrinsic returns character ( len =* ), intent ( in ), optional :: format ! input format string character ( len = :), allocatable :: timestr !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - integer , dimension ( 8 ) :: valloc ! numeric time values as DATE_AND_TIME(3f) intrinsic returns integer , parameter :: longest = 4096 character ( len = 1 ) :: chara ! character being looked at in format string character ( len = 10 ) :: iso_name character ( len = 2 ) :: dayend character ( len = 9 ) :: day ! day of week character ( len = :), allocatable :: local_format character ( len = longest ) :: text ! character array character ( len = longest ) :: xxxx integer :: i , ii , i10 integer :: ierr integer :: iout integer :: iso_year , iso_week , iso_weekday integer :: systemclock , countrate integer :: weekday integer , save :: called = 0 logical :: keyword ! flag that previous character was a % character logical , save :: since = . FALSE . real ( kind = realtime ) :: cputime real ( kind = realtime ) :: julian real ( kind = realtime ) :: unixtime real ( kind = realtime ), save :: unixtime_last valloc = values if ( present ( format )) then local_format = format else local_format = ' ' endif select case ( local_format ) case ( 'iso-8601W' , 'isoweek' ) ; local_format = '%I' ! 2016-W24-5 (yyyy-Www-d) case ( 'iso-8601' , 'iso' ) ; local_format = '%Y-%M-%DT%h:%m:%s%z' ! 2006-08-14T02:34:56-0600 case ( 'sql' ) ; local_format = '\"%Y-%M-%D %h:%m:%s.%x\"' ! case ( 'sqlday' ) ; local_format = '\"%Y-%M-%D\"' ! case ( 'sqltime' ) ; local_format = '\"%h:%m:%s.%x\"' ! case ( 'rfc-2822' ) ; local_format = '%w, %D %l %Y %h:%m:%s %T' ! Mon, 14 Aug 2006 02:34:56 -0600 case ( 'rfc-3339' ) ; local_format = '%Y-%M-%DT%h:%m:%s%z' ! 2006-08-14 02:34:56-06:00 case ( 'suffix' ) ; local_format = '%Y%D%M%h%m%s' ! 20170122210327 case ( 'date' ) ; local_format = '%w %l %D %h:%m:%s UTC%z %Y' ! Mon Jul 25 03:19:21 UTC-4:00 2016 case ( 'short' ) ; local_format = '%w, %l %d, %Y %H:%m:%s %N UTC%z' ! Fri, Jun 17th, 2016 06:31:00 PM UTC-04:00 case ( 'long' ) ; local_format = '%W, %L %d, %Y %H:%m:%s %N UTC%z' ! Friday, June 17th, 2016 06:31:00 PM UTC-04:00 case ( ' ' ) ; local_format = '%W, %L %d, %Y %H:%m:%s %N UTC%z' ! Friday, June 17th, 2016 06:31:00 PM UTC-04:00 case ( 'formal' ) ; local_format = 'The %d of %L %Y' ! The 9th of November 2014 case ( 'lord' ) ; local_format = 'the %d day of %L in the year of our Lord %Y' ! the 9th day of November in the year of our Lord 2014 case ( 'easter' ) call easter ( values ( 1 ), valloc ) ! given year get month and day Easter falls on local_format = \"Easter day: the %d day of %L in the year of our Lord %Y\" case ( 'all' ) local_format = '& & Civil Calendar:%t%W %L %d%n& & Civil Date:%t%t%Y-%M-%D %h:%m:%s %z%n& & Julian Date:%t%t%J%n& & Unix Epoch Time:%t%E%n& & Day Of Year:%t%t%O%n& & ISO-8601 week:%t%t%I& &' case default xxxx = local_format if ( index ( xxxx , '%' ). eq . 0 ) then ! if no % characters try to guess what macros are present call substitute ( xxxx , 'year' , '%Y' ) call substitute ( xxxx , 'month' , '%M' ) call substitute ( xxxx , 'MONTH' , '%L' ) call substitute ( xxxx , 'Month' , '%l' ) call substitute ( xxxx , 'weekday' , '%u' ) call substitute ( xxxx , 'WEEKDAY' , '%W' ) call substitute ( xxxx , 'Weekday' , '%w' ) call substitute ( xxxx , 'today' , '%Y%M%D' ) call substitute ( xxxx , 'day' , '%D' ) call substitute ( xxxx , 'DAY' , '%d' ) call substitute ( xxxx , 'GOOD' , '%N' ) call substitute ( xxxx , 'HOUR' , '%H' ) call substitute ( xxxx , 'hour' , '%h' ) call substitute ( xxxx , 'minute' , '%m' ) call substitute ( xxxx , 'timezone' , '%T' ) call substitute ( xxxx , 'TIMEZONE' , '%z' ) call substitute ( xxxx , 'Timezone' , '%Z' ) call substitute ( xxxx , 'millisecond' , '%x' ) call substitute ( xxxx , 'second' , '%s' ) call substitute ( xxxx , 'epoch' , '%e' ) call substitute ( xxxx , 'julian' , '%j' ) call substitute ( xxxx , 'ordinal' , '%O' ) if ( index ( xxxx , '%' ). eq . 0 ) then ! if no % characters change every char to %char if a format macro letter do i = 65 , 122 select case ( char ( i )) case ( 'B' : 'E' , 'H' : 'J' , 'L' : 'Q' , 'S' , 'T' , 'U' , 'W' , 'Y' , 'Z' , 'b' : 'e' , 'h' : 'm' , 'n' , 'o' : 'q' , 's' : 'u' , 'w' , 'x' , 'z' ) call substitute ( xxxx , char ( i ), '%' // char ( i )) end select enddo endif endif local_format = trim ( xxxx ) end select text = ' ' !  write string, when encounter a percent character do a substitution keyword = . FALSE . iout = 1 do i10 = 1 , len ( local_format ) ! Read the FORMAT string and replace the \"%\" strings per the following rules: chara = local_format ( i10 : i10 ) if ( chara . eq . '%' . and .. not . keyword ) then keyword = . TRUE . cycle endif if ( keyword ) then keyword = . FALSE . select case ( chara ) !===================================================================================== case ( '%' ); write ( text ( iout :), '(A1)' ) chara ! literal percent character !===================================================================================== case ( 'b' ); write ( text ( iout :), '(A1)' ) ' ' ! space character !===================================================================================== case ( 'B' ); write ( text ( iout :), '(A1)' ) '!' ! exclamation (bang) character !===================================================================================== case ( 'c' ); call cpu_time ( cputime ) ! CPU_TIME() write ( text ( iout :), '(G0)' ) cputime !===================================================================================== case ( 'C' ); called = called + 1 ! number of times this routine called write ( text ( iout :), '(I0)' ) called !===================================================================================== case ( 'd' ); ! the day of the month 1st..31st dayend = '  ' select case ( valloc ( 3 )) case ( 1 , 21 , 31 ); dayend = 'st' case ( 2 , 22 ); dayend = 'nd' case ( 3 , 23 ); dayend = 'rd' case ( 4 : 20 , 24 : 30 ); dayend = 'th' case default end select write ( text ( iout :), '(I0,a)' ) valloc ( 3 ), dayend !===================================================================================== case ( 'D' ); write ( text ( iout :), '(I2.2)' ) valloc ( 3 ) ! the day of the month 1..31 !===================================================================================== case ( 'e' ); call date_to_unix ( valloc , unixtime , ierr ) ! integer Unix Epoch time in seconds write ( text ( iout :), '(G0)' ) nint ( unixtime ) !===================================================================================== case ( 'E' ); call date_to_unix ( valloc , unixtime , ierr ) ! Unix Epoch time in seconds write ( text ( iout :), '(G0)' ) unixtime !===================================================================================== case ( 'h' ); write ( text ( iout :), '(I2.2)' ) valloc ( 5 ) ! the hour of the day, in the range of 0 to 23 !===================================================================================== case ( 'H' ); ii = mod ( valloc ( 5 ), 12 ) ! hour of day in range 1..12 if ( ii . eq . 0 ) then ii = 12 endif write ( text ( iout :), '(I0)' ) ii !===================================================================================== case ( 'i' ); call d2w ( valloc , iso_year , iso_week , iso_weekday , iso_name ) ! ISO week of year write ( text ( iout :), '(I0)' ) iso_week !===================================================================================== case ( 'I' ); call d2w ( valloc , iso_year , iso_week , iso_weekday , iso_name ) ! iso-8601 Week-numbering year date write ( text ( iout :), '(a)' ) iso_name !===================================================================================== case ( 'j' ); call date_to_julian ( valloc , julian , ierr ) ! integer Julian Day (truncated to integer) write ( text ( iout :), '(I0)' ) int ( julian ) !===================================================================================== case ( 'J' ); call date_to_julian ( valloc , julian , ierr ) ! Julian Date out to milliseconds !write(text(iout:),'(I0,\".\",i3.3)')int(julian),nint((julian-int(julian))*1000.0) write ( text ( iout :), '(g0)' ) julian !===================================================================================== case ( 'k' ); call system_clock ( count = systemclock , count_rate = countrate ) ! systemclock/countrate write ( text ( iout :), '(G0)' ) real ( systemclock ) / countrate !===================================================================================== case ( 'K' ); call system_clock ( count = systemclock , count_rate = countrate ) ! system clock count write ( text ( iout :), '(I0)' ) systemclock !===================================================================================== case ( 'l' ); write ( text ( iout :), '(A3)' ) v2mo ( valloc ( 2 )) ! three characters of the name of the month of the year !===================================================================================== case ( 'L' ); write ( text ( iout :), '(A)' ) v2mo ( valloc ( 2 )) ! name of the month of the year !===================================================================================== case ( 'm' ); write ( text ( iout :), '(I2.2)' ) valloc ( 6 ) ! the minutes of the hour, in the range 0 to 59 !===================================================================================== case ( 'M' ); write ( text ( iout :), '(I2.2)' ) valloc ( 2 ) ! month of year (1..12) !===================================================================================== case ( 'N' ); if ( valloc ( 5 ). ge . 12 ) then ! AM||PM write ( text ( iout :), '(\"PM\")' ) else write ( text ( iout :), '(\"AM\")' ) endif !===================================================================================== case ( 'n' ); write ( text ( iout :), '(a)' ) new_line ( \"A\" ) !===================================================================================== case ( 'O' ); write ( text ( iout :), '(I3.3)' ) d2o ( valloc ) ! Ordinal day of year !===================================================================================== case ( 'o' ); call date_to_unix ( valloc , unixtime , ierr ) ! integer Unix Epoch time in seconds write ( text ( iout :), '(G0)' ) floor ( unixtime / 86400 ) ! number of whole days since Epoch time !===================================================================================== !===================================================================================== case ( 'p' ); write ( text ( iout :), '(A)' ) phase_of_moon ( valloc ) ! phase of moon !===================================================================================== case ( 'P' ); write ( text ( iout :), '(i0,\"%\")' ) moon_fullness ( valloc ) ! percent of fullness !===================================================================================== case ( 'q' ); write ( text ( iout :), '(\"''\")' ) ! single quote (apostrophe) !===================================================================================== case ( 'Q' ); write ( text ( iout :), '(''\"'')' ) ! double quote !===================================================================================== case ( 's' ); write ( text ( iout :), '(I2.2)' ) valloc ( 7 ) ! the seconds of the minute, in the range 0 to 59 !===================================================================================== case ( 'S' ); if (. not . since ) then ! seconds since last called since = . TRUE . call date_to_unix ( valloc , unixtime_last , ierr ) endif call date_to_unix ( valloc , unixtime , ierr ) write ( text ( iout :), '(G0)' ) unixtime - unixtime_last unixtime_last = unixtime !===================================================================================== case ( 't' ); write ( text ( iout :), '(A1)' ) CHAR ( 9 ) ! tab character !===================================================================================== case ( 'T' ); write ( text ( iout :), '(SP,I3.2,SS,I2.2)' ) int ( valloc ( 4 ) / 60 ), abs ( mod ( valloc ( 4 ), 60 )) ! time from UTC as +-hhmm !===================================================================================== case ( 'U' ); call dow ( valloc , weekday , day , ierr ) write ( text ( iout :), '(I1)' ) mod ( weekday + 7 , 7 ) + 1 ! Return the day of the week, 1..7 Sunday=1 !===================================================================================== case ( 'u' ); call dow ( valloc , weekday , day , ierr ) ! Return the day of the week, 1..7 Monday=1 write ( text ( iout :), '(I1)' ) weekday !===================================================================================== case ( 'W' ); call dow ( valloc , weekday , day , ierr ) ! Return the name of the day of the week write ( text ( iout :), '(a)' ) day !===================================================================================== case ( 'w' ); call dow ( valloc , weekday , day , ierr ) ! Return the first three characters of the day of the week write ( text ( iout :), '(A3)' ) day ( 1 : 3 ) !===================================================================================== case ( 'x' ); write ( text ( iout :), '(I3.3)' ) valloc ( 8 ) ! the milliseconds of the second, in the range 0 to 999 !===================================================================================== case ( 'Y' ); write ( text ( iout :), '(I0.4)' ) valloc ( 1 ) ! the year, including the century (for example, 1990) !===================================================================================== case ( 'Z' ); write ( text ( iout :), '(SP,I5.4)' ) valloc ( 4 ) ! time difference with respect to UTC in minutes !===================================================================================== case ( 'z' ); write ( text ( iout :), '(SP,I3.2,\":\",SS,I2.2)' ) int ( valloc ( 4 ) / 60 ), abs ( mod ( valloc ( 4 ), 60 )) ! time from UTC as +-hh:mm !===================================================================================== case default write ( text ( iout :), '(A1)' ) chara !===================================================================================== end select !===================================================================================== iout = len_trim ( text ) + 1 if ( iout . ge . longest ) exit else write ( text ( iout :), '(A1)' ) chara ; iout = iout + 1 endif enddo timestr = trim ( text ) end function fmtdate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    fmtdate_usage(3f) - [M_time:DATE_PRINTING] display macros recognized !!    by fmtdate(3f) and now(3f) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine fmtdate_usage(indent) !! !!     integer,intent(in),optional      :: indent !! !!##DESCRIPTION !! !!   The fmtdate_usage(3f) subroutine displays the formatting options !!   available for use in procedures such as fmtdate(3f) and now(3f). !!   It is typically used to produce up-to-date help text in commands !!   that use the M_time(3fm) module, so that the formatting information !!   only needs maintained in one place (this routine) and is easily !!   displayed so users can quickly obtain a description of the formatting !!   macros. !! !!##OPTIONS !!     indent      how many spaces to prefix the output with, so that !!                 calling programs can position the output. Default !!                 for this optional parameter is three (3). !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_fmtdate_usage !!     use M_time, only : fmtdate_usage !!     implicit none !!        call fmtdate_usage() ! see all formatting options !!     end program demo_fmtdate_usage !! !!    results (actually call the routine to ensure this is up to date): !! !!     Description                                        Example !! !!     Base time array: !!     (1) %Y -- year, yyyy                                2016 !!     (2) %M -- month of year, 01 to 12                   07 !!     (3) %D -- day of month, 01 to 31                    29 !!         %d -- day of month, with suffix (1st, 2nd,...)  29th !!     (4) %Z -- minutes from UTC                          -0240 !!         %z -- -+hh:mm from UTC                          -04:00 !!         %T -- -+hhmm  from UTC                          -0400 !!     (5) %h -- hours, 00 to 23                           10 !!         %H -- hour (1 to 12, or twelve-hour clock)      10 !!         %N -- midnight< AM <=noon; noon<= PM <midnight  AM !!     (6) %m -- minutes, 00 to 59                         54 !!     (7) %s -- sec, 00 to 59                             08 !!     (8) %x -- milliseconds 000 to 999                   521 !!     Conversions: !!         %E -- Unix Epoch time                           1469804048.5220029 !!         %e -- integer value of Unix Epoch time          1469804049 !!         %J -- Julian  date                              2457599.121 !!         %j -- integer value of Julian Date(Julian Day)  2457599 !!         %O -- Ordinal day (day of year)                 211 !!         %o -- Whole days since Unix Epoch date          17011 !!         %U -- day of week, 1..7 Sunday=1                6 !!         %u -- day of week, 1..7 Monday=1                5 !!         %i -- ISO week of year 1..53                    30 !!         %I -- iso-8601 week-numbering date(yyyy-Www-d)  2016-W30-5 !!      Names: !!         %l -- abbreviated month name                    Jul !!         %L -- full month name                           July !!         %w -- first three characters of weekday         Fri !!         %W -- weekday name                              Friday !!         %p -- phase of moon                             New !!         %P -- percent of way from new to full moon      -1% !!      Literals: !!         %% -- a literal %                               % !!         %t -- tab character !!         %b -- blank character !!         %B -- exclamation(bang) character !!         %n -- new line (system dependent) !!         %q -- single quote (apostrophe) !!         %Q -- double quote !!      Program timing: !!         %c -- CPU_TIME(3f) output                     .21875000000000000 !!         %C -- number of times this routine is used    1 !!         %S -- seconds since last use of this format   .0000000000000000 !!         %k -- time in seconds from SYSTEM_CLOCK(3f)   723258.812 !!         %K -- time in clicks from SYSTEM_CLOCK(3f)    723258812 !! !!    If no percent (%) is found in the format one of several !!    alternate substitutions occurs. !! !!    If the format is composed entirely of one of the following !!    keywords the following substitutions occur: !! !!      \"iso-8601\", !!      \"iso\"        ==> %Y-%M-%DT%h:%m:%s%z !!      \"iso-8601W\", !!      \"isoweek\"    ==> %I 2016-W30-5 !!      \"sql\"        ==> \"%Y-%M-%D %h:%m:%s.%x\" !!      \"sqlday\"     ==> \"%Y-%M-%D\" !!      \"sqltime\"    ==> \"%h:%m:%s.%x\" !!      \"rfc-2822\"   ==> %w, %D %l %Y %h:%m:%s %T !!      \"rfc-3339\"   ==> %Y-%M-%DT%h:%m:%s%z !!      \"date\"       ==> %w %l %D %h:%m:%s UTC%z %Y !!      \"short\"      ==> %w, %l %d, %Y %H:%m:%s %N UTC%z !!      \"long\",\" \"   ==> %W, %L %d, %Y %H:%m:%s %N UTC%z !!      \"suffix\"     ==> %Y%D%M%h%m%s !!      \"formal\"     ==> The %d of %L %Y !!      \"lord\"       ==> the %d day of %L in the year of our Lord %Y !!      \"easter\"     ==> FOR THE YEAR OF THE CURRENT DATE: !!                       Easter day: the %d day of %L in the year of our Lord %Y !!      \"all\"        ==> A SAMPLE OF DATE FORMATS !! !!    otherwise the following words are replaced with the most !!    common macros: !! !!    numeric values: !! !!       year     %Y  2016 !!       month    %M  07 !!       day      %D  29 !!       hour     %h  10 !!       minute   %m  54 !!       second   %s  08 !!       timezone %T  0400 !! !!       epoch    %e  1469804049 !!       julian   %j  2457599 !!       ordinal  %O  211 !!       weekday  %u  5 !! !!    string values: !! !!       MONTH    %L  July !!       Month    %l  Jul !!       WEEKDAY  %W  Thursday !!       Weekday  %w  Thu !!       DAY      %d  7th !!       TIMEZONE %z  -04:00 !!       Timezone %Z  -240 !!       GOOD     %N  AM !!       HOUR     %H  10 !! !!    if none of these keywords are found then every letter that !!    is a macro is assumed to have an implied percent in front !!    of it. For example: !! !!       YMDhms ==> %Y%M%D%h%m%s ==> 20160729105408 !!##AUTHOR !!    John S. Urban, 2015-10-24 !!##LICENSE !!    Public Domain subroutine fmtdate_usage ( indent ) ! ident_15=\"@(#)M_time::fmtdate_usage(3f): display macros recognized by fmtdate(3f)\" integer , intent ( in ), optional :: indent character ( len = 128 ), allocatable :: usage (:) integer :: i , ii character ( len = :), allocatable :: blanks if ( present ( indent )) then ! set indent to passed value or, if value is not present, set indent to 3 ii = indent else ii = 3 endif blanks = repeat ( ' ' , ii ) ! define a prefix string to create specified indent usage = [ CHARACTER ( LEN = 128 ) :: & ! 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890 123456789 123456789 123456789 123456789 12345678 & 'Description                                        Example%b ' ,& & '%b                                                           ' ,& & '%bBase time array:                                           ' ,& & ' (1) %%Y -- year, yyyy                                %Y     ' ,& & ' (2) %%M -- month of year, 01 to 12                   %M     ' ,& & ' (3) %%D -- day of month, 01 to 31                    %D     ' ,& & '     %%d -- day of month, with suffix (1st, 2nd,...)  %d     ' ,& & ' (4) %%Z -- minutes from UTC                          %Z     ' ,& & '     %%z -- -+hh:mm from UTC                          %z     ' ,& & '     %%T -- -+hhmm  from UTC                          %T     ' ,& & ' (5) %%h -- hours, 00 to 23                           %h     ' ,& & '     %%H -- hour (1 to 12, or twelve-hour clock)      %H     ' ,& & '     %%N -- midnight< AM <=noon; noon<= PM <midnight  %N     ' ,& & ' (6) %%m -- minutes, 00 to 59                         %m     ' ,& & ' (7) %%s -- sec, 00 to 59                             %s     ' ,& & ' (8) %%x -- milliseconds 000 to 999                   %x     ' ,& & '%bConversions:                                               ' ,& & '     %%E -- Unix Epoch time                           %E     ' ,& & '     %%e -- integer value of Unix Epoch time          %e     ' ,& & '     %%J -- Julian  date                              %J     ' ,& & '     %%j -- integer value of Julian Date(Julian Day)  %j     ' ,& & '     %%O -- Ordinal day (day of year)                 %O     ' ,& & '     %%o -- Whole days since Unix Epoch date          %o     ' ,& & '     %%U -- day of week, 1..7 Sunday=1                %U     ' ,& & '     %%u -- day of week, 1..7 Monday=1                %u     ' ,& & '     %%i -- ISO week of year 1..53                    %i     ' ,& & '     %%I -- iso-8601 week-numbering date(yyyy-Www-d)  %I     ' ,& & '%b Names:                                                    ' ,& & '     %%l -- abbreviated month name                    %l     ' ,& & '     %%L -- full month name                           %L     ' ,& & '     %%w -- first three characters of weekday         %w     ' ,& & '     %%W -- weekday name                              %W     ' ,& & '     %%p -- phase of moon                             %p     ' ,& & '     %%P -- percent of way from new to full moon      %P     ' ,& & '%b Literals:                                                 ' ,& & '     %%%% -- a literal %%                               %%   ' ,& & '     %%t -- tab character                             %t     ' ,& & '     %%b -- blank character                           %b     ' ,& & '     %%B -- exclamation(bang) character               %B     ' ,& & '     %%n -- new line (system dependent)               %n     ' ,& & '     %%q -- single quote (apostrophe)                 %q     ' ,& & '     %%Q -- double quote                              %Q     ' ,& & '%b Program timing:                                           ' ,& & '     %%c -- CPU_TIME(3f) output                       %c     ' ,& & '     %%C -- number of times this routine is used      %C     ' ,& & '     %%S -- seconds since last use of this format     %S     ' ,& & '     %%k -- time in seconds from SYSTEM_CLOCK(3f)     %k     ' ,& & '     %%K -- time in clicks from SYSTEM_CLOCK(3f)      %K     ' ,& & '%b                                                           ' ,& & '%bIf no percent (%%) is found in the format one of several   ' ,& & '%balternate substitutions occurs.                            ' ,& & '%b                                                           ' ,& & '%bIf the format is composed entirely of one of the following ' ,& & '%bkeywords the following substitutions occur:                ' ,& & '%b  \"iso-8601\",                                              ' ,& & '%b  \"iso\"        ==> %%Y-%%M-%%DT%%h:%%m:%%s%%z             %Y-%M-%DT%h:%m:%s%z     ' ,& & '%b  \"iso-8601W\",                                                                    ' ,& & '%b  \"isoweek\"    ==> %%I                              %I                            ' ,& & '%b  \"sql\"        ==> \"%%Y-%%M-%%D %%h:%%m:%%s.%%x\"          \"%Y-%M-%D %h:%m:%s.%x\"  ' ,& & '%b  \"sqlday\"     ==> \"%%Y-%%M-%%D\"                      \"%Y-%M-%D\"                  ' ,& & '%b  \"sqltime\"    ==> \"%%h:%%m:%%s.%%x\"                   \"%h:%m:%s.%x\"              ' ,& & '%b  \"rfc-2822\"   ==> %%w, %%D %%l %%Y %%h:%%m:%%s %%T        ' ,& & '%b                   %w, %D %l %Y %h:%m:%s %T                ' ,& & '%b  \"rfc-3339\"   ==> %%Y-%%M-%%DT%%h:%%m:%%s%%z             %Y-%M-%DT%h:%m:%s%z     ' ,& & '%b  \"date\"       ==> %%w %%l %%D %%h:%%m:%%s UTC%%z %%Y      ' ,& & '%b                   %w %l %D %h:%m:%s UTC%z %Y              ' ,& & '%b  \"short\"      ==> %%w, %%l %%d, %%Y %%H:%%m:%%s %%N UTC%%z' ,& & '%b                   %w, %l %d, %Y %H:%m:%s %N UTC%z         ' ,& & '%b  \"long\",\" \"   ==> %%W, %%L %%d, %%Y %%H:%%m:%%s %%N UTC%%z' ,& & '%b                   %W, %L %d, %Y %H:%m:%s %N UTC%z         ' ,& & '%b  \"suffix\"     ==> %%Y%%D%%M%%h%%m%%s                    %Y%D%M%h%m%s             ' ,& & '%b  \"formal\"     ==> The %%d of %%L %%Y                 The %d of %L %Y             ' ,& & '%b  \"lord\"       ==> the %%d day of %%L in the year of our Lord %%Y                 ' ,& & '%b                   the %d day of %L in the year of our Lord %Y                    ' ,& & '%b  \"easter\"     ==> FOR THE YEAR OF THE CURRENT DATE:       ' ,& & '%b                     Easter day: the %%d day of %%L in the year of our Lord %%Y   ' ,& & '%b  \"all\"        ==> A SAMPLE OF DATE FORMATS                ' ,& & '%botherwise the following words are replaced with the most   ' ,& & '%bcommon macros:                                             ' ,& & '%b   year          %%Y  %Y                                   ' ,& & '%b   month         %%M  %M                                   ' ,& & '%b   day           %%D  %D                                   ' ,& & '%b   timezone      %%z  %z                                   ' ,& & '%b   hour          %%h  %h                                   ' ,& & '%b   minute        %%m  %m                                   ' ,& & '%b   second        %%s  %s                                   ' ,& & '%b   millisecond   %%x  %x                                   ' ,& & '%b   epoch         %%e  %e                                   ' ,& & '%b   julian        %%j  %j                                   ' ,& & '%b   ordinal       %%O  %O                                   ' ,& & '%b   weekday       %%u  %u                                   ' ,& & '%b   MONTH         %%L  July                                 ' ,& & '%b   Month         %%l  Jul                                  ' ,& & '%b   DAY           %%d  7th                                  ' ,& & '%b   HOUR          %%H  10                                   ' ,& & '%b   GOOD          %%N  AM                                   ' ,& & '%b   Weekday       %%w  Thu                                  ' ,& & '%b   WEEKDAY       %%W  Thursday                             ' ,& & '%b   Timezone      %%Z  -240                                 ' ,& & '%b   TIMEZONE      %%z  -04:00                               ' ,& & '%bif none of these keywords are found then every letter that ' ,& & '%bis a macro is assumed to have an implied percent in front  ' ,& & '%bof it. For example:                                        ' ,& & '%b   YMDhms ==> %%Y%%M%%D%%h%%m%%s ==> %Y%M%D%h%m%s          ' ,& & '%b                                                           ' ] write ( * , '(a,a)' )( blanks ,( trim ( now ( usage ( i )))), i = 1 , size ( usage )) end subroutine fmtdate_usage !----------------------------------------------------------------------------------------------------------------------------------- ! C for reference ! %U     week number of year, with Sunday as first day of week (00..53) ! %Z     alphabetic time zone abbreviation (e.g., EDT) !        By default, date pads numeric fields with zeroes. The following optional flags may follow '%': !        -      (hyphen) do not pad the field !        _      (underscore) pad with spaces !        0      (zero) pad with zeros !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    guessdate(3f) - [M_time:READING_DATES] reads in a date, in various formats !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine guessdate(anot,dat) !! !!     character(len=*),intent(in) :: anot !!     integer,intent(out)         :: dat(8) !! !!##DESCRIPTION !! !!   Read in strings and except for looking for month names remove !!   non-numeric characters and try to convert a string assumed to represent !!   a date to a date-time array. !! !!   Years should always be expressed as four-digit numbers, and except for !!   the special format yyyy-mm-dd the day should come after the year. Named !!   months are preferred. If ambiguous the order is assumed to be day - !!   month - year. Times are assumed to be of the form HH:MM:SS !! !!   It is planned that this routine will be superseded. As an alternative, !!   a C routine exists in the standard C libraries that allows for !!   expansive features when reading dates that can be called via the !!   ISO_C_BINDING interface. !! !!##OPTIONS !!    anot  A string assumed to represent a date including a year, month and day. !! !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_guessdate !!     use M_time, only : guessdate, fmtdate !!     implicit none !!     character(len=20),allocatable :: datestrings(:) !!     character(len=:),allocatable  :: answer !!     integer                       :: dat(8) !!     integer                       :: i !!        datestrings=[ & !!        & 'January 9th, 2001   ',& !!        & ' Tue Jul 19 2016    ',& !!        & ' 21/12/2016         ',& !!        & ' 4th of Jul 2004    ' ] !!        do i=1,size(datestrings) !!           write(*,'(a)')repeat('-',80) !!           write(*,*)'TRYING ',datestrings(i) !!           call guessdate(datestrings(i),dat) !!           write(*,*)'DAT ARRAY ',dat !!           answer=fmtdate(dat) !!           write(*,*)'FOR '//datestrings(i)//' GOT '//trim(answer) !!        enddo !!     end program demo_guessdate !! !!    results: !! !!     --------------------------------------------------------------------- !!     TRYING January 9th, 2001 !!     DAT ARRAY         2001  1  9   -240    0   0   0    0 !!     FOR January 9th, 2001  GOT Tuesday, January 9th, 2001 12:00:00 AM !!     --------------------------------------------------------------------- !!     TRYING  Tue Jul 19 2016 !!     DAT ARRAY         2016  7  19  -240    0   0   0    0 !!     FOR  Tue Jul 19 2016   GOT Tuesday, July 19th, 2016 12:00:00 AM !!     --------------------------------------------------------------------- !!     TRYING  21/12/2016 !!     DAT ARRAY         2016  12 21  -240    0   0   0    0 !!     FOR  21/12/2016        GOT Wednesday, December 21st, 2016 12:00:00 AM !!     --------------------------------------------------------------------- !!     TRYING  4th of Jul 2004 !!     DAT ARRAY         2004  7  4   -240    0   0   0    0 !!     FOR  4th of Jul 2004   GOT Sunday, July 4th, 2004 12:00:00 AM !! !!##LICENSE !!    Public Domain subroutine guessdate ( datestring , dat , ier ) ! ident_16=\"@(#)M_time::guessdate(3f): Guess format of a date string to create a DAT date-time array\" ! partially based on a concept from JRH 1991-03-19 ! JSU, 20160729 ! ! makes an odd number of assumptions trying to guess what date format is being used. If you know the format of your date ! values READ(3f) and parse them directly instead of using this procedure, even though it does a good job with common USA formats. ! !x! REDO more rigorously with regular expressions and recognize standard formats directly ! NOTE : Main constraint is that day is input BEFORE year unless use YYYY-MM-DD and a : implies HH:MM:SS, no timezone names !        Not rigorous. Gets most common formats but can easily make errors in all but simple unambiguous common date formats character ( len =* ), intent ( in ) :: datestring ! Date in string format character ( len = :), allocatable :: datestring_local ! Date in string format character ( len = :), allocatable :: temp integer , intent ( out ) :: dat ( 8 ) integer , optional :: ier integer :: ier_local integer :: iye , mon , idy ! Year, Month, Day integer :: ihr , imi , ise ! Hour, Minute, Second integer :: itz , imill ! Timezone, Milliseconds character ( len = len ( datestring ) * 2 ) :: buff integer :: i , idum , ind logical :: alpha integer :: ios integer :: itries character ( len = 3 ), parameter :: amon ( 12 ) = [ 'JAN' , 'FEB' , 'MAR' , 'APR' , 'MAY' , 'JUN' , 'JUL' , 'AUG' , 'SEP' , 'OCT' , 'NOV' , 'DEC' ] integer , parameter :: idmon ( 12 ) = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] character ( len = :), allocatable :: scratch (:) integer , parameter :: isize = 40 real :: rvalues ( isize ) character ( len = 2 ) :: ampm integer :: iend , inums , ierr logical :: number logical :: verbose integer :: loops dat = getnow () ! get time zone of current process and set defaults iye = dat ( 1 ) mon = dat ( 2 ) idy = dat ( 3 ) itz = dat ( 4 ) ! default is to use current timezone ihr = 0 imi = 0 ise = 0 imill = 0 ier_local = 0 rvalues = 0.0 datestring_local = '' verbose = . false . !----------------------------------------------------------------------------------------------------------------------------------- temp = ' ' // trim ( upper ( datestring )) if ( len ( temp ). ge . 2 ) then if ( temp ( 2 : 2 ). eq . '?' ) then verbose = . true . temp = temp ( 3 :) endif endif if ( verbose ) write ( * , * ) '*guessdate* a ' , temp , '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- number = . false . ! when transition from letter to number add a space do i = 1 , len ( temp ) select case ( temp ( i : i )) case ( 'A' : 'Z' , '/' ) if ( number ) then datestring_local = datestring_local // ' ' endif number = . false . case default number = . true . end select datestring_local = datestring_local // temp ( i : i ) enddo !----------------------------------------------------------------------------------------------------------------------------------- if ( verbose ) write ( * , * ) '*guessdate* b ' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill datestring_local = datestring_local // '                 ' ! pad string so substitute will fit if old string shorter than new string !make sure spaces are around month names call substitute ( datestring_local , 'JANUARY' , ' JAN ' ) call substitute ( datestring_local , 'FEBRUARY' , ' FEB ' ) call substitute ( datestring_local , 'MARCH' , ' MAR ' ) call substitute ( datestring_local , 'APRIL' , ' APR ' ) call substitute ( datestring_local , 'MAY' , ' MAY ' ) call substitute ( datestring_local , 'JUNE' , ' JUN ' ) call substitute ( datestring_local , 'JULY' , ' JUL ' ) call substitute ( datestring_local , 'AUGUST' , ' AUG ' ) call substitute ( datestring_local , 'SEPTEMBER' , ' SEP ' ) call substitute ( datestring_local , 'OCTOBER' , ' OCT ' ) call substitute ( datestring_local , 'NOVEMBER' , ' NOV ' ) call substitute ( datestring_local , 'DECEMBER' , ' DEC ' ) call substitute ( datestring_local , 'SEPT' , ' SEP ' ) call substitute ( datestring_local , 'JAN' , ' JAN ' ) call substitute ( datestring_local , 'FEB' , ' FEB ' ) call substitute ( datestring_local , 'MAR' , ' MAR ' ) call substitute ( datestring_local , 'APR' , ' APR ' ) call substitute ( datestring_local , 'MAY' , ' MAY ' ) call substitute ( datestring_local , 'JUN' , ' JUN ' ) call substitute ( datestring_local , 'JUL' , ' JUL ' ) call substitute ( datestring_local , 'AUG' , ' AUG ' ) call substitute ( datestring_local , 'SEP' , ' SEP ' ) call substitute ( datestring_local , 'OCT' , ' OCT ' ) call substitute ( datestring_local , 'NOV' , ' NOV ' ) call substitute ( datestring_local , 'DEC' , ' DEC ' ) ! assume T[0=9] is from yyyyy-mm-ddThh:mm:ss.xx ISO-8601 format (or SEPTnn,OCTnn AUGUSTnn, where space was added or name changed) call substitute ( datestring_local , 'T0' , ' 0' ) call substitute ( datestring_local , 'T1' , ' 1' ) call substitute ( datestring_local , 'T2' , ' 2' ) call substitute ( datestring_local , 'T3' , ' 3' ) call substitute ( datestring_local , 'T4' , ' 4' ) call substitute ( datestring_local , 'T5' , ' 5' ) call substitute ( datestring_local , 'T6' , ' 6' ) call substitute ( datestring_local , 'T7' , ' 7' ) call substitute ( datestring_local , 'T8' , ' 8' ) call substitute ( datestring_local , 'T9' , ' 9' ) call substitute ( datestring_local , ': ' , ':' ) call substitute ( datestring_local , ' :' , ':' ) if ( verbose ) write ( * , * ) '*guessdate* A ' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- call substitute ( datestring_local , 'UTC' , ' ' ) !----------------------------------------------------------------------------------------------------------------------------------- call split ( datestring_local , scratch , ' ;,\"''' ) if ( verbose ) write ( * , * ) '*guessdate* B ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! a leading +/- is assumed to be a timezone if ( index ( \"+-\" , scratch ( i )( 1 : 1 )) . ne . 0 ) then if ( index ( scratch ( i ), ':' ). ne . 0 ) then ! assumed to be +-hh:mm call string_to_values ( scratch ( i ), isize , rvalues , inums , ':' , ierr ) if ( inums . ge . 2 ) then itz = 60 * nint ( rvalues ( 1 )) + nint ( rvalues ( 2 )) elseif ( inums . eq . 1 ) then itz = 60 * nint ( rvalues ( 1 )) endif else ! assumed to be +-mm itz = nint ( s2v ( scratch ( i ))) endif scratch ( i ) = ' ' endif enddo if ( verbose ) write ( * , * ) '*guessdate* C ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! AM and PM are assumed to only occur significantly (not end of day or month name, ...) if ( len_trim ( scratch ( i )). ge . 2 ) then iend = len_trim ( scratch ( i )) ampm = scratch ( i )( iend - 1 : iend ) select case ( ampm ) case ( 'AM' ) call substitute ( scratch ( i ), 'AM' , ':' ) case ( 'PM' ) ihr = ihr + 12 call substitute ( scratch ( i ), 'PM' , ':' ) end select endif enddo if ( verbose ) write ( * , * ) '*guessdate* E ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! look for HH:MM:SS if ( index ( scratch ( i ), ':' ). ne . 0 ) then buff = scratch ( i ) call substitute ( buff , '-' , ' -' ) call substitute ( buff , '+' , ' +' ) call string_to_values ( buff , isize , rvalues , inums , ':/' , ierr ) if ( inums . ge . 1 ) ihr = ihr + nint ( rvalues ( 1 )) if ( inums . ge . 2 ) imi = nint ( rvalues ( 2 )) if ( inums . ge . 3 ) ise = nint ( rvalues ( 3 )) if ( inums . ge . 4 ) itz = nint ( rvalues ( 4 )) scratch ( i ) = ' ' endif enddo if ( verbose ) write ( * , * ) '*guessdate* F ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- do i = 1 , size ( scratch ) ! assume yyyy-mm-dd if found a dash if ( index ( scratch ( i ), \"-\" ). ne . 0 ) then call string_to_values ( scratch ( i ), isize , rvalues , inums , '-' , ierr ) select case ( inums ) case ( 3 ) iye = nint ( rvalues ( 1 )) mon = nint ( rvalues ( 2 )) idy = nint ( rvalues ( 3 )) scratch ( i ) = v2s ( nint ( rvalues ( 3 ))) // ' ' // v2s ( nint ( rvalues ( 2 ))) // ' ' // v2s ( nint ( rvalues ( 1 ))) case ( 2 ) iye = nint ( rvalues ( 1 )) mon = nint ( rvalues ( 2 )) scratch ( i ) = v2s ( nint ( rvalues ( 2 ))) // ' ' // v2s ( nint ( rvalues ( 1 ))) case default end select endif enddo if ( verbose ) write ( * , * ) '*guessdate* D ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- datestring_local = '' do i = 1 , size ( scratch ) datestring_local = datestring_local // ' ' // adjustl ( trim ( scratch ( i ))) enddo if ( verbose ) write ( * , * ) '*guessdate* G ' ,( trim ( scratch ( i )), '|' , i = 1 , size ( scratch )), '::' , iye , mon , idy , itz , ihr , imi , ise , imill !----------------------------------------------------------------------------------------------------------------------------------- if ( datestring_local . eq . ' ' ) then loops = 0 else loops = 1000 endif if ( verbose ) write ( * , * ) '*guessdate* Ga' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill , loops INFINITE : do itries = 1 , loops ! give up after 1000 passes buff = datestring_local ! copy to buffer alpha = . false . do i = 1 , 12 ind = index ( buff , amon ( i )) if ( ind . ne . 0 ) then ! Found a matching month mon = i buff ( ind : ind + 2 ) = '   ' ! Delete month alpha = . true . ! Alphabetic month exit endif enddo do i = 1 , len ( buff ) ! First remove all non-numeric characters idum = ichar ( buff ( i : i )) if ( idum . lt . 4 8. or . idum . gt . 57 ) then buff ( i : i ) = ' ' endif enddo if ( alpha ) then ! Alphabetic month read ( buff , * , iostat = ios ) idy , iye if ( ios . ne . 0 ) cycle INFINITE else read ( buff , * , iostat = ios ) idy , mon , iye if ( ios . ne . 0 ) cycle INFINITE endif !x!if(iye.le.99)then !x!   iye=iye+2000                                       ! Cope with two digit year (assume 21st century.) !x!endif if ( mon . lt . 1. or . mon . gt . 12 ) cycle INFINITE ! Check range of months if ( mon . eq . 2 ) then ! Special check for Feb. if (( iye / 4 ) * 4. eq . iye ) then ! Leap year if ( idy . lt . 1. or . idy . gt . 29 ) cycle INFINITE else ! Non-leap year if ( idy . lt . 1. or . idy . gt . 28 ) cycle INFINITE endif else if ( idy . lt . 1. or . idy . gt . idmon ( mon )) cycle INFINITE ! Error ..... re-input endif exit enddo INFINITE if ( verbose ) write ( * , * ) '*guessdate* H ' , datestring_local , '::' , iye , mon , idy , itz , ihr , imi , ise , imill if ( itries . ge . 1000 ) then write ( * , * ) '*guessdate* ERROR: could not extract date for ' // trim ( datestring ) endif dat ( 1 ) = iye dat ( 2 ) = mon dat ( 3 ) = idy dat ( 4 ) = itz dat ( 5 ) = ihr dat ( 6 ) = imi dat ( 7 ) = ise dat ( 8 ) = imill if ( present ( ier )) ier = ier_local end subroutine guessdate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    dow(3f) - [M_time:DAY_OF_WEEK] given a date-time array DAT return !!    the day of the week !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine dow(values, weekday, day, ierr) !! !!     integer,intent(in) :: values(8) !!     integer,intent(out),optional :: weekday !!     character(len=*),intent(out),optional :: day !!     integer,intent(out),optional :: ierr !! !!##DESCRIPTION !!   Given a date array DAT !!   return the day of the week as a number and a name, Mon=1. !! !!##OPTIONS !!    values   \"DAT\" array (an integer array of the same format as !!             the array returned by the intrinsic DATE_AND_TIME(3f)) !!             describing the date to be used to calculate the day !!             of the week. !!##RETURNS !!    weekday  The numeric day of the week, starting with Monday=1. !!             Optional. !!    day      The name of the day of the week. !!             Optional. !!    ierr     Error code !! !!             o [ 0] correct !!             o [-1] invalid input date !!             o [-2] neither day nor weekday !!               return values were requested. !! !!             If the error code is not returned and an error occurs, !!             the program is stopped. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_dow !!     use M_time, only : dow !!     implicit none !!     integer          :: dat(8)     ! input date array !!     integer          :: weekday !!     character(len=9) :: day !!     integer          :: ierr !!       call date_and_time(values=dat) !!       call dow(dat, weekday, day, ierr) !!       write(*,'(a,i0)')'weekday=',weekday !!       write(*,'(a,a)')'day=',trim(day) !!       write(*,'(a,i0)')'ierr=',ierr !!     end program demo_dow !! !!    results: !! !!     weekday=1 !!     day=Monday !!     ierr=0 !!##AUTHOR !!    John S. Urban, 2015-12-19 !!##LICENSE !!    Public Domain subroutine dow ( values , weekday , day , ierr ) ! ident_17=\"@(#)M_time::dow(3f): Given DAT date-time array return the day of the week\" integer , intent ( in ) :: values ( 8 ) ! date and time array used to get time zone integer , intent ( out ), optional :: weekday ! The day of the week, 1 = Monday, 7 = Sunday character ( len =* ), intent ( out ), optional :: day ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9 integer , intent ( out ), optional :: ierr ! Error code,0=correct,-1=invalid input date,-2=neither day nor weekday specified real ( kind = realtime ) :: julian ! the Julian Date for which the weekday is required, integer :: iweekday integer :: ierr_local call date_to_julian ( values , julian , ierr_local ) ! need Julian Date to calculate day of week for first day of month ierr_local = 0 iweekday = 0 ! bad value. if ( julian < 0 ) then ierr_local = - 1 elseif (. not . present ( day ). and . . not . present ( weekday )) then ierr_local =- 2 else ! Julian Day is in Z time zone and starts at noon so add 1/2 day; and add time zone iweekday = mod ( int (( julian + dble ( values ( 4 ) / 6 0.0_dp / 2 4.0_dp ) + 0.5_dp ) + 1.0_dp ), 7 ) iweekday = iweekday + 1 ! change range from 0 to 6 to 1 to 7 iweekday = mod ( iweekday + 5 , 7 ) + 1 ! change from Sunday=1 to Monday=1 if ( present ( day )) then select case ( iweekday ) case ( 1 ) ; day = 'Monday' case ( 2 ) ; day = 'Tuesday' case ( 3 ) ; day = 'Wednesday' case ( 4 ) ; day = 'Thursday' case ( 5 ) ; day = 'Friday' case ( 6 ) ; day = 'Saturday' case ( 7 ) ; day = 'Sunday' case default ; day = 'error' end select endif endif if ( present ( ierr )) then ierr = ierr_local elseif ( ierr_local . ne . 0 ) then write ( * , * ) '*dow* Unprocessed Error ' , ierr_local , ' stopping.' stop 2 endif if ( present ( weekday )) then weekday = iweekday endif end subroutine dow !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    d2w(3f) - [M_time:WEEK_OF_YEAR] calculate iso-8601 Week-numbering !!    year date yyyy-Www-d given DAT date-time array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine d2w(dat,iso_year,iso_week,iso_weekday,iso_name) !! !!     integer,intent(in)              :: dat(8)     ! input date array !!     integer,intent(out)             :: iso_year, iso_week, iso_weekday !!     character(len=10),intent(out)   :: iso_name !! !!##DESCRIPTION !!   Given a \"DAT\" array defining a date and time, return the ISO-8601 !!   Week in two formats -- as three integer values defining the ISO year, !!   week of year and weekday; and as a string of the form \"yyyy-Www-d\". !! !!##OPTIONS !!    dat          \"DAT\" array (an integer array of the same format as !!                 the array returned by the intrinsic DATE_AND_TIME(3f)) !!                 describing the date, which is the basic time description !!                 used by the other M_time(3fm) module procedures. !!##RETURNS !!    iso_year     ISO-8601 year number for the given date !!    iso_week     ISO-8601 week number for the given date !!    iso_weekday  ISO-8601 weekday number for the given date !!    iso_name     ISO-8601 Week string for the data in the form \"yyyy-Www-d\". !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_d2w !!     use M_time, only : d2w !!     implicit none !!     integer           :: dat(8)     ! input date array !!     integer           :: iso_year, iso_week, iso_weekday !!     character(len=10) :: iso_name !!        call date_and_time(values=dat) !!        call d2w(dat,iso_year,iso_week,iso_weekday,iso_name) !!        write(*,'(\"ISO-8601 Week:   \",a)')iso_name !!        write(*,'(a,i0)')'ISO-8601 year    ',iso_year !!        write(*,'(a,i0)')'ISO-8601 week    ',iso_week !!        write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday !!     end program demo_d2w !! !!    results: !! !!     ISO-8601 Week:   2016-W29-1 !!     ISO-8601 year    2016 !!     ISO-8601 week    29 !!     ISO-8601 weekday 1 !! !!##DEFINITION !!   The ISO-8601 date and time standard was issued by the International !!   Organization for Standardization (ISO). It is used (mainly) in !!   government and business for fiscal years, as well as in timekeeping. !!   The system specifies a week year atop the Gregorian calendar by defining !!   a notation for ordinal weeks of the year. !! !!   o An ISO week-numbering year (also called ISO year informally) has 52 !!     or 53 full weeks. That is 364 or 371 days instead of the usual 365 !!     or 366 days. !!   o The extra week is referred to here as a leap week, although ISO-8601 !!     does not use this term.  Weeks start with Monday. !!   o The first week of a year is the week that contains the first Thursday !!     of the year (and, hence, always contains 4 January).  ISO week year !!     numbering therefore slightly deviates from the Gregorian for some days !!     close to January 1st. !! !!##CALCULATION !!   The ISO-8601 week number of any date can be calculated, given its !!   ordinal date (i.e. position within the year) and its day of the week. !! !!##METHOD !!     Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday), !!     subtract the weekday from the ordinal date, then add 10. Divide the !!     result by 7. Ignore the remainder; the quotient equals the week !!     number. If the week number thus obtained equals 0, it means that !!     the given date belongs to the preceding (week-based) year. If a !!     week number of 53 is obtained, one must check that the date is not !!     actually in week 1 of the following year. !! !!     These two statements are assumed true when correcting the dates !!     around January 1st: !! !!     o The number of weeks in a given year is equal to the corresponding !!       week number of 28 December. !!     o January 4th is always in the first week. !! !!##ISO_NAME !!   Week date representations are in the format YYYYWww-D. !! !!     o [YYYY] indicates the ISO week-numbering year which is slightly !!       different from the traditional Gregorian calendar year. !!     o [Www] is the week number prefixed by the letter W, from W01 !!       through W53. !!     o [D] is the weekday number, from 1 through 7, beginning with Monday !!       and ending with Sunday. !! !!   For example, the Gregorian date 31 December 2006 corresponds to the !!   Sunday of the 52nd week of 2006, and is written !! !!     2006-W52-7 (extended form) !!     or !!     2006W527 (compact form). !! !!##REFERENCE !!    From Wikipedia, the free encyclopedia 2015-12-19 !! !!##AUTHOR !!    John S. Urban, 2015-12-19 !!##LICENSE !!    Public Domain subroutine d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) ! ident_18=\"@(#)M_time::d2w(3f): DAT date-time array to iso-8601 Week-numbering year date yyyy-Www-d\" integer , intent ( in ) :: dat ( 8 ) ! input date array integer , intent ( out ) :: iso_year , iso_week , iso_weekday character ( len = 10 ), intent ( out ) :: iso_name integer :: shared_weekday integer :: last_week_this_year integer :: dec28_lastyear ( 8 ) ! December 28th is always in last week integer :: dec28_thisyear ( 8 ) ! December 28th is always in last week character ( len = 9 ) :: day integer :: ierr iso_year = dat ( 1 ) ! initially assume the iso_year is the same as the data array year iso_week = uncorrected_week_of_year ( dat ) ! this is the week number unless around January 1st iso_weekday = shared_weekday ! this is the number of the day of the week assuming Monday=1 dec28_thisyear = [ dat ( 1 ), 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week; use this to get number of weeks last_week_this_year = uncorrected_week_of_year ( dec28_thisyear ) ! get the number of the last week of the year (52 or 53) ! correct dates around January 1st if ( iso_week < 1 ) then ! if week < 1 then week = lastWeek(year -1) dec28_lastyear = [ dat ( 1 ) - 1 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week, we want its week number iso_week = uncorrected_week_of_year ( dec28_lastyear ) ! got the week number for the last week of last year (52 or 53) iso_year = dat ( 1 ) - 1 ! our date belongs to last year elseif ( iso_week > last_week_this_year ) then ! if week > lastweek(year) then week = 1 iso_week = iso_week - last_week_this_year ! our date belongs to next year iso_year = dat ( 1 ) + 1 endif write ( iso_name , '(i4.4,\"-W\",i2.2,\"-\",i1)' ) iso_year , iso_week , iso_weekday ! create ISO string designation for our date contains function uncorrected_week_of_year ( datin ) implicit none integer :: uncorrected_week_of_year integer , intent ( in ) :: datin ( 8 ) integer :: ordinal call dow ( datin , shared_weekday , day , ierr ) ! formula needs day of week 1..7 where Monday=1 ordinal = d2o ( datin ) ! formula needs ordinal day of year where Jan 1st=1 uncorrected_week_of_year = ( ordinal - shared_weekday + 10 ) / 7 end function uncorrected_week_of_year end subroutine d2w !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    w2d(3f) - [M_time:WEEK_OF_YEAR] calculate DAT date-time array from iso-8601 !!    Week-numbering year date yyyy-Www-d !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine w2d(iso_year,iso_week,iso_weekday,dat) !! !!     integer,intent(in)      :: iso_year, iso_week, iso_weekday !!     integer,intent(out)     :: dat(8)     ! output date array !! !!##DESCRIPTION !!   Given an ISO-8601 week return a \"DAT\" array defining a date and time, !!   The ISO-8601 is supplied as three integer values defining the ISO !!   year, week of year and weekday. !! !!##OPTIONS !!    iso_year     ISO-8601 year number for the given date !!    iso_week     ISO-8601 week number for the given date !!    iso_weekday  ISO-8601 weekday number for the given date !!    iso_name     ISO-8601 Week string for the data in the form \"yyyy-Www-d\". !! !!##RETURNS !!    dat          \"DAT\" array (an integer array of the same format as !!                 the array returned by the intrinsic DATE_AND_TIME(3f)) !!                 describing the date to be used, which is the basic !!                 time description used by the other M_time(3fm) module !!                 procedures. !! !!##EXAMPLE !! !! !!  Sample program: !! !!     program demo_w2d !!     use M_time, only : w2d, fmtdate !!     implicit none !!       write(*,'(a)')& !!       & 'Given Monday 29 December 2008 is written \"2009-W01-1\"' !!       call printit(2009,1,1) !!       write(*,'(a)')& !!       & 'Given Sunday 3 January 2010 is written \"2009-W53-7\"' !!       call printit(2009,53,7) !!       write(*,'(a)')& !!       & 'Given the Gregorian date Sun 31 December 2006 & !!       &is written 2006-W52-7' !!       call printit(2006,52,7) !!       write(*,'(a)')& !!       & 'Given 27 September 2008 is 2008-W39-6' !!       call printit(2008,39,6) !!     contains !!     subroutine printit(iso_year,iso_week,iso_weekday) !!     ! ISO-8601 Week: 2016-W29-1 !!     integer  :: iso_year, iso_week, iso_weekday !!     ! input date array !!     integer  :: dat(8) !!      call w2d(iso_year,iso_week,iso_weekday,dat) !!      write(*,'(a,i0)')'GIVEN:           ' !!      write(*,'(a,i0)')'ISO-8601 year    ',iso_year !!      write(*,'(a,i0)')'ISO-8601 week    ',iso_week !!      write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday !!      write(*,'(a,i0)')'RESULT:          ' !!      write(*,'(a,*(i0:,\",\"))')'   DAT array        ',dat !!      write(*,'(a,/,67(\"=\"))')'    '//fmtdate(dat,'long') !!     end subroutine printit !!    end program demo_w2d !! !!  Results: !! !!     Given Monday 29 December 2008 is written \"2009-W01-1\" !!     GIVEN: !!     ISO-8601 year    2009 !!     ISO-8601 week    1 !!     ISO-8601 weekday 1 !!     RESULT: !!        DAT array        2008,12,29,-240,0,0,0,0 !!         Monday, December 29th, 2008 12:00:00 AM UTC-04:00 !!     ========================================================= !!     Given Sunday 3 January 2010 is written \"2009-W53-7\" !!     GIVEN: !!     ISO-8601 year    2009 !!     ISO-8601 week    53 !!     ISO-8601 weekday 7 !!     RESULT: !!        DAT array        2010,1,3,-240,0,0,0,0 !!         Sunday, January 3rd, 2010 12:00:00 AM UTC-04:00 !!     ========================================================= !!     Given the Gregorian date Sun 31 December 2006 is written 2006-W52-7 !!     GIVEN: !!     ISO-8601 year    2006 !!     ISO-8601 week    52 !!     ISO-8601 weekday 7 !!     RESULT: !!        DAT array        2006,12,31,-240,0,0,0,0 !!         Sunday, December 31st, 2006 12:00:00 AM UTC-04:00 !!     ========================================================= !!     Given 27 September 2008 is 2008-W39-6 !!     GIVEN: !!     ISO-8601 year    2008 !!     ISO-8601 week    39 !!     ISO-8601 weekday 6 !!     RESULT: !!        DAT array        2008,9,27,-240,0,0,0,0 !!         Saturday, September 27th, 2008 12:00:00 AM UTC-04:00 !!     ========================================================= !! !!##DEFINITION !!   The ISO-8601 date and time standard was issued by the International !!   Organization for Standardization (ISO). It is used (mainly) in !!   government and business for fiscal years, as well as in timekeeping. !!   The system specifies a week year atop the Gregorian calendar by !!   defining a notation for ordinal weeks of the year. !! !!   An ISO week-numbering year (also called ISO year informally) has !!   52 or 53 full weeks. That is 364 or 371 days instead of the usual !!   365 or 366 days. The extra week is referred to here as a leap week, !!   although ISO-8601 does not use this term. Weeks start with Monday. !!   The first week of a year is the week that contains the first Thursday !!   of the year (and, hence, always contains 4 January). ISO week year !!   numbering therefore slightly deviates from the Gregorian for some !!   days close to January 1st. !! !!##METHOD !!     Calculating a date given the year, week number and weekday !! !!     This method requires that one know the weekday of 4 January of the !!     year in question. Add 3 to the number of this weekday, giving a !!     correction to be used for dates within this year. !! !!     Method: Multiply the week number by 7, then add the weekday. From !!     this sum subtract the correction for the year. The result is the !!     ordinal date, which can be converted into a calendar date.  If the !!     ordinal date thus obtained is zero or negative, the date belongs to !!     the previous calendar year; if greater than the number of days in !!     the year, to the following year. !! !!     Example: year 2008, week 39, Saturday (day 6) !!     Correction for 2008: 5 + 3 = 8 !!     (39 x 7) + 6 = 279 !!     279 - 8 = 271 !!     Ordinal day 271 of a leap year is day 271 - 244 = 27 September !!     Result: 27 September 2008 !! !!##ISO_NAME !!   Week date representations are in the format YYYYWww-D. !! !!     o [YYYY] indicates the ISO week-numbering year which is slightly !!       different from the traditional Gregorian calendar year. !!     o [Www] is the week number prefixed by the letter W, from W01 !!       through W53. !!     o [D] is the weekday number, from 1 through 7, beginning with Monday !!       and ending with Sunday. !! !!   For example, the Gregorian date 31 December 2006 corresponds to the !!   Sunday of the 52nd week of 2006, and is written !! !!     2006-W52-7 (extended form) !!     or !!     2006W527 (compact form). !! !!##REFERENCE !!    From Wikipedia, the free encyclopedia 2016-08-08 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain !----------------------------------------------------------------------------------------------------------------------------------- subroutine w2d ( iso_year , iso_week , iso_weekday , dat ) ! ident_19=\"@(#)M_time::w2d(3f): convert iso-8601 Week-numbering year date yyyy-Www-d to DAT date-time array\" integer , intent ( in ) :: iso_year , iso_week , iso_weekday integer , intent ( out ) :: dat ( 8 ) ! output date array integer :: jan4weekday integer :: correction integer :: ordinal integer :: ierr integer :: temp_dat ( 8 ) temp_dat = [ iso_year , 1 , 4 , 0 , 12 , 0 , 0 , 0 ] call dow ( temp_dat , jan4weekday , ierr = ierr ) ! get day of week for January 4th where Sun=1 correction = jan4weekday + 3 ! calculate correction ordinal = iso_week * 7 + iso_weekday - correction ! calculate ordinal day dat = o2d ( ordinal , iso_year ) ! convert ordinal to DAT (routine works with negative values or days past year end) end subroutine w2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    box_month(3f) - [M_time:DATE_PRINTING] create specified month in a !!    character array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine box_month(dat,calen) !! !!     integer,intent(in)    :: dat(8) !!     character(len=21)     :: calen(8) !! !!##DESCRIPTION !!   box_month(3f) uses a year and month from a date array to populate !!   a small character array with a calendar representing the month. !! !!##OPTIONS !!    dat  \"DAT\" array (an integer array of the same format as !!          the array returned by the intrinsic DATE_AND_TIME(3f)) !!          describing the date to be used to specify what calendar !!          month to produce. !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !!##RETURNS !!    calen  returned character array holding a display of the !!           specified month !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_box_month !!     use M_time, only : box_month !!     implicit none !!     integer           :: dat(8) !!     character(len=21) :: calendar(8) !!        call date_and_time(values=dat) !!        call box_month(dat,calendar) !!        write(*,'(a)')calendar !!     end program demo_box_month !! !!    results: !! !!      >     July 2016 !!      >Mo Tu We Th Fr Sa Su !!      >             1  2  3 !!      > 4  5  6  7  8  9 10 !!      >11 12 13 14 15 16 17 !!      >18 19 20 21 22 23 24 !!      >25 26 27 28 29 30 31 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain subroutine box_month ( dat , calen ) ! ident_20=\"@(#)M_time::box_month(3f): generate month specified by DAT date-time array in character array\" integer , parameter :: wklen = 3 * 7 !----------------------------------------------------------------------------------------------------------------------------------- ! uses year and month from date array DAT to populate a small character array with a calendar representing the month integer , intent ( in ) :: dat ( 8 ) character ( len = wklen ) :: calen ( 8 ) !----------------------------------------------------------------------------------------------------------------------------------- real ( kind = realtime ) :: julian integer :: weekday integer :: dat_1st ( 8 ) integer :: dat_nextday ( 8 ) integer :: location , ierr , i !----------------------------------------------------------------------------------------------------------------------------------- calen (:) = '                    ' ! initialize output array to spaces dat_1st = [ dat ( 1 ), dat ( 2 ), 1 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! create date array for first day in month specified call dow ( dat_1st , weekday , ierr = ierr ) ! return the day of the week for first of month !----------------------------------------------------------------------------------------------------------------------------------- calen ( 1 ) = adjustc ( v2mo ( dat ( 2 )) // ' ' // v2s ( dat ( 1 )), len ( calen ( 1 ))) ! build first line with month and year centered calen ( 2 ) = 'Mo Tu We Th Fr Sa Su' ! build second line with days of week !----------------------------------------------------------------------------------------------------------------------------------- location = 1 + (( weekday - 1 ) * 3 ) ! if data were one row where would 3-character day value start? call date_to_julian ( dat_1st , julian , ierr ) ! get Julian Date for 1st day of month MNTH : do i = 1 , 31 ! put dates into rest of array starting at third line write ( calen ( location / wklen + 3 )( mod ( location , wklen ):), '(i2)' ) i if ( i . ge . 28 ) then ! is tomorrow in another month? call julian_to_date ( julian + i , dat_nextday , ierr ) if ( dat_nextday ( 2 ). ne . dat ( 2 )) then exit MNTH endif endif location = location + 3 enddo MNTH !----------------------------------------------------------------------------------------------------------------------------------- end subroutine box_month !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    d2j(3f) - [M_time:JULIAN] given DAT date-time array returns Julian Date !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function d2j(dat) result (julian) !! !!     integer,intent(in)  :: dat(8) !!     real(kind=realtime) :: julian !! !!##DESCRIPTION !!   Given DAT date-time array returns Julian Date !! !!##OPTIONS !!    dat       Integer array holding a \"DAT\" array, similar in structure !!              to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!              If not present, use current time. !!##RETURNS !!    julian    The Julian Date. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_d2j !!     use M_time, only : d2j !!     implicit none !!     integer :: dat(8) !!        call date_and_time(values=dat) !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        write(*,*)'Julian Date is ',d2j(dat) !!     end program demo_d2j !! !!    results: !! !!     Today is:2016:7:19:-240:2:11:50:885 !!     Julian Date is    2457588.7582278359 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function d2j ( dat ) result ( julian ) ! ident_21=\"@(#)M_time::d2j(3f): Given DAT date-time array returns Julian Date\" integer , intent ( in ), optional :: dat ( 8 ) real ( kind = realtime ) :: julian integer :: ierr integer :: dat_local ( 8 ) if ( present ( dat )) then ! if dat array is present use value contained in it call date_to_julian ( dat , julian , ierr ) else ! if dat array is not present create one containing current time dat_local = getnow () call date_to_julian ( dat_local , julian , ierr ) endif end function d2j !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    j2d(3f) - [M_time:JULIAN] given a JED (Julian Ephemeris Date) returns a !!    date-time array DAT. !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function j2d(julian) result (dat) !! !!     real(kind=realtime),intent(in),optional :: julian !!     integer                                 :: dat(8) !! !!##DESCRIPTION !!   Converts a Julian Ephemeris Date to a DAT date-time array. !! !!##OPTIONS !!    julian  A Julian Ephemeris Date (JED) is the number of days since !!            noon (not midnight) on January 1st, 4713 BC. !!            If not present, use current time. !! !!##RETURNS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_j2d !!     use M_time, only : j2d, d2j, fmtdate, realtime !!     implicit none !!     integer,parameter :: dp=kind(0.0d0) !!     real(kind=realtime) :: today !!     integer :: dat(8) !!        call date_and_time(values=dat) ! get the date using intrinsic !!        today=d2j(dat)                  ! convert today to Julian Date !!        write(*,*)'Today=',fmtdate(j2d(today)) !!        ! math is easy with Julian Days and Julian Dates !!        write(*,*)'Yesterday=',fmtdate(j2d(today-1.0_dp)) !!        write(*,*)'Tomorrow=',fmtdate(j2d(today+1.0_dp)) !!     end program demo_j2d !! !!    results: !! !!     Today=Tuesday, July 19th, 2016 08:48:20 AM !!     Yesterday=Monday, July 18th, 2016 08:48:20 AM !!     Tomorrow=Wednesday, July 20th, 2016 08:48:20 AM !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function j2d ( julian ) result ( dat ) ! ident_22=\"@(#)M_time::j2d(3f): Given Julian Date returns DAT date-time array\" real ( kind = realtime ), intent ( in ) :: julian integer :: dat ( 8 ) integer :: ierr call julian_to_date ( julian , dat , ierr ) end function j2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    d2u(3f) - [M_time:UNIX_EPOCH] given DAT date-time array returns Unix !!    Epoch Time (UET starts at 0000 on 1 Jan. 1970, UTC) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function d2u(dat) result (unixtime) !! !!       integer,intent(in),optional :: dat(8) !!       real(kind=realtime)         :: unixtime !! !!##DESCRIPTION !!   Converts a DAT date-time array to a Unix Epoch Time value. Typically !!   mathematical operations such as sums, sorting and comparison are !!   performed with simple UET numeric values, and then they are converted !!   back. !! !!##OPTIONS !!    dat   Integer array holding a \"DAT\" array, similar in structure !!          to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!          If not present the current time is used !! !!##RETURNS !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since 00:00:00 on !!              January 1st, 1970, UTC. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_d2u !!     use M_time, only : d2u !!     implicit none !!     integer           :: dat(8) !!        call date_and_time(values=dat) !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        write(*,*)'Unix Epoch time is ',d2u(dat) !!     end program demo_d2u !! !!    results: !! !!     Today is:2016:7:19:-240:2:0:48:561 !!     Unix Epoch time is    1468908048.5610321 !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function d2u ( dat ) result ( unixtime ) ! ident_23=\"@(#)M_time::d2u(3f): Given DAT date-time array returns Unix Epoch time\" real ( kind = realtime ) :: unixtime integer , intent ( in ), optional :: dat ( 8 ) integer :: datlocal ( 8 ) integer :: ierr if ( present ( dat )) then datlocal = dat else datlocal = getnow () ! current time is placed in array endif call date_to_unix ( datlocal , unixtime , ierr ) end function d2u !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    u2d(3f) - [M_time:UNIX_EPOCH] given Unix Epoch Time returns DAT !!    date-time array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function u2d(unixtime) result (dat) !! !!     class(*),intent(in),optional      :: unixtime !!     ! integer !!     ! real !!     ! real(kind=realtime) !! !!     integer                           :: dat(8) !! !!##DESCRIPTION !!   Given Unix Epoch Time returns DAT date-time array !! !!##OPTIONS !!    unixtime  The \"Unix Epoch\" time, or the number of seconds since !!              00:00:00 on January 1st, 1970, UTC. If not present, use !!              current time. !! !!##RETURNS !!    dat       Integer array holding a \"DAT\" array, similar in structure !!              to the array returned by the intrinsic DATE_AND_TIME(3f): !! !!                 dat=[ year,month,day,timezone,hour,& !!                  & minutes,seconds,milliseconds] !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_u2d !!     use M_time, only : u2d, d2u, fmtdate, realtime !!     implicit none !!     integer,parameter :: dp=kind(0.0d0) !!     real(kind=realtime) :: today !!     integer :: dat(8) !!        ! get the date using intrinsic !!        call date_and_time(values=dat) !!        ! convert today to Julian Date !!        today=d2u(dat) !!        write(*,*)'Today=',fmtdate(u2d(today)) !!        ! subtract day !!        write(*,*)'Yesterday=',fmtdate(u2d(today-86400.0_dp)) !!        ! add day !!        write(*,*)'Tomorrow=',fmtdate(u2d(today+86400.0_dp)) !!     end program demo_u2d !! !!    results: !! !!     Today=Tuesday, July 19th, 2016 11:10:08 AM !!     Yesterday=Monday, July 18th, 2016 11:10:08 AM !!     Tomorrow=Wednesday, July 20th, 2016 11:10:08 AM !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function u2d ( unixtime ) result ( dat ) ! ident_24=\"@(#)M_time::u2d(3f): Given Unix Epoch Time returns DAT date-time array\" class ( * ), intent ( in ), optional :: unixtime integer :: dat ( 8 ) real ( kind = realtime ) :: local_unixtime integer :: ierr if ( present ( unixtime )) then select type ( unixtime ) type is ( integer ); local_unixtime = unixtime type is ( integer ( kind = int64 )); local_unixtime = unixtime type is ( real ); local_unixtime = unixtime type is ( real ( kind = realtime )); local_unixtime = unixtime end select else local_unixtime = d2u () endif call unix_to_date ( local_unixtime , dat , ierr ) end function u2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function get_timezone () result ( tz ) implicit none integer :: tz integer :: timezone ( 8 ) timezone = getnow () tz = timezone ( 4 ) if ( tz . gt . 0 ) then ! gfortran bug on new-years write ( * , * ) '<ERROR>*get_timezone*TZ=' , tz tz = mod ( tz , 1440 ) - 1440 endif end function get_timezone !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    sec2days(3f) - [M_time:DURATION] convert seconds to string of form !!    dd-hh:mm:ss !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function sec2days(seconds,crop) result(dhms) !! !!     real(kind=realtime),intent(in) :: seconds !!       or !!     integer,intent(in)             :: seconds !!       or !!     real,intent(in)                :: seconds !!       or !!     character(len=*)               :: seconds !! !!     logical,intent(in),optional    :: crop !!     character(len=:),allocatable   :: dhms !! !!##DESCRIPTION !!   Given a number of seconds convert it to a string of the form !! !!       dd-hh:mm:ss !! !!   where dd is days, hh hours, mm minutes and ss seconds. !! !!##OPTIONS !!    seconds    number of seconds to convert to string of form dd-hh:mm:ss. May !!               be of type INTEGER, REAL, REAL(KIND=REALTIME), or CHARACTER. !! !!               CHARACTER strings may be of the form !!               [NNd][NNh][NNm][NNs][NNw]. Case,spaces and underscores are !!               ignored. Allowed aliases for d,h,m, and s units are !! !!                   d -  days,day !!                   m -  minutes,minute,min !!                   h -  hours,hour,hrs,hr !!                   s -  seconds,second,sec !! !!               The numeric values may represent floating point numbers. !! !!    crop       if .true., remove leading zero day values or day and hour values. !!               Optional, defaults to .false. . !!##RETURNS !!    dmhs       the returned string of form [d:h:]m:s !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_sec2days !!     use M_time, only : sec2days !!     implicit none !!     integer,parameter :: dp=kind(0.0d0) !!        write(*,*)sec2days(129860) !!        write(*,*)sec2days(80000.0_dp) !!        write(*,*)sec2days(80000.0,crop=.true.) !!        write(*,*)sec2days('1 day 2.0hr 100 min 300.0seconds') !!     end program demo_sec2days !! !!    results: !! !!     1-12:04:20 !!     0-22:13:20 !!     22:13:20 !!     1-03:45:00 !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function sec2days ( seconds , crop ) result ( dhms ) use , intrinsic :: iso_fortran_env , only : int64 ! ident_25=\"@(#)M_time::sec2days(3f): converts seconds or string of form IId JJh KKm LLs to string showing days of form D-HH:MM:SS\" ! on this platform, (select_int_kind(i),i=1,100) returns ! 1:2=1 ,3:4=2 ,5:9=4 ,10:18= 8 ,19:38=16 ,39:=-1 !integer,parameter        :: k(38)=[(selected_int_kind(i),i=1,38)] integer :: i class ( * ), intent ( in ) :: seconds logical , intent ( in ), optional :: crop character ( len = :), allocatable :: dhms real ( kind = realtime ), parameter :: units_hl ( 4 ) = [ 8640 0.0_dp , 360 0.0_dp , 6 0.0_dp , 1.0_dp ] character ( len = 40 ) :: scratch integer ( kind = int64 ) :: days , hours , minutes , secsleft integer , parameter :: one_day = 86400 integer , parameter :: one_hour = 3600 integer , parameter :: one_minute = 60 logical :: crop_local integer :: iprint logical :: negative integer :: ilast character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: array (:) doubleprecision :: dtime !  Convert input value to nearest integer !  Notice that the value SECONDS can be any of several types ( INTEGER,REAL,REAL(KIND=REALTIME)) select type ( seconds ) type is ( integer ); secsleft = seconds type is ( real ); secsleft = nint ( seconds ) type is ( real ( kind = realtime )); secsleft = nint ( seconds ) type is ( character ( len =* )) ! note _ is removed from input strings to allow use of _ every three digits in a number as sometimes seen in Java, perl, ... strlocal = compact ( lower ( transliterate ( seconds , \" _',\" , '' )), '' ) // '                ' ! add whitespace to make room for spaces call substitute ( strlocal , 'days' , 'd' ) ! from long names to short names substitute common aliases for units call substitute ( strlocal , 'day' , 'd' ) call substitute ( strlocal , 'hours' , 'h' ) call substitute ( strlocal , 'hour' , 'h' ) call substitute ( strlocal , 'hrs' , 'h' ) call substitute ( strlocal , 'hr' , 'h' ) call substitute ( strlocal , 'minutes' , 'm' ) call substitute ( strlocal , 'minute' , 'm' ) call substitute ( strlocal , 'min' , 'm' ) call substitute ( strlocal , 'seconds' , 's' ) call substitute ( strlocal , 'second' , 's' ) call substitute ( strlocal , 'secs' , 's' ) call substitute ( strlocal , 'sec' , 's' ) call substitute ( strlocal , 'weeks' , 'w' ) call substitute ( strlocal , 'week' , 'w' ) call substitute ( strlocal , 'wks' , 'w' ) call substitute ( strlocal , 'wk' , 'w' ) call substitute ( strlocal , 's' , 's ' ) ! assuming only one suffix character and not too many to exceed length of strlocal call substitute ( strlocal , 'm' , 'm ' ) call substitute ( strlocal , 'h' , 'h ' ) call substitute ( strlocal , 'd' , 'd ' ) call substitute ( strlocal , 'w' , 'w ' ) dtime = 0.0_dp call split ( strlocal , array , ' ' ) do i = 1 , size ( array ) ilast = len_trim ( array ( i )) select case ( array ( i )( ilast : ilast )) case ( 'w' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) * 7 case ( 'd' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) case ( 'h' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 2 ) case ( 'm' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 3 ) case ( 's' ); dtime = dtime + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 4 ) case default dtime = dtime + s2v ( array ( i )) end select enddo secsleft = int ( dtime , kind = int64 ) end select if ( present ( crop )) then ! whether to trim cases where(days=0) and (hours=0 when days=0) from output or always show dd-hh:mm:ss crop_local = crop else crop_local = . false . endif if ( secsleft . lt . 0 ) then secsleft =- secsleft negative = . true . else negative = . false . endif iprint = 4 days = secsleft / one_day ! get whole number of days if ( days . eq . 0 ) iprint = 3 secsleft = secsleft - days * one_day ! calculate remainder hours = secsleft / one_hour ! get whole number of hours if ( days . eq . 0. and . hours . eq . 0 ) iprint = 2 secsleft = secsleft - hours * one_hour minutes = secsleft / one_minute ! get whole number of minutes secsleft = secsleft - minutes * one_minute if (. not . crop_local ) then iprint = 4 endif select case ( iprint ) ! select format if cropping is on and leading zero values are present case ( 2 ) write ( scratch , '(i2.2,\":\",i2.2)' ) minutes , secsleft case ( 3 ) write ( scratch , '(i2.2,\":\",i2.2,\":\",i2.2)' ) hours , minutes , secsleft case default write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2)' ) days , hours , minutes , secsleft end select if ( negative ) then dhms = '-' // trim ( scratch ) else dhms = trim ( scratch ) endif end function sec2days !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    days2sec(3f) - [M_time:DURATION] convert string of form !!    [[-]dd-]hh:mm:ss.nn to seconds !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function days2sec(str) result(time) !! !!     character(len=*),intent(in)       :: str !!     real(kind=realtime)               :: time !! !!##DESCRIPTION !!   Given a string representing a duration of the form !!   \"[-][[[dd-]hh:]mm:]ss\"  or [NNd][NNh][NNm[]NNs][NNw] !!   return a value representing seconds. !! !!   If \"dd-\" is present, units for the numbers are assumed to !!   proceed from day to hour to minute to second. But if no !!   day is present, the units are assumed to proceed from second !!   to minutes to hour from left to right. That is ... !! !!         [-]dd-hh:mm:ss !!         [-]dd-hh:mm !!         [-]dd-hh !! !!         hh:mm:ss !!         mm:ss !!         ss !! !!         Where dd is days, hh hours, mm minutes and ss seconds. !! !!   A decimal fraction is supported on the seconds (Actually, !!   any of the numeric values may represent positive floating !!   point numbers). Spaces are ignored. !! !! !!   Simple numeric values may also be used with unit suffixes; where !!   s,m,h, or d represents seconds, minutes, hours or days and w !!   represents a week. Allowed aliases for w,d,h,m, and s units are !! !!        [NNd][NNh][NNm][NNs][NNw] !! !!          d -  days,day !!          m -  minutes,minute,min,mins !!          h -  hours,hour,hr,hrs !!          s -  seconds,second,sec,secs !!          w -  week, weeks, wk, wks !! !!   The numeric values may represent floating point numbers. !! !!   Spaces, commas and case are ignored. !! !!##OPTIONS !!       str   string of the general form dd-hh:mm:ss.nn !!##RETURNS !!       time  the number of seconds represented by the input string !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_days2sec !!     use M_time, only : days2sec !!     implicit none !!        write(*,*)days2sec('1-12:04:20') !!        write(*,*)'one second ',days2sec('1') !!        write(*,*)'one minute ',days2sec('1:00') !!        write(*,*)'one hour ',days2sec('1:00:00') !!        write(*,*)'one day ',days2sec('1-00:00:00') !!        write(*,*)nint(days2sec(' 1-12:04:20              ')) .eq. 129860 !!        write(*,*)nint(days2sec(' 1.5 days                ')) .eq. 129600 !!        write(*,*)nint(days2sec(' 1.5 days 4hrs 30minutes ')) .eq. 145800 !!        write(*,*)nint(days2sec(' 1.5d                    ')) .eq. 129600 !!        write(*,*)nint(days2sec(' 1d2h3m4s                ')) .eq. 93784 !!        ! duplicates !!        write(*,*)nint(days2sec(' 1d1d1d                  ')) .eq. 259200 !!        ! negative values !!        write(*,*)nint(days2sec(' 4d-12h                  ')) .eq. 302400 !!     end program demo_days2sec !! !!    Results: !! !!     > 129860.00000000000 !!     > one second    1.0000000000000000 !!     > one minute    60.000000000000000 !!     > one hour    3600.0000000000000 !!     > one day    86400.000000000000 !!     > T !!     > T !!     > T !!     > T !!     > T !!     > T !!     > T !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function days2sec ( str ) result ( time ) implicit none ! ident_26=\"@(#)M_time::days2sec(3f): convert string [[-]dd-]hh:mm:ss.nn to seconds or string IId JJh KKm LLs to seconds\" character ( len =* ), intent ( in ) :: str real ( kind = realtime ) :: time ! Supported input syntax: !    [-]dd-hh:mm:ss !          hh:mm:ss !          mm:ss !          ss ! character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: array (:) real ( kind = realtime ), parameter :: units_lh ( 4 ) = [ 1.0_dp , 6 0.0_dp , 360 0.0_dp , 8640 0.0_dp ] real ( kind = realtime ), parameter :: units_hl ( 4 ) = [ 8640 0.0_dp , 360 0.0_dp , 6 0.0_dp , 1.0_dp ] integer :: i , icount , iwords , ilast logical :: negative time = 0.0_dp strlocal = compact ( str , '' ) ! remove whitespace strlocal = transliterate ( strlocal , \"_',\" , '' ) ! remove single quotes,underscores sometimes used in numbers strlocal = lower ( strlocal ) // repeat ( ' ' , len ( strlocal )) ! change to lowercase and add whitespace to make room for spaces if ( len ( strlocal ). eq . 0 ) then time = 0.0_dp elseif ( scan ( strlocal , 'smhdw' ). ne . 0 ) then ! unit code values not DD-HH:MM:SS either plain number or unit numbers call substitute ( strlocal , 'days' , 'd' ) ! from long names to short names substitute common aliases for units call substitute ( strlocal , 'day' , 'd' ) call substitute ( strlocal , 'hours' , 'h' ) call substitute ( strlocal , 'hour' , 'h' ) call substitute ( strlocal , 'hrs' , 'h' ) call substitute ( strlocal , 'hr' , 'h' ) call substitute ( strlocal , 'minutes' , 'm' ) call substitute ( strlocal , 'minute' , 'm' ) call substitute ( strlocal , 'mins' , 'm' ) call substitute ( strlocal , 'min' , 'm' ) call substitute ( strlocal , 'seconds' , 's' ) call substitute ( strlocal , 'second' , 's' ) call substitute ( strlocal , 'secs' , 's' ) call substitute ( strlocal , 'sec' , 's' ) call substitute ( strlocal , 'weeks' , 'w' ) call substitute ( strlocal , 'week' , 'w' ) call substitute ( strlocal , 'wks' , 'w' ) call substitute ( strlocal , 'wk' , 'w' ) call substitute ( strlocal , 's' , 's ' ) ! assuming only one suffix character and not too many to exceed length of strlocal call substitute ( strlocal , 'm' , 'm ' ) call substitute ( strlocal , 'h' , 'h ' ) call substitute ( strlocal , 'd' , 'd ' ) call substitute ( strlocal , 'w' , 'w ' ) call split ( strlocal , array , ' ' ) iwords = size ( array ) icount = 0 do i = iwords , 1 , - 1 icount = icount + 1 ilast = len_trim ( array ( i )) select case ( array ( i )( ilast : ilast )) case ( 'w' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) * 7 case ( 'd' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 1 ) case ( 'h' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 2 ) case ( 'm' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 3 ) case ( 's' ); time = time + s2v ( array ( i )(: ilast - 1 )) * units_hl ( 4 ) case default time = time + s2v ( array ( i )) end select enddo else if ( strlocal ( 1 : 1 ). eq . '-' ) then ! allow negative prefix as first character but remove it and change sign of value at end negative = . true . strlocal ( 1 : 1 ) = ' ' else negative = . false . endif call split ( trim ( strlocal ), array , ' -:' ) iwords = size ( array ) if ( iwords . gt . 4 ) then write ( * , * ) '*days2sec* error: too many values in ' // trim ( strlocal ) iwords = 4 endif if ( index ( strlocal , '-' ). gt . 0 ) then ! found a dash, assume has days and form DD-HH:MM:SS, DD-, DD-HH, DD-HH:MM do i = 1 , iwords time = time + s2v ( array ( i )) * units_hl ( i ) enddo else ! no dash, assume no days, either HH:MM:SS or MM:SS, SS icount = 0 do i = iwords , 1 , - 1 icount = icount + 1 ilast = len_trim ( array ( i )) time = time + s2v ( array ( i )) * units_lh ( icount ) enddo endif if ( negative ) time =- time endif end function days2sec !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     phase_of_moon(3f) - [M_time:ASTROLOGICAL] return name for phase of !!     moon for given date !!     (LICENSE:PD) !!##SYNOPSIS !! !!   function phase_of_moon(datin) !! !!    integer,intent(in)            :: datin(8) !!    character(len=:),allocatable  :: phase_of_moon !! !!##DESCRIPTION !!   Phases Of The Moon !! !!   This procedure is used to support the %p field descriptor for the !!   fmtdate(3f) routine. !! !!   The moon circles the earth every 29.530588853 days on average, so pick a !!   starting point and count. A new moon occurred at Julian date 2451550.1 !!   (January 6, 2000, 18:14 UTC). Then it is easy to count the number of !!   days since the last new moon. This is an approximate calculation. !! !!   There are eight generally recognized phases of the moon in common use !! !!    o new or dark !!    o waxing crescent !!    o first quarter !!    o waxing gibbous !!    o full !!    o waning gibbous !!    o last quarter !!    o waning crescent !! !!   To calculate the phase of the moon simply divide the days since the !!   last new moon by eight and select the appropriate phase. !! !!   Note that technically the four states (new, first quarter, full, third !!   quarter) are events not phases. That is to say, the moon is technically !!   only new for an instant. !! !!##EXAMPLES !! !!  Sample: !! !!   program demo_phase_of_moon !!   use M_time, only : now !!   use M_time, only : phase_of_moon !!   use M_time, only : moon_fullness !!   implicit none !!   integer             :: dat(8) !!    ! generate DAT array !!    call date_and_time(values=dat) !!    ! show DAT array !!    write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!    ! the %p and %P fields are supported by fmtdate(3f) !!    write(*,*)& !!    & now('The phase of the moon is %p, with a fullness of %P') !!    write(*,'(1x,*(a))',advance='no')& !!    & 'The phase of the moon is ',trim( phase_of_moon(dat)),',' !!    write(*,'(1x,a,i0,a)')'with a fullness of ',moon_fullness(dat),'%' !!   end program demo_phase_of_moon !! !!  Sample output: !! !!     Today is:2018:11:3:-240:20:18:44:245 !!     The phase of the moon is Waning crescent, with a fullness of -30% !!     The phase of the moon is Waning crescent, with a fullness of -30% !! !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function phase_of_moon ( datin ) implicit none ! ident_27=\"@(#)M_time::phase_of_moon(3f): return name for phase of moon for given date\" integer , intent ( in ) :: datin ( 8 ) character ( len = :), allocatable :: phase_of_moon real ( kind = realtime ), parameter :: syndonic_month = 2 9.530588853_realtime ! average period of a lunar cycle, or days per lunation integer , parameter :: reference ( * ) = [ 2000 , 1 , 6 , 0 , 18 , 14 , 0 , 0 ] ! new moon of January 2000 was January 6, 18:14 UTC. character ( len = 20 ), parameter :: phase_names ( * ) = [ \"New            \" , \"Waxing crescent\" , & \"First quarter  \" , \"Waxing gibbous \" , & \"Full           \" , \"Waning gibbous \" , & \"Last quarter   \" , \"Waning crescent\" ] real ( kind = realtime ), parameter :: phase_length = syndonic_month / 8_realtime ! days per phase integer :: phase real ( kind = realtime ) :: days days = d2j ( datin ) - d2j ( reference ) ! days between reference date and input date days = mod ( days + phase_length / 2.0_dp , syndonic_month ) ! modulo calculation of which phase rounding up if ( days . lt . 0 ) days = days + syndonic_month ! correct for days before reference date phase = int ( days * ( size ( phase_names ) / syndonic_month )) + 1 ! index into phase names phase_of_moon = phase_names ( phase ) end function phase_of_moon !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     moon_fullness(3f) - [M_time:ASTROLOGICAL] return percentage of moon phase !!     from new to full !!     (LICENSE:PD) !!##SYNOPSIS !! !!   function moon_fullness(datin) !! !!    integer,intent(in)            :: datin(8) !!    integer                       :: moon_fullness !! !!##DESCRIPTION !! !!   This procedure is used to support the %P field descriptor for the !!   fmtdate(3f) routine. !! !!   The moon circles the earth every 29.530588853 days on average, so pick !!   a starting point and count. A new moon occurred at January 6, 2000, !!   18:14 UTC. Then it is easy to count the number of days since the last !!   new moon. This is an approximate calculation. !! !!##OPTIONS !! !!  datin      DAT Date array describing input date !! !!##RESULTS !! !!     moon_fullness  0 is a new or dark moon, 100 is a full moon, + for waxing !!                    and - for waning. !! !!##EXAMPLES !! !!    Sample: !! !!     program demo_moon_fullness !!     use M_time, only : now !!     use M_time, only : phase_of_moon !!     use M_time, only : moon_fullness !!     implicit none !!     integer             :: dat(8) !!        ! generate DAT array !!        call date_and_time(values=dat) !!        ! show DAT array !!        write(*,'(\" Today is:\",*(i0:,\":\"))')dat !!        ! the %p and %P fields are supported by fmtdate(3f) !!        write(*,*)& !!        &now('The phase of the moon is %p, with a fullness of %P') !!        write(*,'(1x,*(a))',advance='no')& !!        &'The phase of the moon is ',trim( phase_of_moon(dat)),',' !!        write(*,'(1x,a,i0,a)')& !!        &'with a fullness of ', moon_fullness(dat),'%' !!     end program demo_moon_fullness !! !!    Sample output: !! !!      Today is:2018:11:3:-240:20:18:44:245 !!      The phase of the moon is Waning crescent, with a fullness of -30% !!      The phase of the moon is Waning crescent, with a fullness of -30% !!##AUTHOR !!    John S. Urban, 2015 !!##LICENSE !!    Public Domain function moon_fullness ( datin ) implicit none ! ident_28=\"@(#)M_time::moon_fullness(3f): return percentage of moon phase from new to full\" integer , intent ( in ) :: datin ( 8 ) integer :: moon_fullness real ( kind = realtime ), parameter :: syndonic_month = 2 9.530588853_realtime ! average period of a lunar cycle, or days per lunation integer , parameter :: reference ( * ) = [ 2000 , 1 , 6 , 0 , 18 , 14 , 0 , 0 ] ! new moon of January 2000 was January 6, 18:14 UTC. real ( kind = realtime ) :: days_into_cycle days_into_cycle = mod ( d2j ( datin ) - d2j ( reference ) , syndonic_month ) ! number of days into lunar cycle if ( days_into_cycle . lt . 0 ) days_into_cycle = days_into_cycle + syndonic_month ! correct for input date being before reference date if ( days_into_cycle . le . syndonic_month / 2.0_realtime ) then ! if waxing from new to full report as 0% to 100% moon_fullness = int (( days_into_cycle / syndonic_month ) * 20 0.0_realtime + 0.5_realtime ) else ! if waning from full to new report as -99% to -1% moon_fullness =- ( 200 - int (( days_into_cycle / syndonic_month ) * 20 0.0_realtime )) endif end function moon_fullness !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    easter(3f) - [M_time:ASTROLOGICAL] calculate date for Easter given a year !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   subroutine easter(year,dat) !! !!     integer, intent(in)   :: year !!     integer, intent(out)  :: dat !! !!##DESCRIPTION !!   The Date of Easter (Sunday) !! !!   The algorithm is due to J.-M. Oudin (1940) and is reprinted !!   in the Explanatory Supplement to the Astronomical Almanac, !!   ed. P. K. Seidelmann (1992). See Chapter 12, \"Calendars\", by !!   L. E. Doggett. !! !!   The following are dates of Easter from 1980 to 2024: !! !!        1980  April  6        1995  April 16        2010  April  4 !!        1981  April 19        1996  April  7        2011  April 24 !!        1982  April 11        1997  March 30        2012  April  8 !!        1983  April  3        1998  April 12        2013  March 31 !!        1984  April 22        1999  April  4        2014  April 20 !!        1985  April  7        2000  April 23        2015  April  5 !!        1986  March 30        2001  April 15        2016  March 27 !!        1987  April 19        2002  March 31        2017  April 16 !!        1988  April  3        2003  April 20        2018  April  1 !!        1989  March 26        2004  April 11        2019  April 21 !!        1990  April 15        2005  March 27        2020  April 12 !!        1991  March 31        2006  April 16        2021  April  4 !!        1992  April 19        2007  April  8        2022  April 17 !!        1993  April 11        2008  March 23        2023  April  9 !!        1994  April  3        2009  April 12        2024  March 31 !! !!   N.B. The date of Easter for the Eastern Orthodox Church may be different. !! !!##OPTIONS !!      year    Year for which to calculate day that Easter falls on !!##RESULTS !!      dat     Date array for noon on Easter for the specified year !! !!##EXAMPLE !! !! !!    Sample program: !! !!     program demo_easter !!     use M_time, only : easter, fmtdate !!     implicit none !!     integer :: year !!     integer :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond !!       call date_and_time(values=dat)  ! get current year !!       year=dat(1) !!       call easter(year, dat) !!       write(*,*)fmtdate(dat,& !!       \"Easter day: the %d day of %L in the year of our Lord %Y\") !!     end program demo_easter !! !!    Sample output: !! !!     Easter day: the 16th day of April in the year of our Lord 2017 !> !! !!   U.S. Naval Observatory Astronomical Applications Department !! !!   This code assembled by Alan Miller !!   Reference web site: !!   http://aa.usno.navy.mil/faq/docs/easter.html !!   Latest revision 8 April 2002 SUBROUTINE Easter ( year , dat ) implicit none ! ident_29=\"@(#)M_time::easter(3f): calculate date for Easter given a year\" integer , intent ( in ) :: year integer , intent ( out ) :: dat ( 8 ) ! year,month,day,tz,hour,minute,second,millisecond integer :: day , month integer :: c , i , j , k , l , n c = year / 100 n = year - 19 * ( year / 19 ) k = ( c - 17 ) / 25 i = c - c / 4 - ( c - k ) / 3 + 19 * n + 15 i = i - 30 * ( i / 30 ) i = i - ( i / 28 ) * ( 1 - ( i / 28 ) * ( 29 / ( i + 1 )) * ( ( 21 - n ) / 11 ) ) j = year + year / 4 + i + 2 - c + c / 4 j = j - 7 * ( j / 7 ) l = i - j month = 3 + ( l + 40 ) / 44 day = l + 28 - 31 * ( month / 4 ) ! fill out a date_and_time array dat = getnow () ! get current year dat = [ year , month , day , dat ( 4 ), 12 , 0 , 0 , 0 ] end subroutine Easter !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! !   XXXX !  X    X ! X ! X ! X ! X ! X !  X    X !   XXXX ! !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    system_sleep(3f) - [M_time:C_INTERFACE] call C sleep(3c) or usleep(3c) !!    procedure !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine system_sleep(wait_seconds) !! !!       integer,intent(in)  :: wait_seconds !!          or !!       real,intent(in)  :: wait_seconds !! !!##DESCRIPTION !!   The system_sleep(3f) routine uses the intrinsic ISO_C_BINDING !!   interface to call the C sleep(3c) procedure or usleep(3c) !!   routine. !! !!##OPTIONS !!    wait_seconds  integer,real or doubleprecision number of seconds for !!                  process to sleep. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_system_sleep !!     use M_time, only : system_sleep, now !!     implicit none !!     integer :: i !!        ! !!        write(*,'(a)')\"Time before integer call is: \",now() !!        call system_sleep(4) !!        write(*,'(a)')\"Time after  integer call is: \",now() !!        ! !!        write(*,'(a)')\"Time before real call is: \",now() !!        call system_sleep(4.0) !!        write(*,'(a)')\"Time after  real call is: \",now() !!        ! !!        write(*,'(a)')\"Time before loop is: \",now() !!        do i=1,1000 !!           call system_sleep(4.0/1000.0) !!        enddo !!        write(*,'(a)')\"Time after loop  is: \",now() !!        ! !!     end program demo_system_sleep !! !!  results !! !!      Time before integer call is: !!      Sunday, July 17th, 2016 2:29:45 AM UTC-0240 !!      Time after integer call is: !!      Sunday, July 17th, 2016 2:29:49 AM UTC-0240 !!      Time before real call is: !!      Sunday, July 17th, 2016 2:29:49 AM UTC-0240 !!      Time after  real call is: !!      Sunday, July 17th, 2016 2:29:53 AM UTC-0240 !!      Time before loop is: !!      Sunday, July 17th, 2016 2:29:53 AM UTC-0240 !!      Time after loop  is: !!      Sunday, July 17th, 2016 2:30:09 AM UTC-0240 !! !!##AUTHOR !!    John S. Urban, 2015 !! !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine system_sleep ( seconds ) use , intrinsic :: iso_c_binding , only : c_int ! ident_30=\"@(#)M_time::system_sleep(3f): call sleep(3c) or usleep(3c)\" class ( * ), intent ( in ) :: seconds integer ( kind = c_int ) :: cint select type ( seconds ) type is ( integer ); cint = seconds ; call call_sleep ( cint ) type is ( real ); cint = nint ( seconds * 100000 0.0_dp ) ; call call_usleep ( cint ) type is ( real ( kind = realtime )); cint = nint ( seconds * 100000 0.0_dp ) ; call call_usleep ( cint ) end select end SUBROUTINE system_sleep !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine call_sleep ( wait_seconds ) use , intrinsic :: iso_c_binding , only : c_int ! ident_31=\"@(#)M_time::call_sleep(3fp): call sleep(3c)\" integer ( kind = c_int ), intent ( in ) :: wait_seconds integer ( kind = c_int ) :: how_long interface function c_sleep ( seconds ) bind ( C , name = \"sleep\" ) import integer ( c_int ) :: c_sleep ! should be unsigned int (not available in Fortran). OK until highest bit gets set. integer ( c_int ), intent ( in ), VALUE :: seconds end function c_sleep end interface if ( wait_seconds . gt . 0 ) then how_long = c_sleep ( wait_seconds ) endif end subroutine call_sleep !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine call_usleep ( wait_seconds ) use , intrinsic :: iso_c_binding , only : c_int ! ident_32=\"@(#)M_time::call_usleep(3fp): call usleep(3c)\" integer ( kind = c_int ), intent ( in ) :: wait_seconds integer ( kind = c_int ) :: how_long interface function c_usleep ( seconds ) bind ( C , name = \"usleep\" ) import integer ( c_int ) :: c_usleep ! should be unsigned int (not available in Fortran). OK until highest bit gets set. integer ( c_int ), intent ( in ), VALUE :: seconds end function c_usleep end interface if ( wait_seconds . gt . 0 ) then how_long = c_usleep ( wait_seconds ) endif end subroutine call_usleep !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! function getnow () result ( values ) ! ident_33=\"@(#)M_time::getnow(3f): get DAT for current time or value of SOURCE_DATE_EPOCH\" integer :: values ( 8 ) call date_and_time ( values = values ) end function getnow !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_time !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!","tags":"","loc":"sourcefile/m_time.f90.html"},{"title":"M_time_oop.f90 – M_time","text":"Contents Modules M_time_oop Source Code M_time_oop.f90 Source Code !=================================================================================================================================== ! !     XX                                             X !      X            X                       X !      X            X                       X !  XXXXX   XXXX    XXXX    XXXXX           XXXX    XXX    XXX X    XXXXX ! X    X       X    X     X     X           X        X     X X X  X     X ! X    X   XXXXX    X     XXXXXXX           X        X     X X X  XXXXXXX ! X    X  X    X    X     X                 X        X     X X X  X ! X    X  X    X    X  X  X     X           X  X     X     X X X  X     X !  XXXXXX  XXXX X    XX    XXXXX             XX    XXXXX  XX X XX  XXXXX ! !                                XXXXXXXX ! !> !!##NAME !!    M_time_oop(3fm) - [M_time::INTRO::OOPS] OOP interface for M_time(3fm) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!   use M_time_oop, only : date_time !! !!    use M_time_oop,only : operator(+),operator(-),operator(>),operator(<) !!    use M_time_oop,only : operator(<=),operator(>=),operator(==),operator(/=) !! !!    TYPE(date_time) :: mydate !! !!       mydate%year !!       mydate%month !!       mydate%day !!       mydate%tz !!       mydate%hour !!       mydate%minute !!       mydate%second !!       mydate%millisecond !! !!       call mydate%init() !! !!       mydate%format('') !!       mydate%ordinal() !!       mydate%weekday() !!       mydate%epoch() !!       mydate%julian() !!       dat=mydate%datout() !!       mydate%delta(year=NN, month=NN, day=NN, tz=NN, hour=NN, minute=NN, !!       second=NN, millisecond=NN, week=NN, duration='DD-HH:MM:SS.XX') !! !!##DESCRIPTION !!    An object-oriented interface to the M_time module. The following !!    example program demonstrates and documents the interface !! !!##EXAMPLE !! !! !!  sample program !! !!     program demo_M_time_oop !!     ! !!     ! This is an example using the object-oriented class/type model !!     ! This is essentially the same functionality as the procedures !!     ! in the procedural module M_time(3fm), but allows for Object !!     ! Oriented syntax: !!     ! !!     use M_time_oop,only : date_time !!     !!use M_time_oop,only : operator(+),operator(-),operator(>),operator(<) !!     !!use M_time_oop,only : operator(<=),operator(>=),operator(==),operator(/=) !!     implicit none !!     integer,parameter :: dp=kind(0.0d0) !!     integer         :: dat(8) !!     TYPE(date_time) :: event !!     TYPE(date_time) :: otherdate !!     TYPE(date_time) :: answer !! !!     character(len=*),parameter :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z' !!        ! DIFFERENT INITIALIZATION STYLES !!        ! (Still debating on how best to do this) !!        write(*,*) !!        write(*,'(a)')'Various initialization styles' !! !!        ! DEFINE type(date_time) WITH CONSTRUCTOR !!        otherdate=date_time() !!        print *,'DEFAULT CONSTRUCTOR %format()               ',& !!        & otherdate%format() !!        print *,'DEFAULT CONSTRUCTOR %format(\"\")             ',& !!        & otherdate%format(\"\") !!        print *,'DEFAULT CONSTRUCTOR %format(user-specified) ',& !!        & otherdate%format(iso_fmt) !!        print *,'DEFAULT CONSTRUCTOR %format(\"USA\")          ',& !!        & otherdate%format(\"USA\") !! !!        otherdate=date_time(1492,10,12,0,0,0,0,0) !!        print *,'DEFAULT CONSTRUCTOR setting values          ',& !!        & otherdate%format() !! !!        otherdate=date_time(2016,6,11) !!        print *,'DEFAULT CONSTRUCTOR with partial values     ',& !!        & otherdate%format() !! !!        otherdate=date_time(year=2016,month=6,day=11,tz=-240,& !!        & hour=21,minute=09,second=11,millisecond=500) !!        print *,'DEFAULT CONSTRUCTOR with values by name     ',& !!        & otherdate%format() !! !!        otherdate=date_time([1776,7,4,0,0,0,0,0]) !!        print *,'CONSTRUCTOR with a dat array                ',& !!        & otherdate%format() !! !!        otherdate=date_time([1776,7,4]) !!        print *,'CONSTRUCTOR with a partial dat array        ',& !!        & otherdate%format() !! !!        ! the init() method supports several methods !!        ! initialize to current time using INIT !!        call otherdate%init() !!        ! initialize to current time using INIT !!        call otherdate%init(type=\"now\") !! !!        ! initialize to beginning of Unix Epoch Time !!        call otherdate%init(type=\"epoch\") !!        ! Note !!        ! currently, DATE_TIME DATE array is set to Unix Epoch !!        ! start USING LOCAL TIMEZONE !!        ! whereas default constructor is using default of Unix Epoch !!        ! start using Z time (GMT or UTC time) !! !!        ! initialize with a DAT array using INIT, !!        ! compatible with DATE_AND_TIME VALUES(8) !!        call otherdate%init(dat=[1970,1,1,0,0,0,0,0]) !!        ! using INIT with ordered values !!        call otherdate%init(2016,6,11,-300,23,1,0,0) !!        ! using INIT with names !!        call otherdate%init(year=2016,month=6,day=11,& !!        & tz=-300,hour=23,minute=1,second=0,millisecond=0) !!        ! !!        ! take current date and exercise the OOP interface !!        ! initialize to current time using INIT !!        call event%init() !!        write(*,*) !!        write(*,*)'Print members of type(DATE_TIME)' !!        ! show derived type !!        write(*,404)'EVENT=',event !!        404 format(1x,a,i0,*(\",\",i0:)) !! !!        ! MEMBERS ( basic time values are all integers) !!        ! print members of type !!        write(*,101)'%year        Year................... ',event%year !!        write(*,101)'%month       Month.................. ',event%month !!        write(*,101)'%day         Day.................... ',event%day !!        write(*,101)'%tz          Timezone............... ',event%tz !!        write(*,101)'%hour        Hour................... ',event%hour !!        write(*,101)'%minute      Minute................. ',event%minute !!        write(*,101)'%second      Second................. ',event%second !!        write(*,101)'%millisecond Millisecond............ ',event%millisecond !! !!        ! PRINT METHODS OF TYPE !!        write(*,*)'Print methods of type(DATE_TIME)' !!        write(*,101)'%ordinal     Ordinal day of year.... ',  event%ordinal() !!        write(*,101)'%weekday     Weekday................ ',  event%weekday() !!        101 format(1x,a,i0) !!        ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY !!        write(*,202)'%epoch      Unix epoch time........ ',  event%epoch() !!        write(*,202)'%julian     Julian date............ ',  event%julian() !!        202 format(1x,a,g0) !! !!        ! FORMATTED STRINGS (many strings possible. !!        ! Takes the same format string as fmtdate(3f)) !!        write(*,*) !!        write(*,'(a)')' Formatted Strings (%format(\"STRING\") & !!        & -- see fmtdate(3f) for format descriptions' !!        ! abbreviated month name             %l  Dec !!        write(*,303)'Short month............ ',& !!        & event%format(\"%l\") !!        ! !!        ! full month name                    %L  December !!        write(*,303)'Month.................. ',& !!        & event%format(\"%L\") !!        ! !!        ! first three characters of weekday  %w  Sat !!        write(*,303)'Short week............. ',& !!        & event%format(\"%w\") !!        ! !!        ! weekday name                       %W  Saturday !!        write(*,303)'Week .................. ',& !!        & event%format(\"%W\") !!        ! !!        ! with no percent (%) characters !!        write(*,303)'Calendar Time ......... ',& !!        & event%format(\"Y-M-D h:m:s.x z\") !!        ! !!        ! keywords with no percent (%) characters !!        write(*,303)'Calendar Time ......... ',& !!        & event%format('\"year-month-day & !!        & hour:minute:second.millisecond timezone\"') !!        ! !!        write(*,*)event%format('Longer format.......... & !!        &\"%W, %L %d, %Y %H:%m:%s %N\"') ! a nice friendly format !!        ! !!        303 format(1x,a,'\"',a,'\"') !! !!        ! convert date_time to integer array !!        ! (maybe to use with module M_TIME base procedures) !!        dat=event%datout() !!        write(*,*) !!        write(*,404)'DAT=',dat !! !!        ! OVERLOADED OPERATORS (add and subtract) !!        ! a date_time object can have seconds added !!        answer=event+1*86400.0_dp !!        ! !!        ! a nice friendly format !!        write(*,*)answer%format('TOMORROW=\"%W, %L %d, %Y %H:%m:%s %N\"') !!        ! !!        ! a date_time object can have seconds subtracted !!        answer=event-1*86400.0_dp !!        ! a nice friendly format !!        write(*,*)answer%format('YESTERDAY=\"%W, %L %d, %Y %H:%m:%s %N\"') !!        ! !!        ! if both operands are DATE_TIME objects a subtraction !!        ! finds the time in seconds between the two dates !!        write(*,*)'DIFFERENCE (subtracting one date_time from another)=',& !!        & answer-event !! !!        ! OVERLOADED OPERATORS (logical comparisons) !!        ! NOTE COMPARISONS ARE PERFORMED BY !!        ! CONVERTING TIMES TO INTEGER SECONDS !!        write(*,*)'> ',event.eq.event   ,event.lt.event   ,event.gt.event & !!        & ,event.le.event   ,event.ge.event   ,event.ne.event !!        ! !!        write(*,*)'> ',event.eq.answer  ,event.lt.answer  ,event.gt.answer  & !!        & ,event.le.answer  ,event.ge.answer  ,event.ne.answer !!        ! !!        write(*,*)'> ',answer.eq.event  ,answer.lt.event  ,answer.gt.event  & !!        & ,answer.le.event  ,answer.ge.event  ,answer.ne.event !! !!        ! %DELTA easily lets you change dates by common increments !!        write(*,*) !!        write(*,404)'%DELTA tests starting with date ',event%delta() !!        ! !!        write(*,*) event%format(\"                             & !!        &%W, %L %d, %Y %H:%m:%s %N\") !! !!        write(*,*)'Remember years and months are not constant units' !! !!        answer=event%delta(year=1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\") !!        answer=event%delta(year=-1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(month=24) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(month=-24) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(week=1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(week=-1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(day=1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(day=-1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(hour=4) !!        write(*,*)answer%format(& !!        ! !!        & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\") !!        answer=event%delta(hour=-4) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(minute=180) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(minute=-180) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(second=1800) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(second=-1800) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(millisecond=10000) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(millisecond=-10000) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(year=3,month=2,day=100,hour=200,& !!        & week=-1,minute=300,second=1000,millisecond=-10000) !!        write(*,*)answer%format(& !!        ! !!        &\"FOR %%DELTA(year=3,month=2,day=100,hour=200,& !!        &week=-1,minute=300,second=1000,millisecond=100000)& !!        & %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(duration=\"1-20:30:40.50\") !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(DURATION='1-20:30:40.50')& !!        & %W, %L %d, %Y %H:%m:%s %N\") !! !!     end program demo_M_time_oop !! !! Sample output: !! !!  Various initialization styes !!   DEFAULT CONSTRUCTOR %format()               1970-01-01T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR %format(\"\")             1970-01-01T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR %format(user-specified) 1970-01-01T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR %format(\"USA\")   Thursday, January 1st, 1970 12:00:00 AM !!   DEFAULT CONSTRUCTOR setting values          1492-10-12T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR with partial values     2016-06-11T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR with values by name     2016-06-11T21:09:11.500-04:00 !!   CONSTRUCTOR with a dat array                1776-07-04T00:00:00.000+00:00 !!   CONSTRUCTOR with a partial dat array        1776-07-04T20:00:00.000-04:00 !! !!   Print members of type(DATE_TIME) !!   EVENT=2020,10,24,-240,21,49,54,105 !!   %year        Year................... 2020 !!   %month       Month.................. 10 !!   %day         Day.................... 24 !!   %tz          Timezone............... -240 !!   %hour        Hour................... 21 !!   %minute      Minute................. 49 !!   %second      Second................. 54 !!   %millisecond Millisecond............ 105 !!   Print methods of type(DATE_TIME) !!   %ordinal     Ordinal day of year.... 298 !!   %weekday     Weekday................ 6 !!   %epoch      Unix epoch time........ 1603590594.1049695 !!   %julian     Julian date............ 2459147.5763206594 !! !!   Formatted Strings (%format(\"STRING\") !!   -- see fmtdate(3f) for format descriptions !!   Short month............ \"Oct\" !!   Month.................. \"October\" !!   Short week............. \"Sat\" !!   Week .................. \"Saturday\" !!   Calendar Time ......... \"2020-10-24 21:49:54.105 -04:00\" !!   Calendar Time ......... \"\"2020-10-24 21:49:54.105 -0400\"\" !!   Longer format.......... \"Saturday, October 24th, 2020 9:49:54 PM\" !! !!   DAT=2020,10,24,-240,21,49,54,105 !!   TOMORROW=\"Sunday, October 25th, 2020 9:49:54 PM\" !!   YESTERDAY=\"Friday, October 23rd, 2020 9:49:54 PM\" !!   DIFFERENCE (subtracting one date_time from another)=  -86400.000000000000 !!   >  T F F T T F !!   >  F F T F T T !!   >  F T F T F T !! !!   %DELTA tests starting with date 2020,10,24,-240,21,49,54,105 !!                                Saturday, October 24th, 2020 9:49:54 PM !!   Remember years and months are not constant units !!   FOR %DELTA(YEAR=+1)            Sunday, October 24th, 2021 9:49:54 PM !!   FOR %DELTA(YEAR=-1)            Thursday, October 24th, 2019 9:49:54 PM !!   FOR %DELTA(MONTH=+24)          Wednesday, October 26th, 2022 9:49:54 PM !!   FOR %DELTA(MONTH=-24)          Wednesday, October 24th, 2018 9:49:54 PM !!   FOR %DELTA(WEEK=+1)            Saturday, October 31st, 2020 9:49:54 PM !!   FOR %DELTA(WEEK=-1)            Saturday, October 17th, 2020 9:49:54 PM !!   FOR %DELTA(DAY=+1)             Sunday, October 25th, 2020 9:49:54 PM !!   FOR %DELTA(DAY=-1)             Friday, October 23rd, 2020 9:49:54 PM !!   FOR %DELTA(HOUR=+4)            Sunday, October 25th, 2020 1:49:54 AM !!   FOR %DELTA(HOUR=-4)            Saturday, October 24th, 2020 5:49:54 PM !!   FOR %DELTA(MINUTE=+180)        Sunday, October 25th, 2020 12:49:54 AM !!   FOR %DELTA(MINUTE=-180)        Saturday, October 24th, 2020 6:49:54 PM !!   FOR %DELTA(SECOND=+1800)       Saturday, October 24th, 2020 10:19:54 PM !!   FOR %DELTA(SECOND=-1800)       Saturday, October 24th, 2020 9:19:54 PM !!   FOR %DELTA(MILLISECOND=+10000) Saturday, October 24th, 2020 9:50:04 PM !!   FOR %DELTA(MILLISECOND=-10000) Saturday, October 24th, 2020 9:49:44 PM !!   FOR %DELTA(year=3,month=2,day=100,hour=200,week=-1,minute=300, !!   second=1000,millisecond=100000) Thursday, April 4th, 2024 11:06:24 AM !!   FOR %DELTA(DURATION='1-20:30:40.50') Monday, October 26th, 2020 6:20:34 PM !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! submodule is not supported by the compiler used to develop this yet or it would be worth a try !!submodule (M_time) M_time_oop !!end submodule M_time_oop ! module M_time_oop ! ! Define an OOP (Object-Oriented Programming) interface for the M_time module. ! ! Leveraging the existing procedural functions in module M_TIME to do the calculations allows ! this to simply be a definition of a derived type ( TYPE(DATE_TIME) ) and the ! methods it supports and overloading of operators to support the new data type. ! use M_time , only : d2u , u2d , fmtdate , d2o , dow , fmtdate_usage , days2sec , realtime use M_time , only : j2d , d2j use M_time_duplicate , only : upper implicit none integer , parameter :: dp = kind ( 0.0d0 ) private private upper !----------------------------------------------------------------------------------------------------------------------------------- public date_time private dt2d_ private epoch_ private julian_ private ordinal private weekday private format private delta private init_dt !----------------------------------------------------------------------------------------------------------------------------------- !DERIVED TYPE DATE_TIME ! type date_time ! COMPONENTS: ! Eight integer element integer elements containing year, month, day, Time zone difference ! from UTC in minutes, hour, minutes, seconds, and milliseconds of the second in one-to-one ! correspondence with the elements of the array generated by the intrinsic function DATE_AND_TIME()... integer :: year = 1970 integer :: month = 1 integer :: day = 1 integer :: tz = 0 integer :: hour = 0 integer :: minute = 0 integer :: second = 0 integer :: millisecond = 0 contains ! METHODS: procedure :: datout => dt2d_ procedure :: epoch => epoch_ procedure :: julian => julian_ procedure :: ordinal procedure :: weekday procedure :: format procedure :: delta procedure :: init => init_dt !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(DATE_TIME) procedure , private :: plus_seconds generic :: operator ( + ) => plus_seconds procedure , private :: eq generic :: operator ( == ) => eq procedure , private :: lt generic :: operator ( < ) => lt procedure , private :: gt generic :: operator ( > ) => gt procedure , private :: ge generic :: operator ( >= ) => ge procedure , private :: le generic :: operator ( <= ) => le procedure , private :: ne generic :: operator ( /= ) => ne !-! procedure         :: construct_from_dat !-! generic           :: assignment(=)  => construct_from_dat procedure , private :: minus_seconds ! subtracts seconds, returns a new date_time procedure , private :: minus_date_time ! returns seconds generic :: operator ( - ) => minus_seconds generic :: operator ( - ) => minus_date_time end type !=================================================================================================================================== ! User-defined constructors are created by defining a generic interface ! with the same name as the derived type they're supposed to construct. interface date_time module procedure construct_from_dat !-!module procedure construct_from_jed !-!module procedure construct_from_uet end interface date_time !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! this function is used internally in the module, but is also declared to be a constructor for creating TYPE(DATE_TYPE) structures ! function construct_from_dat ( dat ) ! ident_1=\"@(#)M_time::construct_from_dat(3f): construct TYPE(DATE_TIME) with DAT date-time array\" integer , intent ( in ) :: dat (:) ! (maybe partial) date time array integer :: datlocal ( 8 ) ! date time array similar to that returned by DATE_AND_TIME type ( date_time ) :: construct_from_dat datlocal = u2d ( 0.0_dp ) ! initialize to start of Unix Epoch Time using local time zone if ( size ( dat ). gt . 0 ) then ! allow for partial DAT arrays datlocal (: size ( dat )) = dat endif construct_from_dat % year = datlocal ( 1 ) construct_from_dat % month = datlocal ( 2 ) construct_from_dat % day = datlocal ( 3 ) construct_from_dat % tz = datlocal ( 4 ) construct_from_dat % hour = datlocal ( 5 ) construct_from_dat % minute = datlocal ( 6 ) construct_from_dat % second = datlocal ( 7 ) construct_from_dat % millisecond = datlocal ( 8 ) end function construct_from_dat !=================================================================================================================================== function construct_from_jed ( jed ) ! ident_2=\"@(#)M_time::construct_from_jed(3f): construct TYPE(DATE_TIME) with REAL Julian JED date-time value\" real ( kind = realtime ), intent ( in ) :: jed type ( date_time ) :: construct_from_jed construct_from_jed = construct_from_dat ( j2d ( jed )) end function construct_from_jed !=================================================================================================================================== function construct_from_uet ( uet ) ! ident_3=\"@(#)M_time::construct_from_uet(3f): construct TYPE(DATE_TIME) with INTEGER Unix UET date-time value\" integer , intent ( in ) :: uet type ( date_time ) :: construct_from_uet construct_from_uet = construct_from_dat ( u2d ( real ( uet , kind = realtime ))) end function construct_from_uet !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! DEFINE THE METHODS FOR THE TYPE ! These functions are privately used to define the methods that TYPE(DATE_TIME) will support !=================================================================================================================================== function dt2d_ ( self ) result ( dat ) ! ident_4=\"@(#)M_time::dt2d_(3f): convert derived type date_time to DAT date-time array\" class ( date_time ), intent ( in ) :: self integer :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME dat = [ self % year , self % month , self % day , self % tz , self % hour , self % minute , self % second , self % millisecond ] end function dt2d_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function epoch_ ( self ) result ( epoch_seconds ) ! ident_5=\"@(#)M_time::epoch_(3f): convert derived type date_time to unix epoch seconds\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ) :: epoch_seconds epoch_seconds = d2u ( dt2d_ ( self )) end function epoch_ !=================================================================================================================================== function format ( self , fmt ) result ( string ) ! ident_6=\"@(#)M_time::format(3f): convert derived type date_time to formatted string\" class ( date_time ), intent ( in ) :: self character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: fmtlocal character ( len = :), allocatable :: string character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' character ( len =* ), parameter :: usa_fmt = '%W, %L %d, %Y %H:%m:%s %N' character ( len =* ), parameter :: ymd_fmt = '%Y-%M-%D %h:%m:%s.%x%z' character ( len =* ), parameter :: mdy_fmt = '%M/%D/%Y %h:%m:%s.%x%z' if ( present ( fmt )) then fmtlocal = fmt else fmtlocal = iso_fmt endif if ( index ( fmtlocal , '%' ). eq . 0 ) then ! if a percent(%) in string assume it is a string to be passed to fmtdate select case ( upper ( fmtlocal )) case ( \"ISO\" , \"ISO-8601\" , \"\" ); fmtlocal = iso_fmt case ( \"USA\" ); fmtlocal = usa_fmt case ( \"YMD\" ); fmtlocal = ymd_fmt case ( \"MDY\" ); fmtlocal = mdy_fmt case default !! usually used in a WRITE(3f) or PRINT(3f) so should not write output !write(*,*)'date_time%format: unknown format name' !write(*,*)'use predefined names (\"iso\",\"usa\",\"ymd\",\"mdy\")' !write(*,*)'or a user-supplied format including the following macros:' !call fmtdate_usage() !fmtlocal='date_time%format: unknown format name '//trim(fmtlocal)//'(not \"iso\",\"usa\",\"ymd\",\"mdy\" or %macros)'//iso_fmt end select endif string = fmtdate ( dt2d_ ( self ), fmtlocal ) end function format !=================================================================================================================================== function julian_ ( self ) result ( julian_days ) ! ident_7=\"@(#)M_time::julian_(3f): convert derived type date_time to julian date\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ) :: julian_days julian_days = d2j ( dt2d_ ( self )) end function julian_ !=================================================================================================================================== function ordinal ( self ) result ( ordinal_days ) ! ident_8=\"@(#)M_time::ordinal(3f): convert derived type date_time to ordinal date\" class ( date_time ), intent ( in ) :: self integer :: ordinal_days ordinal_days = d2o ( dt2d_ ( self )) end function ordinal !=================================================================================================================================== function weekday ( self ) result ( iday ) ! ident_9=\"@(#)M_time::weekday(3f): convert derived type date_time to weekday (1=Monday,7=Sunday)\" class ( date_time ), intent ( in ) :: self integer :: iday integer :: ierr ! Error return,0=correct,-1=invalid Julian Date,-2=neither day nor weekday specified call dow ( dt2d_ ( self ), weekday = iday , ierr = ierr ) end function weekday !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function delta ( self , year , month , day , tz , hour , minute , second , millisecond , week , duration ) ! ! allow keyword addition and subtraction from each member of a date_time object ! even though there is no specific size for month and year, this is conventionally what is meant by \"a year from now\" ! or \"a month from now\". Once the arbitrary values are used to change the original date_time value convert it to ! Epoch time and back to make sure you get a valid date. ! ident_10=\"@(#)M_time::delta(3f): add times to a type(date_time)\" class ( date_time ), intent ( in ) :: self integer , intent ( in ), optional :: year , month , day , tz , hour , minute , second , millisecond , week character ( len =* ), intent ( in ), optional :: duration type ( date_time ) :: delta delta = self if ( present ( year )) then ; delta % year = self % year + year ; else ; delta % year = self % year ; endif if ( present ( month )) then ; delta % month = self % month + month ; else ; delta % month = self % month ; endif if ( present ( day )) then ; delta % day = self % day + day ; else ; delta % day = self % day ; endif if ( present ( tz )) then ; delta % tz = self % tz + tz ; else ; delta % tz = self % tz ; endif if ( present ( hour )) then ; delta % hour = self % hour + hour ; else ; delta % hour = self % hour ; endif if ( present ( minute )) then ; delta % minute = self % minute + minute ; else ; delta % minute = self % minute ; endif if ( present ( second )) then ; delta % second = self % second + second ; else ; delta % second = self % second ; endif if ( present ( millisecond )) then ; delta % millisecond = self % millisecond + millisecond ; else ; delta % millisecond = self % millisecond ; endif if ( present ( week )) then ; delta % day = delta % day + week * 7 ; endif if ( present ( duration )) then ; delta % second = delta % second + int ( days2sec ( duration )) ; endif delta = construct_from_dat ( u2d ( d2u ( dt2d_ ( delta )))) ! to get a valid date after arbitrary math convert to Epoch and back end function delta !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine init_dt ( self , year , month , day , tz , hour , minute , second , millisecond , type , dat ) ! ! allow for date_time object to be initialized. Default is current time ! If the 8-element dat array is present use it to initialize the date_time object ! If not, initialize to the current time or start of epoch depending on TYPE=[\"now\"|\"epoch\"] ! Then, apply specific values, typically specified by keyword value ! ident_11=\"@(#)M_time::init_dt(3f): initialize TYPE(DATE_TIME)\" class ( date_time ) :: self type ( date_time ) :: holddt integer , intent ( in ), optional :: year , month , day , tz , hour , minute , second , millisecond character ( len =* ), intent ( in ), optional :: type integer , intent ( in ), optional :: dat ( 8 ) character ( len = 10 ) :: typelocal integer :: datlocal ( 8 ) if ( present ( dat )) then holddt = construct_from_dat ( dat ) else if ( present ( type )) then typelocal = type else typelocal = \"now\" endif select case ( typelocal ) case ( \"now\" , \"NOW\" ) call date_and_time ( values = datlocal ) ! current time is placed in array using standard procedure holddt = construct_from_dat ( datlocal ) ! convert date array to date_time type case ( \"epoch\" , \"EPOCH\" ) holddt = construct_from_dat ([ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) case default call date_and_time ( values = datlocal ) ! current time is placed in array using standard procedure holddt = construct_from_dat ( datlocal ) ! convert date array to date_time type end select endif if ( present ( year )) holddt % year = year if ( present ( month )) holddt % month = month if ( present ( day )) holddt % day = day if ( present ( tz )) holddt % tz = tz if ( present ( hour )) holddt % hour = hour if ( present ( minute )) holddt % minute = minute if ( present ( second )) holddt % second = second if ( present ( millisecond )) holddt % millisecond = millisecond holddt = construct_from_dat ( u2d ( d2u ( dt2d_ ( holddt )))) ! to get a valid date after arbitrary values convert to Epoch and back self % year = holddt % year self % month = holddt % month self % day = holddt % day self % tz = holddt % tz self % hour = holddt % hour self % minute = holddt % minute self % second = holddt % second self % millisecond = holddt % millisecond end subroutine init_dt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! FUNCTIONS FOR DEFINING OVERLOADED OPERATORS !=================================================================================================================================== function plus_seconds ( self , seconds ) result ( dattim ) ! ident_12=\"@(#)M_time::plus_seconds(3f): add derived type date_time object and seconds\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ), intent ( in ) :: seconds type ( date_time ) :: dattim ! convert TYPE(DATE_TIME) to a DAT array for input into d2u (DAT to UNIX time) and add seconds ! take the seconds (ie. the Unix Epoch time) and convert it back into a DAT array and call the ! construct_from_dat() function to convert the DAT array back to a TYPE(DATE_TIME) dattim = construct_from_dat ( u2d ( d2u ( dt2d_ ( self )) + seconds )) end function plus_seconds !=================================================================================================================================== function minus_seconds ( self , seconds ) result ( dattim ) ! ident_13=\"@(#)M_time::minus_seconds(3f): subtract seconds from derived type date_time object\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ), intent ( in ) :: seconds type ( date_time ) :: dattim dattim = construct_from_dat ( u2d ( d2u ( dt2d_ ( self )) - seconds )) end function minus_seconds !=================================================================================================================================== function minus_date_time ( self , other ) result ( seconds ) ! ident_14=\"@(#)M_time::minus_date_time(3f): add derived type date_time object and seconds\" class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other real ( kind = realtime ) :: seconds seconds = d2u ( dt2d_ ( self )) - d2u ( dt2d_ ( other )) end function minus_date_time !=================================================================================================================================== logical function eq ( self , other ) ! ident_15=\"@(#)M_time::eq(3f): compare derived type date_time objects (eq,lt,gt,le,ge,ne)\" class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other eq = int ( d2u ( dt2d_ ( self ))) . eq . int ( d2u ( dt2d_ ( other ))) end function eq logical function lt ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other lt = int ( d2u ( dt2d_ ( self ))) . lt . int ( d2u ( dt2d_ ( other ))) end function lt logical function gt ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other gt = int ( d2u ( dt2d_ ( self ))) . gt . int ( d2u ( dt2d_ ( other ))) end function gt logical function le ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other le = int ( d2u ( dt2d_ ( self ))) . le . int ( d2u ( dt2d_ ( other ))) end function le logical function ge ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other ge = int ( d2u ( dt2d_ ( self ))) . ge . int ( d2u ( dt2d_ ( other ))) end function ge logical function ne ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other ne = int ( d2u ( dt2d_ ( self ))) . ne . int ( d2u ( dt2d_ ( other ))) end function ne !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_time_oop","tags":"","loc":"sourcefile/m_time_oop.f90.html"},{"title":"M_time_duplicate.f90 – M_time","text":"Contents Modules M_time_duplicate Source Code M_time_duplicate.f90 Source Code module M_time_duplicate ! copy of other GPF routines used here public lower public substitute public upper public adjustc public compact public s2v public split public string_to_values public string_to_value public transliterate public v2s interface v2s module procedure d2s , r2s , i2s , l2s end interface interface string_to_value module procedure a2d , a2r , a2i end interface contains !> !!##NAME !!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes one substring for another in string !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine substitute(targetline,old,new,ierr,start,end) !! !!     character(len=*)              :: targetline !!     character(len=*),intent(in)   :: old !!     character(len=*),intent(in)   :: new !!     integer,intent(out),optional  :: ierr !!     integer,intent(in),optional   :: start !!     integer,intent(in),optional   :: end !!##DESCRIPTION !!   Globally substitute one substring for another in string. !! !!##OPTIONS !!     TARGETLINE  input line to be changed. Must be long enough to !!                 hold altered output. !!     OLD         substring to find and replace !!     NEW         replacement for OLD substring !!     IERR        error code. If IER = -1 bad directive, >= 0 then !!                 count of changes made. !!     START       sets the left margin to be scanned for OLD in !!                 TARGETLINE. !!     END         sets the right margin to be scanned for OLD in !!                 TARGETLINE. !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_substitute !!     use M_time, only : substitute !!     implicit none !!     ! must be long enough to hold changed line !!     character(len=80) :: targetline !! !!     targetline='this is the input string' !!     write(*,*)'ORIGINAL    : '//trim(targetline) !! !!     ! changes the input to 'THis is THe input string' !!     call substitute(targetline,'th','TH') !!     write(*,*)'th => TH    : '//trim(targetline) !! !!     ! a null old substring means \"at beginning of line\" !!     ! changes the input to 'BEFORE:this is the input string' !!     call substitute(targetline,'','BEFORE:') !!     write(*,*)'\"\" => BEFORE: '//trim(targetline) !! !!     ! a null new string deletes occurrences of the old substring !!     ! changes the input to 'ths s the nput strng' !!     call substitute(targetline,'i','') !!     write(*,*)'i => \"\"     : '//trim(targetline) !! !!     end program demo_substitute !! !!    Expected output !! !!     ORIGINAL    : this is the input string !!     th => TH    : THis is THe input string !!     \"\" => BEFORE: BEFORE:THis is THe input string !!     i => \"\"     : BEFORE:THs s THe nput strng !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine substitute ( targetline , old , new , ierr , start , end ) !character(len=*),parameter::ident_11=\"@(#)M_strings::substitute(3f): Globally substitute one substring for another in string\" !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ) :: targetline ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made integer , intent ( in ), optional :: start ! start sets the left margin integer , intent ( in ), optional :: end ! end sets the right margin !----------------------------------------------------------------------------------------------------------------------------------- character ( len = len ( targetline )) :: dum1 ! scratch string buffers integer :: ml , mr , ier1 integer :: maxlengthout ! MAXIMUM LENGTH ALLOWED FOR NEW STRING integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: ir integer :: ind integer :: il integer :: id integer :: ic integer :: ichar !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( start )) then ! optional starting column ml = start else ml = 1 endif if ( present ( end )) then ! optional ending column mr = end else mr = len ( targetline ) endif !----------------------------------------------------------------------------------------------------------------------------------- ier1 = 0 ! initialize error flag/change count maxlengthout = len ( targetline ) ! max length of output string original_input_length = len_trim ( targetline ) ! get non-blank length of input line dum1 (:) = ' ' ! initialize string to build output in id = mr - ml ! check for window option !x! change to optional parameter(s) !----------------------------------------------------------------------------------------------------------------------------------- len_old = len ( old ) ! length of old substring to be replaced len_new = len ( new ) ! length of new substring to replace old substring if ( id . le . 0 ) then ! no window so change entire input string il = 1 ! il is left margin of window to change ir = maxlengthout ! ir is right margin of window to change dum1 (:) = ' ' ! begin with a blank line else ! if window is set il = ml ! use left margin ir = min0 ( mr , maxlengthout ) ! use right margin or rightmost dum1 = targetline (: il - 1 ) ! begin with what's below margin endif ! end of window settings !----------------------------------------------------------------------------------------------------------------------------------- if ( len_old . eq . 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichar = len_new + original_input_length if ( ichar . gt . maxlengthout ) then call stderr ( '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( len_new . gt . 0 ) then dum1 ( il :) = new (: len_new ) // targetline ( il : original_input_length ) else dum1 ( il :) = targetline ( il : original_input_length ) endif targetline ( 1 : maxlengthout ) = dum1 (: maxlengthout ) ier1 = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ier1 return endif !----------------------------------------------------------------------------------------------------------------------------------- ichar = il ! place to put characters into output string ic = il ! place looking at in input string loop : do ind = index ( targetline ( ic :), old (: len_old )) + ic - 1 ! try to find start of old string in remaining part of input in change window if ( ind . eq . ic - 1. or . ind . gt . ir ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif ier1 = ier1 + 1 ! found an old string to change, so increment count of changes if ( ind . gt . ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output if ( ichar - 1 + ladd . gt . maxlengthout ) then ier1 =- 1 exit loop endif dum1 ( ichar :) = targetline ( ic : ind - 1 ) ichar = ichar + ladd endif if ( ichar - 1 + len_new . gt . maxlengthout ) then ier1 =- 2 exit loop endif if ( len_new . ne . 0 ) then dum1 ( ichar :) = new (: len_new ) ichar = ichar + len_new endif ic = ind + len_old enddo loop !----------------------------------------------------------------------------------------------------------------------------------- select case ( ier1 ) case (: - 1 ) call stderr ( '*substitute* new line will be too long' ) case ( 0 ) ! there were no changes made to the window case default ladd = original_input_length - ic if ( ichar + ladd . gt . maxlengthout ) then call stderr ( '*substitute* new line will be too long' ) ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( ic . lt . len ( targetline )) then dum1 ( ichar :) = targetline ( ic : max ( ic , original_input_length )) endif targetline = dum1 (: maxlengthout ) end select if ( present ( ierr )) ierr = ier1 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine substitute !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! upper(3f) - [M_strings:CASE] changes a string to uppercase !! (LICENSE:PD) !! !!##SYNOPSIS !! !!    elemental pure function upper(str,begin,end) result (string) !! !!     character(*), intent(in)    :: str !!     integer,optional,intent(in) :: begin,end !!     character(len(str))         :: string  ! output string !!##DESCRIPTION !!   upper(string) returns a copy of the input string with all characters !!   converted in the optionally specified range to uppercase, assuming !!   ASCII character sets are being used. If no range is specified the !!   entire string is converted to uppercase. !! !!##OPTIONS !!    str    string to convert to uppercase !!    begin  optional starting position in \"str\" to begin converting to uppercase !!    end    optional ending position in \"str\" to stop converting to uppercase !! !!##RESULTS !!    upper  copy of the input string with all characters converted to uppercase !!            over optionally specified range. !! !!##TRIVIA !!   The terms \"uppercase\" and \"lowercase\" date back to the early days of !!   the mechanical printing press. Individual metal alloy casts of each !!   needed letter, or punctuation symbol, were meticulously added to a !!   press block, by hand, before rolling out copies of a page. These !!   metal casts were stored and organized in wooden cases. The more !!   often needed miniscule letters were placed closer to hand, in the !!   lower cases of the work bench. The less often needed, capitalized, !!   majuscule letters, ended up in the harder to reach upper cases. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_upper !!     use M_time, only: upper !!     implicit none !!     character(len=:),allocatable  :: s !!        s=' ABCDEFG abcdefg ' !!        write(*,*) 'mixed-case input string is ....',s !!        write(*,*) 'upper-case output string is ...',upper(s) !!        write(*,*) 'make first character uppercase  ... ',upper('this is a sentence.',1,1) !!        write(*,'(1x,a,*(a:,\"+\"))') 'upper(3f) is elemental ==>',upper([\"abc\",\"def\",\"ghi\"]) !!     end program demo_upper !! !!    Expected output !! !!     mixed-case input string is .... ABCDEFG abcdefg !!     upper-case output string is ... ABCDEFG ABCDEFG !!     make first character uppercase  ... This is a sentence. !!     upper(3f) is elemental ==>ABC+DEF+GHI !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !=================================================================================================================================== elemental pure function upper ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_21=\"@(#)M_strings::upper(3f): Changes a string to uppercase\" character ( * ), intent ( In ) :: str ! inpout string to convert to all uppercase integer , intent ( in ), optional :: begin , end character ( len ( str )) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: ibegin , iend string = str ! initialize output string to input string ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'a' : 'z' ) ! located miniscule letter string ( i : i ) = char ( iachar ( str ( i : i )) - 32 ) ! change miniscule letter to uppercase end select end do end function upper !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    lower(3f) - [M_strings:CASE] changes a string to lowercase over specified range !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    elemental pure function lower(str,begin,end) result (string) !! !!     character(*), intent(in) :: str !!     integer,optional         :: begin, end !!     character(len(str))      :: string  ! output string !!##DESCRIPTION !!   lower(string) returns a copy of the input string with all characters !!   converted to miniscule over the specified range, assuming ASCII !!   character sets are being used. If no range is specified the entire !!   string is converted to miniscule. !! !!##OPTIONS !!    str    string to convert to miniscule !!    begin  optional starting position in \"str\" to begin converting to miniscule !!    end    optional ending position in \"str\" to stop converting to miniscule !! !!##RESULTS !!    lower  copy of the input string with all characters converted to miniscule !!           over optionally specified range. !! !!##TRIVIA !!    The terms \"uppercase\" and \"lowercase\" date back to the early days of !!    the mechanical printing press. Individual metal alloy casts of each !!    needed letter, or punctuation symbol, were meticulously added to a !!    press block, by hand, before rolling out copies of a page. These !!    metal casts were stored and organized in wooden cases. The more !!    often needed miniscule letters were placed closer to hand, in the !!    lower cases of the work bench. The less often needed, capitalized, !!    majuscule letters, ended up in the harder to reach upper cases. !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_lower !!     use M_time, only: lower !!     implicit none !!     character(len=:),allocatable  :: s !!        s=' ABCDEFG abcdefg ' !!        write(*,*) 'mixed-case input string is ....',s !!        write(*,*) 'lower-case output string is ...',lower(s) !!     end program demo_lower !! !!    Expected output !! !!       mixed-case input string is .... ABCDEFG abcdefg !!       lower-case output string is ... abcdefg abcdefg !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== elemental pure function lower ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_22=\"@(#)M_strings::lower(3f): Changes a string to lowercase over specified range\" character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = char ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine stderr ( string ) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT character ( len =* ) :: string write ( ERROR_UNIT , '(a)' ) string end subroutine stderr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!       adjustc(3f) - [M_strings:WHITESPACE] center text !!       (LICENSE:PD) !! !!##SYNOPSIS !! !!   pure function adjustc(string[,length]) !! !!    character(len=*),intent(in)  :: string !!    integer,intent(in),optional  :: length !!    character(len=:),allocatable :: adjustc !!##DESCRIPTION !!   Centers input text in a string of the length specified. Returns a !!   string of length LENGTH if LENGTH is present. Otherwise returns a !!   string of the length of the input string. !!##OPTIONS !!     string  input string to trim and center !!     length  line length to center text in, optional. !!##RETURNS !!     adjustc  centered output string !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_adjustc !!     use M_strings, only : adjustc !!     !  using length of the input string !!        write(*,'(a)')       '================================' !!        write(*,'(a)')adjustc('centered string                 ') !!        write(*,'(a)')adjustc('                 centered string') !!        write(*,'(a)')adjustc('  centered string               ') !!     !  using explicit output string length !!        write(*,'(a)')repeat('=',50) !!        write(*,'(a)')adjustc('this is a centered string',50) !!        write(*,'(a)')repeat('=',50) !!     end program demo_adjustc !! !!    Expected output: !! !!     \\================================ !!             centered string !!             centered string !!             centered string !!     \\================================================== !!                 this is a centered string !!     \\================================================== !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== pure function adjustc ( string , length ) !character(len=*),parameter::ident_32=\"@(#)M_strings::adjustc(3f): center text\" !> !! PROCEDURE   adjustc(3f) !! DESCRIPTION center text using implicit or explicit length !!##VERSION     2.0, 20160711 !! AUTHOR      John S. Urban !=================================================================================================================================== !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string ! input string to trim and center integer , intent ( in ), optional :: length ! line length to center text in character ( len = :), allocatable :: adjustc ! output string integer :: inlen integer :: ileft ! left edge of string if it is centered !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( length )) then ! optional length inlen = length ! length will be requested length if ( inlen . le . 0 ) then ! bad input length inlen = len ( string ) ! could not use input value, fall back to length of input string endif else ! output length was not explicitly specified, use input string length inlen = len ( string ) endif allocate ( character ( len = inlen ) :: adjustc ) ! create output at requested length adjustc ( 1 : inlen ) = ' ' ! initialize output string to all blanks !----------------------------------------------------------------------------------------------------------------------------------- ileft = ( inlen - len_trim ( adjustl ( string ))) / 2 ! find starting point to start input string to center it if ( ileft . gt . 0 ) then ! if string will fit centered in output adjustc ( ileft + 1 : inlen ) = adjustl ( string ) ! center the input text in the output string else ! input string will not fit centered in output string adjustc ( 1 : inlen ) = adjustl ( string ) ! copy as much of input to output as can endif end function adjustc !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function compact(STR,CHAR) result (OUTSTR) !! !!     character(len=*),intent(in)          :: STR !!     character(len=*),intent(in),optional :: CHAR !!     character(len=len(str))              :: OUTSTR !!##DESCRIPTION !!   COMPACT(3f) converts multiple spaces, tabs and control characters !!   (called \"whitespace\") to a single character or nothing. Leading !!   whitespace is removed. !! !!##OPTIONS !!    STR     input string to reduce or remove whitespace from !!    CHAR    By default the character that replaces adjacent !!            whitespace is a space. If the optional CHAR parameter is supplied !!            it will be used to replace the whitespace. If a null character is !!            supplied for CHAR whitespace is removed. !!##RETURNS !!    OUTSTR  string of same length as input string but with all contiguous whitespace !!            reduced to a single space and leading whitespace removed !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_compact !!     use M_strings, only : compact !!     implicit none !!     ! produces 'This is a test               ' !!     write(*,*)compact('  This     is      a     test  ') !!     ! produces 'Thisisatest                  ' !!     write(*,*)compact('  This     is      a     test  ',char='') !!     ! produces 'This:is:a:test               ' !!     write(*,*)compact('  This     is      a     test  ',char=':') !!     ! note CHAR is used to replace the whitespace, but if CHAR is !!     ! in the original string it is just copied !!     write(*,*)compact('A  AA    A   AAAAA',char='A') !!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA' !!     ! not 'A' !!     end program demo_compact !! !!    Expected output !! !!     >This is a test !!     >Thisisatest !!     >This:is:a:test !!     >AAAAAAAAAAAA !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !elemental pure function compact(str,char) result (outstr) function compact ( str , char ) result ( outstr ) !character(len=*),parameter::ident_38=\"@(#)M_strings::compact(3f): Converts white-space to single spaces\" character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ), optional :: char character ( len = len ( str )) :: outstr character ( len = 1 ) :: ch integer :: i integer :: position_in_output logical :: last_was_space character ( len = 1 ) :: char_p logical :: nospace if ( present ( char )) then char_p = char if ( len ( char ). eq . 0 ) then nospace = . true . else nospace = . false . endif else char_p = ' ' nospace = . false . endif outstr = ' ' last_was_space = . false . position_in_output = 0 IFSPACE : do i = 1 , len_trim ( str ) ch = str ( i : i ) select case ( ichar ( ch )) case ( 0 : 32 , 127 ) ! space or tab character or control character if ( position_in_output . eq . 0 ) then ! still at beginning so ignore leading whitespace cycle IFSPACE elseif (. not . last_was_space ) then ! if have not already put out a space output one if (. not . nospace ) then position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = char_p endif endif last_was_space = . true . case (: - 1 , 33 : 126 , 128 :) ! not a space, quote, or control character so copy it position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = ch last_was_space = . false . end select end do IFSPACE end function compact !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      s2v(3f) - [M_strings:NUMERIC] function returns doubleprecision numeric value from a string !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    function s2v(string[,ierr][,onerr]) !! !!     character(len=*)             :: string !!     doubleprecision              :: s2v !!     integer,intent(out),optional :: ierr !!     class(*),intent(in),optional :: onerr !!##DESCRIPTION !!   This function converts a string to a DOUBLEPRECISION numeric value. !! !!   The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended to take !!   CHARACTER variables. The KIND= keyword is not supported on the extensions. !!##OPTIONS !! !!     string   holds string assumed to represent a numeric value !!     ierr     If an error occurs the program is stopped if the optional !!              parameter IERR is not present. If IERR returns a non-zero !!              value an error occurred. !!     onerr    The value to return on error. A value of zero (NaN) is !!              returned on error by default. !!##RETURNS !!     s2v !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_s2v !! !!     use M_strings, only: s2v, int, real, dble !!     implicit none !!     character(len=8)              :: s=' 10.345 ' !!     integer                       :: i !!     character(len=14),allocatable :: strings(:) !!     doubleprecision               :: dv !!     integer                       :: errnum !! !!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION !!     strings=[& !!     &' 10.345       ',& !!     &'+10           ',& !!     &'    -3        ',& !!     &'    -4.94e-2  ',& !!     &'0.1           ',& !!     &'12345.678910d0',& !!     &'              ',& ! Note: will return zero without an error message !!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored !!     &'WHAT?         ']  ! Note: error messages will appear, zero returned !! !!     ! a numeric value is returned, so it can be used in numeric expression !!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0 !!     write(*,*) !!     write(*,*)' STRING            VALUE                    ERROR_NUMBER' !!     do i=1,size(strings) !!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement, !!        ! as it does I/O when errors occur, so called on a separate line !!        dv=s2v(strings(i),errnum) !!        write(*,*) strings(i)//'=',dv,errnum !!     enddo !!     write(*,*)\"Extended intrinsics\" !!     write(*,*)'given inputs:',s,strings(:8) !!     write(*,*)'INT(3f):',int(s),int(strings(:8)) !!     write(*,*)'REAL(3f):',real(s),real(strings(:8)) !!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8)) !!     write(*,*)\"That's all folks!\" !! !!     end program demo_s2v !! !!    Expected output !! !!     >1/2 value of string is    5.1725000000000003 !!     > !!     > STRING            VALUE                    ERROR_NUMBER !!     > 10.345       =   10.345000000000001                0 !!     >+10           =   10.000000000000000                0 !!     >    -3        =  -3.0000000000000000                0 !!     >    -4.94e-2  =  -4.9399999999999999E-002           0 !!     >0.1           =  0.10000000000000001                0 !!     >12345.678910d0=   12345.678910000001                0 !!     >              =   0.0000000000000000                0 !!     >1 2 1 2 1 . 0 =   12121.000000000000                0 !!     >*a2d* - cannot produce number from string [WHAT?] !!     >*a2d* - [Bad value during floating point read] !!     >WHAT?         =   0.0000000000000000             5010 !!     >Extended intrinsics !!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1 12345.678910d0 1 2 1 2 1 . 0 !!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121 !!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000 -4.94000018E-02 !!     >          0.100000001 12345.6787 0.00000000 12121.0000 !!     >DBLE(3f): 10.345000000000001 10.345000000000001 10.000000000000000 !!     >          -3.0000000000000000 -4.9399999999999999E-002 0.10000000000000001 !!     >          12345.678910000001 0.0000000000000000 12121.000000000000 !!     >That's all folks! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !> !!##PROCEDURE: !! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs !!##VERSION:     2.0, 20160704 !! AUTHOR:      John S. Urban !=================================================================================================================================== doubleprecision function s2v ( chars , ierr , onerr ) !  1989 John S. Urban !character(len=*),parameter::ident_43=\"@(#)M_strings::s2v(3f): returns doubleprecision number from string\" character ( len =* ), intent ( in ) :: chars integer , optional :: ierr doubleprecision :: valu integer :: ierr_local class ( * ), intent ( in ), optional :: onerr ierr_local = 0 if ( present ( onerr )) then call a2d ( chars , valu , ierr_local , onerr ) else call a2d ( chars , valu , ierr_local ) endif if ( present ( ierr )) then ! if error is not returned stop program on error ierr = ierr_local s2v = valu elseif ( ierr_local . ne . 0 ) then write ( * , * ) '*s2v* stopped while reading ' // trim ( chars ) stop 1 else s2v = valu endif end function s2v !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    split(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine split(input_line,array,delimiters,order,nulls) !! !!     character(len=*),intent(in)              :: input_line !!     character(len=:),allocatable,intent(out) :: array(:) !!     character(len=*),optional,intent(in)     :: delimiters !!     character(len=*),optional,intent(in)     :: order !!     character(len=*),optional,intent(in)     :: nulls !!##DESCRIPTION !!   SPLIT(3f) parses a string using specified delimiter characters and !!   store tokens into an allocatable array !! !!##OPTIONS !! !!    INPUT_LINE  Input string to tokenize !! !!    ARRAY       Output array of tokens !! !!    DELIMITERS  List of delimiter characters. !!                The default delimiters are the \"whitespace\" characters !!                (space, tab,new line, vertical tab, formfeed, carriage !!                return, and null). You may specify an alternate set of !!                delimiter characters. !! !!                Multi-character delimiters are not supported (Each !!                character in the DELIMITERS list is considered to be !!                a delimiter). !! !!                Quoting of delimiter characters is not supported. !! !!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array. !!                By default ARRAY contains the tokens having parsed !!                the INPUT_LINE from left to right. If ORDER='RIGHT' !!                or ORDER='REVERSE' the parsing goes from right to left. !! !!    NULLS IGNORE|RETURN|IGNOREEND  Treatment of null fields. !!                By default adjacent delimiters in the input string !!                do not create an empty string in the output array. if !!                NULLS='return' adjacent delimiters create an empty element !!                in the output ARRAY. If NULLS='ignoreend' then only !!                trailing delimiters at the right of the string are ignored. !! !!##EXAMPLES !! !!  Sample program: !! !!       program demo_split !!       use M_strings, only: split !!       character(len=*),parameter     :: & !!       & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ' !!       character(len=:),allocatable :: array(:) ! output array of tokens !!          write(*,*)'INPUT LINE:['//LINE//']' !!          write(*,'(80(\"=\"))') !!          write(*,*)'typical call:' !!          CALL split(line,array) !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!          write(*,'(80(\"-\"))') !!          write(*,*)'custom list of delimiters (colon and vertical line):' !!          CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore') !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!          write(*,'(80(\"-\"))') !!          write(*,*)& !!          &'custom list of delimiters, reverse array order and count null fields:' !!          CALL split(line,array,delimiters=':|',order='reverse',nulls='return') !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!          write(*,'(80(\"-\"))') !!          write(*,*)'INPUT LINE:['//LINE//']' !!          write(*,*)& !!          &'default delimiters and reverse array order and return null fields:' !!          CALL split(line,array,delimiters='',order='reverse',nulls='return') !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!      end program demo_split !! !!   Output !! !!        > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ] !!        > =========================================================================== !!        >  typical call: !!        > 1 ==> aBcdef !!        > 2 ==> ghijklmnop !!        > 3 ==> qrstuvwxyz !!        > 4 ==> 1:|:2 !!        > 5 ==> 333|333 !!        > 6 ==> a !!        > 7 ==> B !!        > 8 ==> cc !!        >  SIZE:           8 !!        > -------------------------------------------------------------------------- !!        >  custom list of delimiters (colon and vertical line): !!        > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1 !!        > 2 ==> 2     333 !!        > 3 ==> 333 a B cc !!        >  SIZE:           3 !!        > -------------------------------------------------------------------------- !!        >  custom list of delimiters, reverse array order and return null fields: !!        > 1 ==> 333 a B cc !!        > 2 ==> 2     333 !!        > 3 ==> !!        > 4 ==> !!        > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1 !!        >  SIZE:           5 !!        > -------------------------------------------------------------------------- !!        >  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ] !!        >  default delimiters and reverse array order and count null fields: !!        > 1 ==> !!        > 2 ==> !!        > 3 ==> !!        > 4 ==> cc !!        > 5 ==> B !!        > 6 ==> a !!        > 7 ==> 333|333 !!        > 8 ==> !!        > 9 ==> !!        > 10 ==> !!        > 11 ==> !!        > 12 ==> 1:|:2 !!        > 13 ==> !!        > 14 ==> qrstuvwxyz !!        > 15 ==> ghijklmnop !!        > 16 ==> !!        > 17 ==> !!        > 18 ==> aBcdef !!        > 19 ==> !!        > 20 ==> !!        >  SIZE:          20 !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine split ( input_line , array , delimiters , order , nulls ) !----------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_7=\"& !&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array\" !  John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- intrinsic index , min , present , len !----------------------------------------------------------------------------------------------------------------------------------- !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens !----------------------------------------------------------------------------------------------------------------------------------- integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token !----------------------------------------------------------------------------------------------------------------------------------- ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters . ne . '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // char ( 9 ) // char ( 10 ) // char ( 11 ) // char ( 12 ) // char ( 13 ) // char ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter !----------------------------------------------------------------------------------------------------------------------------------- n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 !----------------------------------------------------------------------------------------------------------------------------------- ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found !----------------------------------------------------------------------------------------------------------------------------------- select case ( ilen ) !----------------------------------------------------------------------------------------------------------------------------------- case (: 0 ) ! command was totally blank !----------------------------------------------------------------------------------------------------------------------------------- case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )). eq . 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound . gt . 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol . gt . ilen ) then ! no text left exit INFINITE endif enddo INFINITE !----------------------------------------------------------------------------------------------------------------------------------- end select !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select !----------------------------------------------------------------------------------------------------------------------------------- do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ). lt . ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo !----------------------------------------------------------------------------------------------------------------------------------- end subroutine split !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      string_to_values(3f) - [M_strings:NUMERIC] read a string representing numbers into a numeric array !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       subroutine string_to_values(line,iread,values,inums,delims,ierr) !! !!        character(len=*) :: line !!        integer          :: iread !!        real             :: values(*) !!        integer          :: inums !!        character(len=*) :: delims !!        integer          :: ierr !!##DESCRIPTION !!   This routine can take a string representing a series of numbers and !!   convert it to a numeric array and return how many numbers were found. !! !!##OPTIONS !! !!       LINE     Input string containing numbers !!       IREAD    maximum number of values to try to read from input string !! !!##RESULTS !! !!       VALUES   real array to be filled with numbers !!       INUMS    number of values successfully read (before error occurs !!                if one does) !!       DELIMS   delimiter character(s), usually a space. must not be a !!                null string. If more than one character, a space must !!                not be the last character or it will be ignored. !!       IERR     error flag (0=no error, else column number string starts !!                at that error occurred on). !! !!##EXAMPLE !! !!  Sample Program: !! !!       program demo_string_to_values !!        use M_strings, only : string_to_values !!        character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 ' !!        integer,parameter  :: isz=10 !!        real               :: array(isz) !! !!        call string_to_values(s,10,array,inums,' ;',ierr) !!        call reportit() !! !!        call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr) !!        call reportit() !! !!        contains !!           subroutine reportit() !!              write(*,*)'string_to_values:' !!              write(*,*)'input string.............',trim(s) !!              write(*,*)'number of values found...',inums !!              write(*,*)'values...................',(array(ii),ii=1,inums) !!           end subroutine reportit !!       end program demo_string_to_values !! !!    Expected output !! !!        string_to_values: !!        input string............. 10 20e3;3.45 -400.3e-2;1234; 5678 !!        number of values found...           6 !!        values...................   10.0000000  20000.0000  3.45000005  -4.00299978  1234.00000  5678.00000 !!        string_to_values: !!        input string............. 10 20e3;3.45 -400.3e-2;1234; 5678 !!        number of values found...           3 !!        values...................   10.0000000  2.29999995  3.14159989 !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine string_to_values ( line , iread , values , inums , delims , ierr ) implicit none !---------------------------------------------------------------------------------------------------------------------------------- !   1989,1997-12-31,2014 John S. Urban !   given a line of structure , string , string , string process each !   string as a numeric value and store into an array. !   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS. !   There is no direct checking for more values than can fit in VALUES. !   Quits if encounters any errors in read. !---------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_54=\"@(#)M_strings::string_to_values(3f): reads an array of numbers from a numeric string\" character ( len =* ), intent ( in ) :: line ! input string integer , intent ( in ) :: iread ! maximum number of values to try to read into values real , intent ( inout ) :: values ( iread ) ! real array to be filled with values integer , intent ( out ) :: inums ! number of values successfully read from string character ( len =* ), intent ( in ) :: delims ! allowed delimiters integer , intent ( out ) :: ierr ! 0 if no error, else column number undecipherable string starts at !---------------------------------------------------------------------------------------------------------------------------------- character ( len = 256 ) :: delims_local ! mutable copy of allowed delimiters integer :: istart , iend , ilen , icol integer :: i10 , i20 , i40 real :: rval integer :: ier integer :: delimiters_length !---------------------------------------------------------------------------------------------------------------------------------- delims_local = delims ! need a mutable copy of the delimiter list if ( delims_local . eq . '' ) then ! if delimiter list is null or all spaces make it a space delims_local = ' ' ! delimiter is a single space delimiters_length = 1 ! length of delimiter list else delimiters_length = len_trim ( delims ) ! length of variable WITH TRAILING WHITESPACE TRIMMED endif !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error code returned inums = 0 ! initialize count of values successfully returned istart = 0 !---------------------------------------------------------------------------------------------------------------------------------- ilen = 0 ! ilen will be the position of the right-most non-delimiter in the input line do i20 = len ( line ), 1 , - 1 ! loop from end of string to beginning to find right-most non-delimiter if ( index ( delims_local (: delimiters_length ), line ( i20 : i20 )). eq . 0 ) then ! found a non-delimiter ilen = i20 exit endif enddo if ( ilen . eq . 0 ) then ! command was totally composed of delimiters call stderr ( '*string_to_values* blank line passed as a list of numbers' ) return endif !---------------------------------------------------------------------------------------------------------------------------------- !     there is at least one non-delimiter sub-string !     ilen is the column position of the last non-delimiter character !     now, starting at beginning of string find next non-delimiter icol = 1 ! pointer to beginning of unprocessed part of LINE LOOP : dO i10 = 1 , iread , 1 ! each pass should find a value if ( icol . gt . ilen ) EXIT LOOP ! everything is done INFINITE : do if ( index ( delims_local (: delimiters_length ), line ( icol : icol )). eq . 0 ) then ! found non-delimiter istart = icol iend = 0 ! FIND END OF SUBSTRING do i40 = istart , ilen ! look at each character starting at left if ( index ( delims_local (: delimiters_length ), line ( i40 : i40 )). ne . 0 ) then ! determine if character is a delimiter iend = i40 ! found a delimiter. record where it was found EXIT ! found end of substring so leave loop endif enddo if ( iend . eq . 0 ) iend = ilen + 1 ! no delimiters found, so this substring goes to end of line iend = iend - 1 ! do not want to pass delimiter to be converted rval = 0.0 call string_to_value ( line ( istart : iend ), rval , ier ) ! call procedure to convert string to a numeric value if ( ier . eq . 0 ) then ! a substring was successfully converted to a numeric value values ( i10 ) = rval ! store numeric value in return array inums = inums + 1 ! increment number of values converted to a numeric value else ! an error occurred converting string to value ierr = istart ! return starting position of substring that could not be converted return endif icol = iend + 2 ! set to next character to look at CYCLE LOOP ! start looking for next value else ! this is a delimiter so keep looking for start of next string icol = icol + 1 ! increment pointer into LINE CYCLE INFINITE endif enddo INFINITE enddo LOOP !     error >>>>> more than iread numbers were in the line. end subroutine string_to_values !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    transliterate(3f) - [M_strings:EDITING] replace characters from old set with new set !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    pure function transliterate(instr,old_set,new_set) result(outstr) !! !!     character(len=*),intent(in)  :: instr !!     character(len=*),intent(in)  :: old_set !!     character(len=*),intent(in)  :: new_set !!     character(len=len(instr))    :: outstr !!##DESCRIPTION !!   Translate, squeeze, and/or delete characters from the input string. !! !!##OPTIONS !!    instr    input string to change !!    old_set  list of letters to change in INSTR if found !! !!             Each character in the input string that matches a character in !!             the old set is replaced. !!    new_set  list of letters to replace letters in OLD_SET with. !! !!             If the new_set is the empty set the matched characters are deleted. !! !!             If the new_set is shorter than the old set the last character in the !!             new set is used to replace the remaining characters in the new set. !!##RETURNS !!    outstr   instr with substitutions applied !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_transliterate !! !!     use M_strings, only : transliterate !!     implicit none !!     character(len=80)   :: STRING !! !!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ' !!     write(*,'(a)') STRING !! !!     ! convert a string to uppercase: !!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ') !! !!     ! change all miniscule letters to a colon (\":\"): !!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz',':') !! !!     ! delete all miniscule letters !!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','') !! !!     end program demo_transliterate !! !!    Expected output !! !!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ !!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ !!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z !!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== PURE FUNCTION transliterate ( instr , old_set , new_set ) RESULT ( outstr ) !character(len=*),parameter::ident_16=\"@(#)M_strings::transliterate(3f): replace characters from old set with new set\" !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input string to change CHARACTER ( LEN =* ), intent ( in ) :: old_set CHARACTER ( LEN =* ), intent ( in ) :: new_set !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN = LEN ( instr )) :: outstr ! output string to generate !----------------------------------------------------------------------------------------------------------------------------------- INTEGER :: i10 ! loop counter for stepping thru string INTEGER :: ii , jj !----------------------------------------------------------------------------------------------------------------------------------- jj = LEN ( new_set ) IF ( jj . NE . 0 ) THEN outstr = instr ! initially assume output string equals input string stepthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii . NE . 0 ) THEN if ( ii . le . jj ) then ! use corresponding character in new_set outstr ( i10 : i10 ) = new_set ( ii : ii ) else outstr ( i10 : i10 ) = new_set ( jj : jj ) ! new_set not as long as old_set; use last character in new_set endif ENDIF ENDDO stepthru else ! new_set is null string so delete characters in old_set outstr = ' ' hopthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii . EQ . 0 ) THEN ! only keep characters not in old_set jj = jj + 1 outstr ( jj : jj ) = instr ( i10 : i10 ) ENDIF ENDDO hopthru endif END FUNCTION transliterate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      v2s(3f) - [M_strings:NUMERIC] return numeric string from a numeric value !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       function v2s(value) result(outstr) !! !!        integer|real|doubleprecision|logical,intent(in ) :: value !!        character(len=:),allocatable :: outstr !!        character(len=*),optional,intent(in) :: fmt !! !!##DESCRIPTION !! !!   v2s(3f) returns a representation of a numeric value as a !!   string when given a numeric value of type REAL, DOUBLEPRECISION, !!   INTEGER or LOGICAL. It creates the strings using internal WRITE() !!   statements. Trailing zeros are removed from non-zero values, and the !!   string is left-justified. !! !!##OPTIONS !!    VALUE   input value to be converted to a string !!    FMT     format can be explicitly given, but is limited to !!            generating a string of eighty or less characters. !! !!##RETURNS !!    OUTSTR  returned string representing input value, !! !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_v2s !!     use M_strings, only: v2s !!     write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']' !!     write(*,*) 'The value of 1234    is ['//v2s(1234)//']' !!     write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']' !!     write(*,*) 'The value of .false. is ['//v2s(.false.)//']' !!     write(*,*) 'The value of .true. is  ['//v2s(.true.)//']' !!     end program demo_v2s !! !!    Expected output !! !!     The value of 3.0/4.0 is [0.75] !!     The value of 1234    is [1234] !!     The value of 0d0     is [0] !!     The value of .false. is [F] !!     The value of .true. is  [T] !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== function d2s ( dvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_45=\"@(#)M_strings::d2s(3fp): private function returns string given doubleprecision value\" doubleprecision , intent ( in ) :: dvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( dvalue , string , fmt = fmt ) else call value_to_string ( dvalue , string ) endif outstr = trim ( string ) end function d2s !=================================================================================================================================== function r2s ( rvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_46=\"@(#)M_strings::r2s(3fp): private function returns string given real value\" real , intent ( in ) :: rvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( rvalue , string , fmt = fmt ) else call value_to_string ( rvalue , string ) endif outstr = trim ( string ) end function r2s !=================================================================================================================================== function i2s ( ivalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_47=\"@(#)M_strings::i2s(3fp): private function returns string given integer value\" integer , intent ( in ) :: ivalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( ivalue , string , fmt = fmt ) else call value_to_string ( ivalue , string ) endif outstr = trim ( string ) end function i2s !=================================================================================================================================== function l2s ( lvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_48=\"@(#)M_strings::l2s(3fp): private function returns string given logical value\" logical , intent ( in ) :: lvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( lvalue , string , fmt = fmt ) else call value_to_string ( lvalue , string ) endif outstr = trim ( string ) end function l2s !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      value_to_string(3f) - [M_strings:NUMERIC] return numeric string from a numeric value !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine value_to_string(value,chars[,ilen,ierr,fmt,trimz]) !! !!     character(len=*) :: chars  ! minimum of 23 characters required !!     !-------- !!     ! VALUE may be any <em>one</em> of the following types: !!     doubleprecision,intent(in)               :: value !!     real,intent(in)                          :: value !!     integer,intent(in)                       :: value !!     logical,intent(in)                       :: value !!     !-------- !!     character(len=*),intent(out)             :: chars !!     integer,intent(out),optional             :: ilen !!     integer,optional                         :: ierr !!     character(len=*),intent(in),optional     :: fmt !!     logical,intent(in)                       :: trimz !!##DESCRIPTION !! !!   value_to_string(3f) returns a numeric representation of a numeric !!   value in a string given a numeric value of type REAL, DOUBLEPRECISION, !!   INTEGER or LOGICAL. It creates the string using internal writes. It !!   then removes trailing zeros from non-zero values, and left-justifies !!   the string. !! !!##OPTIONS !!       VALUE   input value to be converted to a string !!       FMT     You may specify a specific format that produces a string !!               up to the length of CHARS; optional. !!       TRIMZ   If a format is supplied the default is not to try to trim !!               trailing zeros. Set TRIMZ to .true. to trim zeros from a !!               string assumed to represent a simple numeric value. !! !!##RETURNS !!       CHARS   returned string representing input value, must be at least !!               23 characters long; or what is required by optional FMT if longer. !!       ILEN    position of last non-blank character in returned string; optional. !!       IERR    If not zero, error occurred; optional. !!##EXAMPLE !! !!    Sample program: !! !!      program demo_value_to_string !!      use M_strings, only: value_to_string !!      implicit none !!      character(len=80) :: string !!      integer           :: ilen !!         call value_to_string(3.0/4.0,string,ilen) !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(3.0/4.0,string,ilen,fmt='') !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(3.0/4.0,string,ilen,fmt='(\"THE VALUE IS \",g0)') !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(1234,string,ilen) !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(1.0d0/3.0d0,string,ilen) !!         write(*,*) 'The value is [',string(:ilen),']' !! !!      end program demo_value_to_string !! !!    Expected output !! !!     The value is [0.75] !!     The value is [      0.7500000000] !!     The value is [THE VALUE IS .750000000] !!     The value is [1234] !!     The value is [0.33333333333333331] !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !=================================================================================================================================== subroutine value_to_string ( gval , chars , length , err , fmt , trimz ) !character(len=*),parameter::ident_40=\"@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value\" class ( * ), intent ( in ) :: gval character ( len =* ), intent ( out ) :: chars integer , intent ( out ), optional :: length integer , optional :: err integer :: err_local character ( len =* ), optional , intent ( in ) :: fmt ! format to write value with logical , intent ( in ), optional :: trimz character ( len = :), allocatable :: fmt_local character ( len = 1024 ) :: msg !  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL) if ( present ( fmt )) then select type ( gval ) type is ( integer ) fmt_local = '(i0)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( real ) fmt_local = '(bz,g23.10e3)' fmt_local = '(bz,g0.8)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) fmt_local = '(bz,g0)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( logical ) fmt_local = '(l1)' if ( fmt . ne . '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval class default call stderr ( '*value_to_string* UNKNOWN TYPE' ) chars = ' ' end select if ( fmt . eq . '' ) then chars = adjustl ( chars ) call trimzeros ( chars ) endif else ! no explicit format option present err_local =- 1 select type ( gval ) type is ( integer ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( real ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( logical ) write ( chars , * , iostat = err_local , iomsg = msg ) gval class default chars = '' end select chars = adjustl ( chars ) if ( index ( chars , '.' ). ne . 0 ) call trimzeros ( chars ) endif if ( present ( trimz )) then if ( trimz ) then chars = adjustl ( chars ) call trimzeros ( chars ) endif endif if ( present ( length )) then length = len_trim ( chars ) endif if ( present ( err )) then err = err_local elseif ( err_local . ne . 0 ) then !x! cannot currently do I/O from a function being called from I/O !x!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']' chars = chars // ' *value_to_string* WARNING:[' // trim ( msg ) // ']' endif end subroutine value_to_string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    trimzeros(3fp) - [M_strings:NUMERIC] Delete trailing zeros from numeric decimal string !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine trimzeros(str) !! !!     character(len=*)  :: str !!##DESCRIPTION !!   TRIMZEROS(3f) deletes trailing zeros from a string representing a !!   number. If the resulting string would end in a decimal point, one !!   trailing zero is added. !!##OPTIONS !!    str   input string will be assumed to be a numeric value and have trailing !!          zeros removed !!##EXAMPLES !! !!    Sample program: !! !!       program demo_trimzeros !!       use M_strings, only : trimzeros !!       character(len=:),allocatable :: string !!          write(*,*)trimzeros('123.450000000000') !!          write(*,*)trimzeros('12345') !!          write(*,*)trimzeros('12345.') !!          write(*,*)trimzeros('12345.00e3') !!       end program demo_trimzeros !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine trimzeros ( string ) !character(len=*),parameter::ident_50=\"@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string\" ! if zero needs added at end assumes input string has room character ( len =* ) :: string character ( len = len ( string ) + 2 ) :: str character ( len = len ( string )) :: exp ! the exponent string if present integer :: ipos ! where exponent letter appears if present integer :: i , ii str = string ! working copy of string ipos = scan ( str , 'eEdD' ) ! find end of real number if string uses exponent notation if ( ipos > 0 ) then ! letter was found exp = str ( ipos :) ! keep exponent string so it can be added back as a suffix str = str ( 1 : ipos - 1 ) ! just the real part, exponent removed will not have trailing zeros removed endif if ( index ( str , '.' ). eq . 0 ) then ! if no decimal character in original string add one to end of string ii = len_trim ( str ) str ( ii + 1 : ii + 1 ) = '.' ! add decimal to end of string endif do i = len_trim ( str ), 1 , - 1 ! scanning from end find a non-zero character select case ( str ( i : i )) case ( '0' ) ! found a trailing zero so keep trimming cycle case ( '.' ) ! found a decimal character at end of remaining string if ( i . le . 1 ) then str = '0' else str = str ( 1 : i - 1 ) endif exit case default str = str ( 1 : i ) ! found a non-zero character so trim string and exit exit end select end do if ( ipos > 0 ) then ! if originally had an exponent place it back on string = trim ( str ) // trim ( exp ) else string = str endif end subroutine trimzeros !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric value from string !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine string_to_value(chars,valu,ierr) !! !!     character(len=*),intent(in)              :: chars   ! input string !!     integer|real|doubleprecision,intent(out) :: valu !!     integer,intent(out)                      :: ierr !!##DESCRIPTION !!   returns a numeric value from a numeric character string. !! !!   works with any g-format input, including integer, real, and !!   exponential. If the input string begins with \"B\", \"Z\", or \"O\" !!   and otherwise represents a positive whole number it is assumed to !!   be a binary, hexadecimal, or octal value. If the string contains !!   commas they are removed. If the string is of the form NN:MMM... or !!   NN#MMM then NN is assumed to be the base of the whole number. !! !!   if an error occurs in the READ, IOSTAT is returned in IERR and !!   value is set to zero. if no error occurs, IERR=0. !!##OPTIONS !!       CHARS  input string to read numeric value from !!##RETURNS !!       VALU   numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION. !!       IERR   error flag (0 == no error) !!##EXAMPLE !! !!    Sample Program: !! !!     program demo_string_to_value !!     use M_strings, only: string_to_value !!     character(len=80) :: string !!        string=' -40.5e-2 ' !!        call string_to_value(string,value,ierr) !!        write(*,*) 'value of string ['//trim(string)//'] is ',value !!     end program demo_string_to_value !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine a2r ( chars , valu , ierr ) !> !! subroutine returns real value from string !character(len=*),parameter::ident_40=\"@(#)M_strings::a2r(3fp): subroutine returns real value from string\" character ( len =* ), intent ( in ) :: chars ! input string real , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( ierr . eq . 0 ) then if ( valu8 . le . huge ( valu )) then valu = real ( valu8 ) else !x!call stderr('*a2r* - value too large',valu8,'>',huge(valu)) call stderr ( '*a2r* - value too large' ) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2r !---------------------------------------------------------------------------------------------------------------------------------- subroutine a2i ( chars , valu , ierr ) !> !! subroutine returns integer value from string !character(len=*),parameter::ident_41=\"@(#)M_strings::a2i(3fp): subroutine returns integer value from string\" character ( len =* ), intent ( in ) :: chars ! input string integer , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( valu8 . le . huge ( valu )) then if ( valu8 . le . huge ( valu )) then valu = int ( valu8 ) else !x!call stderr('sc','*a2i*','- value too large',valu8,'>',huge(valu)) call stderr ( '*a2i* - value too large' ) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2i !---------------------------------------------------------------------------------------------------------------------------------- subroutine a2d ( chars , valu , ierr , onerr ) !> !! subroutine returns doubleprecision value from string !character(len=*),parameter::ident_42=\"@(#)M_strings::a2d(3fp): subroutine returns double value from string\" !     1989,2016 John S. Urban. ! !  o  works with any g-format input, including integer, real, and exponential. !  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0. !  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data. !     IERR will still be non-zero in this case. !---------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: chars ! input string character ( len = :), allocatable :: local_chars doubleprecision , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) class ( * ), optional , intent ( in ) :: onerr !---------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), parameter :: fmt = \"('(bn,g',i5,'.0)')\" ! format used to build frmt character ( len = 15 ) :: frmt ! holds format built to read input string character ( len = 256 ) :: msg ! hold message from I/O errors integer :: intg integer :: pnd integer :: basevalue , ivalu character ( len = 3 ), save :: nan_string = 'NaN' !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error flag to zero local_chars = chars msg = '' if ( len ( local_chars ). eq . 0 ) local_chars = ' ' call substitute ( local_chars , ',' , '' ) ! remove any comma characters pnd = scan ( local_chars , '#:' ) if ( pnd . ne . 0 ) then write ( frmt , fmt ) pnd - 1 ! build format of form '(BN,Gn.0)' read ( local_chars (: pnd - 1 ), fmt = frmt , iostat = ierr , iomsg = msg ) basevalue ! try to read value from string if ( decodebase ( local_chars ( pnd + 1 :), basevalue , ivalu )) then valu = real ( ivalu , kind = kind ( 0.0d0 )) else valu = 0.0d0 ierr =- 1 endif else select case ( local_chars ( 1 : 1 )) case ( 'z' , 'Z' , 'h' , 'H' ) ! assume hexadecimal frmt = '(Z' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'b' , 'B' ) ! assume binary (base 2) frmt = '(B' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'o' , 'O' ) ! assume octal frmt = '(O' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case default write ( frmt , fmt ) len ( local_chars ) ! build format of form '(BN,Gn.0)' read ( local_chars , fmt = frmt , iostat = ierr , iomsg = msg ) valu ! try to read value from string end select endif if ( ierr . ne . 0 ) then ! if an error occurred ierr will be non-zero. if ( present ( onerr )) then select type ( onerr ) type is ( integer ) valu = onerr type is ( real ) valu = onerr type is ( doubleprecision ) valu = onerr end select else ! set return value to NaN read ( nan_string , '(g3.3)' ) valu endif if ( local_chars . ne . 'eod' ) then ! print warning message except for special value \"eod\" call stderr ( '*a2d* - cannot produce number from string [' // trim ( chars ) // ']' ) if ( msg . ne . '' ) then call stderr ( '*a2d* - [' // trim ( msg ) // ']' ) endif endif endif end subroutine a2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !!   decodebase(3f) - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number !!   (LICENSE:PD) !! !!##SYNOPSIS !! !!    logical function decodebase(string,basein,out10) !! !!     character(len=*),intent(in)  :: string !!     integer,intent(in)           :: basein !!     integer,intent(out)          :: out10 !!##DESCRIPTION !! !!   Convert a numeric string representing a whole number in base BASEIN !!   to base 10. The function returns FALSE if BASEIN is not in the range !!   [2..36] or if string STRING contains invalid characters in base BASEIN !!   or if result OUT10 is too big !! !!   The letters A,B,...,Z represent 10,11,...,36 in the base > 10. !! !!##OPTIONS !!    string   input string. It represents a whole number in !!             the base specified by BASEIN unless BASEIN is set !!             to zero. When BASEIN is zero STRING is assumed to !!             be of the form BASE#VALUE where BASE represents !!             the function normally provided by BASEIN. !!    basein   base of input string; either 0 or from 2 to 36. !!    out10    output value in base 10 !! !!##EXAMPLE !! !!    Sample program: !! !!     program demo_decodebase !!     use M_strings, only : codebase, decodebase !!     implicit none !!     integer           :: ba,bd !!     character(len=40) :: x,y !!     integer           :: r !! !!     print *,' BASE CONVERSION' !!     write(*,'(\"Start   Base (2 to 36): \")',advance='no'); read *, bd !!     write(*,'(\"Arrival Base (2 to 36): \")',advance='no'); read *, ba !!     INFINITE: do !!        print *,'' !!        write(*,'(\"Enter number in start base: \")',advance='no'); read *, x !!        if(x.eq.'0') exit INFINITE !!        if(decodebase(x,bd,r)) then !!           if(codebase(r,ba,y)) then !!             write(*,'(\"In base \",I2,\": \",A20)')  ba, y !!           else !!             print *,'Error in coding number.' !!           endif !!        else !!           print *,'Error in decoding number.' !!        endif !!     enddo INFINITE !! !!     end program demo_decodebase !! !!##AUTHOR !!    John S. Urban !! !!       Ref.: \"Math matiques en Turbo-Pascal by !!              M. Ducamp and A. Reverchon (2), !!              Eyrolles, Paris, 1988\". !! !!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr) !! !!##LICENSE !!    Public Domain !=================================================================================================================================== logical function decodebase ( string , basein , out_baseten ) implicit none !character(len=*),parameter::ident_72=\"@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number\" character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: basein integer , intent ( out ) :: out_baseten character ( len = len ( string )) :: string_local integer :: long , i , j , k real :: y real :: mult character ( len = 1 ) :: ch real , parameter :: XMAXREAL = real ( huge ( 1 )) integer :: out_sign integer :: basein_local integer :: ipound integer :: ierr string_local = upper ( trim ( adjustl ( string ))) decodebase = . false . ipound = index ( string_local , '#' ) ! determine if in form [-]base#whole if ( basein . eq . 0. and . ipound . gt . 1 ) then ! split string into two values call string_to_value ( string_local (: ipound - 1 ), basein_local , ierr ) ! get the decimal value of the base string_local = string_local ( ipound + 1 :) ! now that base is known make string just the value if ( basein_local . ge . 0 ) then ! allow for a negative sign prefix out_sign = 1 else out_sign =- 1 endif basein_local = abs ( basein_local ) else ! assume string is a simple positive value basein_local = abs ( basein ) out_sign = 1 endif out_baseten = 0 y = 0.0 ALL : if ( basein_local < 2. or . basein_local > 36 ) then print * , '(*decodebase* ERROR: Base must be between 2 and 36. base=' , basein_local else ALL out_baseten = 0 ; y = 0.0 ; mult = 1.0 long = LEN_TRIM ( string_local ) do i = 1 , long k = long + 1 - i ch = string_local ( k : k ) if ( ch . eq . '-' . and . k . eq . 1 ) then out_sign =- 1 cycle endif if ( ch < '0' . or . ch > 'Z' . or .( ch > '9' . and . ch < 'A' )) then write ( * , * ) '*decodebase* ERROR: invalid character ' , ch exit ALL endif if ( ch <= '9' ) then j = IACHAR ( ch ) - IACHAR ( '0' ) else j = IACHAR ( ch ) - IACHAR ( 'A' ) + 10 endif if ( j >= basein_local ) then exit ALL endif y = y + mult * j if ( mult > XMAXREAL / basein_local ) then exit ALL endif mult = mult * basein_local enddo decodebase = . true . out_baseten = nint ( out_sign * y ) * sign ( 1 , basein ) endif ALL end function decodebase end module M_time_duplicate","tags":"","loc":"sourcefile/m_time_duplicate.f90.html"},{"title":"sec2days.f90 – M_time","text":"Contents Programs demo_sec2days Source Code sec2days.f90 Source Code program demo_sec2days use M_kracken95 , only : kracken , lget , sget , IPvalue use M_time , only : sec2days use M_strings , only : substitute implicit none character ( len =* ), parameter :: ident = \"@(#)sec2days(1f): convert seconds to string of form dd-hh:mm:ss\" character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: radix character ( len = IPvalue ) :: line call kracken ( 'sec2days' , ' -oo -crop .F -radix . -help .F. -version .F.' ) ! parse command line call help_usage ( lget ( 'sec2days_help' )) ! display help information and stop if true call help_version ( lget ( 'sec2days_version' )) ! display version information and stop if true radix = trim ( sget ( 'sec2days_radix' )) line = sget ( 'sec2days_oo' ) if ( radix . ne . '.' ) then call substitute ( line , '.' , ' ' ) call substitute ( line , radix , '.' ) endif strlocal = sec2days ( trim ( line ), lget ( 'sec2days_crop' )) ! get command line option and convert to dd-hh:mm:ss string write ( * , '(a)' ) strlocal contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   sec2days(1f) - [TIME] Convert seconds to string of form dd-hh:mm:ss                                                          ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   sec2days nnnn[.xxx] [ -crop]| --version| --help                                                                              ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Given a numeric string representing seconds convert it to a string                                                           ' ,& '   of the form                                                                                                                  ' ,& '                                                                                                                                ' ,& '      dd-hh:mm:ss                                                                                                               ' ,& '                                                                                                                                ' ,& '   where dd is days, hh hours, mm minutes and ss seconds.                                                                       ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   nnnn[.xxx]  number of seconds to convert to string of form dd-hh:mm:ss.                                                      ' ,& '               nnnn may be interspersed with unit codes d,h,m,s. Spaces,                                                        ' ,& '               commas and case are ignored. Allowed aliases for the unit                                                        ' ,& '               codes are                                                                                                        ' ,& '                 d  days and day                                                                                                ' ,& '                 h  hours,hour,hrs, and hr                                                                                      ' ,& '                 m  minutes,minute and min                                                                                      ' ,& '                 s  seconds,second and sec                                                                                      ' ,& '                                                                                                                                ' ,& '   -crop       trim leading zero values from output                                                                             ' ,& '   -radix      character used as decimal separator                                                                              ' ,& '   --help      display this help and exit                                                                                       ' ,& '   --version   output version information and exit                                                                              ' ,& '                                                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& ' usage                                                                                                                          ' ,& '                                                                                                                                ' ,& '   sec2days 129860                                                                                                              ' ,& '   1-12:04:20                                                                                                                   ' ,& '   sec2days 1d2h3m4s                                                                                                            ' ,& '   1-02:03:04                                                                                                                   ' ,& '   sec2days 1.0 days 2 hours 3 minutes 4 seconds                                                                                ' ,& '   1-02:03:04                                                                                                                   ' ,& '   sec2days 1.5d                                                                                                                ' ,& '   1-12:00:00                                                                                                                   ' ,& '                                                                                                                                ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    sec2days(1f) - [TIME] Convert seconds to string of form dd-hh:mm:ss !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    sec2days nnnn[.xxx] [ -crop]| --version| --help !! !!##DESCRIPTION !!    Given a numeric string representing seconds convert it to a string !!    of the form !! !!       dd-hh:mm:ss !! !!    where dd is days, hh hours, mm minutes and ss seconds. !! !!##OPTIONS !!    nnnn[.xxx]  number of seconds to convert to string of form dd-hh:mm:ss. !!                nnnn may be interspersed with unit codes d,h,m,s. Spaces, !!                commas and case are ignored. Allowed aliases for the unit !!                codes are !!                  d  days and day !!                  h  hours,hour,hrs, and hr !!                  m  minutes,minute and min !!                  s  seconds,second and sec !! !!    -crop       trim leading zero values from output !!    -radix      character used as decimal separator !!    --help      display this help and exit !!    --version   output version information and exit !! !!##EXAMPLE !! !!  usage !! !!    sec2days 129860 !!    1-12:04:20 !!    sec2days 1d2h3m4s !!    1-02:03:04 !!    sec2days 1.0 days 2 hours 3 minutes 4 seconds !!    1-02:03:04 !!    sec2days 1.5d !!    1-12:00:00 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        sec2days(1f)>' ,& '@(#)DESCRIPTION:    convert seconds to string of form dd-hh:mm:ss>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_sec2days","tags":"","loc":"sourcefile/sec2days.f90.html"},{"title":"now.f90 – M_time","text":"Contents Programs display_date Source Code now.f90 Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !----------------------------------------------------------------------------------------------------------------------------------- program display_date use M_kracken95 , only : kracken , lget , retrev , sget , dget ! command line parameter cracking module use M_time , only : now , fmtdate_usage , fmtdate , days2sec , d2u , u2d , realtime , guessdate , j2d use m_strings , only : string_to_values , isdigit , isspace , switch implicit none character ( len =* ), parameter :: ident = \"@(#)now(1f): writes timestamp using specified syntax\" integer :: dat ( 8 ) = 0 real :: rdat ( 8 ) = 0 real ( kind = realtime ) :: duration = 0 character ( len = :), allocatable :: output !character(len=1),allocatable   :: chars(:) integer :: ierr , inums !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - call kracken ( 'now' , ' -help .F. -version .F. -dat -date -jed -uet -test .false. -delta' ) ! crack command line call help_version ( lget ( 'now_version' )) ! display version number if --version is present !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_help' )) then ! display help text and exit if --help is present call usage () stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_test' )) then ! try each format type call fmtdate_usage ( 3 ) stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( sget ( 'now_uet' ). ne . ' ' ) then dat = u2d ( dget ( 'now_uet' )) ! convert command option to UET number, convert to dat elseif ( sget ( 'now_jed' ). ne . ' ' ) then dat = j2d ( dget ( 'now_jed' )) ! convert command option to JED number, convert to dat elseif ( sget ( 'now_dat' ). ne . ' ' ) then dat = u2d () ! initialize DAT with current date and time to get time zone dat = [ dat ( 1 ), 1 , 1 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! default is Jan 1st in current year and timezone 00:00:00 call string_to_values ( sget ( 'now_dat' ), size ( dat ), rdat , inums , ' ,:/' , ierr ) ! convert string to array and overlay default values dat ( 1 : inums ) = nint ( rdat ( 1 : inums )) ! if -date is all integer digits and whitespace and +- and only one - (for UTC value) then use it directly to load a DAT !chars=switch(trim(sget('now_dat'))) !if( all(isdigit(chars).or.isspace(chars).or.chars.eq.'-'.or.chars.eq.'+' ) .and. count(chars.eq.'-').le.1 )then !else !   write(*,*)'*now* error: invalid characters in -dat input '//trim(sget('now_dat')) !endif elseif ( sget ( 'now_date' ). ne . ' ' ) then ! convert command option to date string and try to guess date call guessdate ( sget ( 'now_date' ), dat ) else ! create DAT for current time dat = u2d () ! current time endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - duration = days2sec ( sget ( 'now_delta' )) ! convert string to duration in seconds dat = u2d ( d2u ( dat ) + duration ) ! convert DAT to UET, add duration, place back in DAT !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - output = fmtdate ( dat , sget ( 'now_oo' )) ! create output string by applying format !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - write ( * , '(a)' ) trim ( output ) ! write output !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - contains !----------------------------------------------------------------------------------------------------------------------------------- subroutine usage () ! character ( len =* ), parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character ( len = 80 ), allocatable :: text (:) integer :: i ! NOTE: Without the type specification this constructor would have to specify all of the constants with the same character length. text = [ character ( len = len ( text ( 1 ))) :: & & 'NAME                                                                            ' ,& & '   now(1f)  - [TIME] print the date and time                                    ' ,& & '   (LICENSE:PD)                                                                 ' ,& & '                                                                                ' ,& & 'SYNOPSIS                                                                        ' ,& & '  now [Format [ -date date_str|-ued Unix_time|-jed Julian_Date|-dat date_vector]' ,& & '      [ -delta dd-hh:mm:ss]]|--help |--version|-test]                           ' ,& & '                                                                                ' ,& & 'DESCRIPTION                                                                     ' ,& & '   Report the current time or a Fortran date vector in a variety of formats.    ' ,& & '   Julian dates, Unix Epoch time, weekdays, monthnames, ordinal days,           ' ,& & '   AM/PM and iso-8601 week-numbering are supported by building a format         ' ,& & '   string containing the desired macros.                                        ' ,& & 'OPTIONS                                                                         ' ,& & '   Format  :                                                                    ' ,& & '     This string, containing macro names or keywords, creates the format used   ' ,& & '     to print the specified date.                                               ' ,& & '                                                                                ' ,& & '     The FORMAT string is expanded using the following macros:                  ' ,& & '                                                                                ' ,& & 'CALL FMTDATE_USAGE                                                              ' ,& & '                                                                                ' ,& & '   -dat date_vector  :                                                          ' ,& & '      A date vector is eight integers representing a date in the same manner as ' ,& & '      the Fortran DATE_AND_TIME(3f) function:                                   ' ,& & '          yyyy mm dd zone hh mm ss mss                                          ' ,& & '      only numeric time zones are supported.                                    ' ,& & '                                                                                ' ,& & '      When present, the specified date is used instead of the current time.     ' ,& & '                                                                                ' ,& & '   -uet Unix_Epoch_Time  :                                                      ' ,& & '      When present a value is used as the Unix Epoch Time. This date is         ' ,& & '      is then adjusted using any -delta value and then printed using            ' ,& & '      the specified format.                                                     ' ,& & '                                                                                ' ,& & '   -jed Julian_Date  :                                                          ' ,& & '      When present a value is used as the Julian Ephemeris Date.                ' ,& & '                                                                                ' ,& & '   -delta dd-hh:mm:ss  :                                                        ' ,& & '      Add the specified duration to the date.                                   ' ,& & '                                                                                ' ,& & '   -date date_str  :                                                            ' ,& & '      The guessdate(3f) routine is used to try to convert a date description    ' ,& & '      to a date vector. For the guess to work, dates must either be in the      ' ,& & '      form YYYY-MM-DD or the order of numeric values must be \"\"dd yy yyy\".      ' ,& & '      Only four-digit years are supported. Month names are preferred over       ' ,& & '      numeric values. See the guessdate(3f) documentation for further details.  ' ,& & '                                                                                ' ,& & '   -test :                                                                      ' ,& & '      To list allowed macros use the -test switch.                              ' ,& & '                                                                                ' ,& & '   When present, the specified date is used instead of the current time.        ' ,& & 'EXAMPLES                                                                        ' ,& & ' Sample commands:                                                               ' ,& & '                                                                                ' ,& & '  now                                                                           ' ,& & '    Friday, June 17th, 2016 03:22:53 PM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta  1-0:0:0  # Tomorrow                                               ' ,& & '    Sunday, June 19th, 2016 11:32:26 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta -1-0:0:0  # Yesterday                                              ' ,& & '    Friday, June 17th, 2016 11:32:43 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now long -delta  7-0:0:0  # Next week                                         ' ,& & '    Saturday, June 25th, 2016 11:32:57 AM UTC-04:00                             ' ,& & '                                                                                ' ,& & '  now The date is %Y/%M/%D %h:%m:%s  # user-specified formats using macros      ' ,& & '    The date is 2009/08/10 00:33:48                                             ' ,& & '                                                                                ' ,& & '  now Y/M/D h:m:s # user-specified format with no % character                   ' ,& & '    2009/08/10 00:33:48                                                         ' ,& & '                                                                                ' ,& & '  now year-month-day # user-specified format with no % with long keywords       ' ,& & '  2016-07-29                                                                    ' ,& & '                                                                                ' ,& & '  now -dat 2016 07 23 -240 1 01 00 00  # alternate date                         ' ,& & '  Saturday, July 23rd, 2016 1:01:00 AM UTC-4:00                                 ' ,& & '                                                                                ' ,& & '  now -uet  1469250060                 # alternate Unix Epoch date              ' ,& & '  now -date January 4th, 1999 10:20:30 # try to determine date from description.' ,& & '                                                                                ' ,& & '  now YEAR=%Y MONTH=%M DAY=%D          # YEAR=2009 MONTH=08 DAY=10              ' ,& & '                                                                                ' ,& & '  now HOUR=%h MINUTES=%m SECONDS=%s MILLISECONDS=%x                             ' ,& & '      HOUR=01 MINUTES=18 SECONDS=44 MILLISECONDS=946                            ' ,& & '                                                                                ' ,& & '  # double-quotes are tricky (double them) to put in literally in this program: ' ,& & '  now ''\"\"year-month-day\"\",\"\"hour-minute-second\"\"'' #  \"2017-04-23\",\"14-41-09\"  ' ,& & '                                                                                ' ,& & '  # quotes are easier to control using the single-letter macros(use %q and %Q): ' ,& & '  now QY-M-DQ,Qh:m:sQ                                                           ' ,& & '     \"2017-04-23\",\"14-41-09\"                                                    ' ,& & '                                                                                ' ,& & '  now -test       # Show formatting options, handy way to look up macro names   ' ,& & '                                                                                ' ,& & 'LIMITS                                                                          ' ,& & '  See the M_time module description. Basically, A Gregorian Calendar is         ' ,& & '  assumed, and Leap Seconds are not specifically accounted for.                 ' ,& & 'SEE ALSO                                                                        ' ,& & '   month(1), sec2days(1), days2sec(1), easter(1), paws(1), today(1), ttee(1)    ' ,& & 'AUTHOR                                                                          ' ,& & '   John S. Urban                                                                ' ,& & 'LICENSE                                                                         ' ,& & '   Public Domain                                                                ' ,& & '                                                                                ' ] do i = 1 , size ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 6 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo stop end subroutine usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        now(1f)>' ,& '@(#)DESCRIPTION:    Report a date in a variety of formats>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program display_date !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/now.f90.html"},{"title":"days2sec.f90 – M_time","text":"Contents Programs demo_days2sec Source Code days2sec.f90 Source Code program demo_days2sec use M_kracken95 , only : kracken , sget , lget , rget use M_time , only : days2sec use M_strings , only : v2s implicit none character ( len =* ), parameter :: ident = \"@(#)days2sec(1): given string of form dd-hh:mm:ss convert to seconds\" character ( len = :), allocatable :: printline call kracken ( 'days2sec' , ' -oo -help .F. -version .F. -denominator 1' ) ! parse command line call help_usage ( lget ( 'days2sec_help' )) ! display help information and stop if true call help_version ( lget ( 'days2sec_version' )) ! display version information and stop if true ! get value from command line with SGET, convert to seconds with DAYS2SEC, and make into a nicer value string with V2S printline = v2s ( days2sec ( sget ( 'days2sec_oo' )) / rget ( 'days2sec_denominator' )) ! not in write statement so error message will print write ( * , '(a)' ) printline contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds                                                                ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   days2sec dd-hh:mm:ss | --version| --help                                                                                     ' ,& '   days2sec NNdNNhNNmNNs                                                                                                        ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss where dd is days, hh hours,                                                         ' ,& '   mm minutes and ss seconds convert it to seconds. Many utilities (ps(1),                                                      ' ,& '   for example) show times in this format to make it more intelligible;                                                         ' ,& '   but it generally easier to perform math on values represented in                                                             ' ,& '   seconds.                                                                                                                     ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   dd-hh:mm:ss  Given a string representing a duration of time in the                                                           ' ,& '                following forms:                                                                                                ' ,& '                                                                                                                                ' ,& '                  dd-hh:mm:ss                                                                                                   ' ,& '                     hh:mm:ss                                                                                                   ' ,& '                        mm:ss                                                                                                   ' ,& '                           ss                                                                                                   ' ,& '                                                                                                                                ' ,& '                convert it to seconds.                                                                                          ' ,& '                                                                                                                                ' ,& '                The numeric values may represent floating point numbers.                                                        ' ,& '                                                                                                                                ' ,& '                Spaces are ignored.                                                                                             ' ,& '                                                                                                                                ' ,& '    NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes;                                                    ' ,& '                  where s,m,h, or d represents seconds, minutes, hours                                                          ' ,& '                  or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are                                  ' ,& '                                                                                                                                ' ,& '                   w -  weeks,week,wk,wks                                                                                       ' ,& '                   d -  days,day                                                                                                ' ,& '                   m -  minutes,minute,min                                                                                      ' ,& '                   h -  hours,hour,hrs,hr                                                                                       ' ,& '                   s -  seconds,second,sec,secs                                                                                 ' ,& '                                                                                                                                ' ,& '                  The numeric values may represent floating point numbers.                                                      ' ,& '                                                                                                                                ' ,& '                  Spaces, commas  and case are ignored.                                                                         ' ,& '                                                                                                                                ' ,& '   --denominator  divide the result by this value. Default is one(1).                                                           ' ,& '   --help         display this help and exit                                                                                    ' ,& '   --version      output version information and exit                                                                           ' ,& '                                                                                                                                ' ,& 'EXAMPLE                                                                                                                         ' ,& '  Usage                                                                                                                         ' ,& '                                                                                                                                ' ,& '    days2sec 1-12:04:20                                                                                                         ' ,& '    129860                                                                                                                      ' ,& '    days2sec 1.5 days                                                                                                           ' ,& '    129600                                                                                                                      ' ,& '    days2sec 1.5 days 4hrs 30minutes                                                                                            ' ,& '    145800                                                                                                                      ' ,& '    days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED                                                                    ' ,& '    30                                                                                                                          ' ,& '    days2sec 1 1 1  # SPACES ARE IGNORED                                                                                        ' ,& '    111                                                                                                                         ' ,& 'SEE ALSO                                                                                                                        ' ,& '    sec2days(1)                                                                                                                 ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    days2sec dd-hh:mm:ss | --version| --help !!    days2sec NNdNNhNNmNNs !! !!##DESCRIPTION !!    Given a duration in the form dd-hh:mm:ss where dd is days, hh hours, !!    mm minutes and ss seconds convert it to seconds. Many utilities (ps(1), !!    for example) show times in this format to make it more intelligible; !!    but it generally easier to perform math on values represented in !!    seconds. !! !!##OPTIONS !!    dd-hh:mm:ss  Given a string representing a duration of time in the !!                 following forms: !! !!                   dd-hh:mm:ss !!                      hh:mm:ss !!                         mm:ss !!                            ss !! !!                 convert it to seconds. !! !!                 The numeric values may represent floating point numbers. !! !!                 Spaces are ignored. !! !!     NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes; !!                   where s,m,h, or d represents seconds, minutes, hours !!                   or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are !! !!                    w -  weeks,week,wk,wks !!                    d -  days,day !!                    m -  minutes,minute,min !!                    h -  hours,hour,hrs,hr !!                    s -  seconds,second,sec,secs !! !!                   The numeric values may represent floating point numbers. !! !!                   Spaces, commas  and case are ignored. !! !!    --denominator  divide the result by this value. Default is one(1). !!    --help         display this help and exit !!    --version      output version information and exit !! !!##EXAMPLE !! !!   Usage !! !!     days2sec 1-12:04:20 !!     129860 !!     days2sec 1.5 days !!     129600 !!     days2sec 1.5 days 4hrs 30minutes !!     145800 !!     days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED !!     30 !!     days2sec 1 1 1  # SPACES ARE IGNORED !!     111 !!##SEE ALSO !!     sec2days(1) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        days2sec(1f)>' ,& '@(#)DESCRIPTION:    convert dd-hh:mm:ss string to seconds>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_days2sec","tags":"","loc":"sourcefile/days2sec.f90.html"},{"title":"today.f90 – M_time","text":"Contents Programs today Source Code today.f90 Source Code program today implicit none call main () contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '       today(1f) - [TIME] output current time for uses such as file suffixes.                                                   ' ,& '       (LICENSE:PD)                                                                                                             ' ,& 'SYNOPSIS                                                                                                                        ' ,& '       today format|--help|--version|--options                                                                                  ' ,& 'DESCRIPTION                                                                                                                     ' ,& '       Outputs the current date using the specified format. Typically used                                                      ' ,& '       to generate a string to be used in building filenames containing                                                         ' ,& '       date information.                                                                                                        ' ,& 'OPTIONS                                                                                                                         ' ,& '       format     any allowable format for the fmtdate(3) routine. Enter                                                        ' ,& '                  \"-\" to get a list on stdout. defaults to \"YMD\".                                                               ' ,& '       --help     display this help and exit                                                                                    ' ,& '       --version  output version information and exit                                                                           ' ,& '       --options  display allowed options for building a format                                                                 ' ,& 'EXAMPLE                                                                                                                         ' ,& '       Sample commands:                                                                                                         ' ,& '                                                                                                                                ' ,& '        cp myfile myfile.`today`                                                                                                ' ,& '        find . -ls > MANIFEST.`today epoch`                                                                                     ' ,& '        mkdir `today YMDhms`                                                                                                    ' ,& '        today yearmonthdayhourminutesecond                                                                                      ' ,& '        today --options                       # show formatting options                                                         ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        today(1f) - [TIME] output current time for uses such as file suffixes. !!        (LICENSE:PD) !!##SYNOPSIS !! !!        today format|--help|--version|--options !!##DESCRIPTION !!        Outputs the current date using the specified format. Typically used !!        to generate a string to be used in building filenames containing !!        date information. !!##OPTIONS !!        format     any allowable format for the fmtdate(3) routine. Enter !!                   \"-\" to get a list on stdout. defaults to \"YMD\". !!        --help     display this help and exit !!        --version  output version information and exit !!        --options  display allowed options for building a format !!##EXAMPLE !! !!        Sample commands: !! !!         cp myfile myfile.`today` !!         find . -ls > MANIFEST.`today epoch` !!         mkdir `today YMDhms` !!         today yearmonthdayhourminutesecond !!         today --options                       # show formatting options !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        today(1f)>' ,& '@(#)DESCRIPTION:    output current time for uses such as file suffixes.>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version subroutine main () use M_time , only : now , fmtdate_usage use M_kracken95 , only : kracken , lget , sget ! add command-line parser module ! ident_1=\"@(#)today(1f): output current time for uses such as file suffixes.\" character ( len = :), allocatable :: options call kracken ( 'today' , '-help .F. -version .F. -options .F.' ) ! define command arguments,default values and crack command line call help_usage ( lget ( 'today_help' )) ! if -help option is present, display help text and exit call help_version ( lget ( 'today_version' )) ! if -version option is present, display version text and exit if ( lget ( 'today_options' )) then ! special option to list date format documentation call fmtdate_usage () ! see all formatting options else options = sget ( 'today_oo' ) ! get -oo STRING if ( options . eq . '' ) then ! if options are blank set a default write ( * , '(a)' ) now ( 'YMD' ) ! display current date using format from command line else write ( * , '(a)' ) now ( options ) ! display current date using format from command line endif endif end subroutine main end program today","tags":"","loc":"sourcefile/today.f90.html"},{"title":"month.f90 – M_time","text":"Contents Programs month_exe Source Code month.f90 Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== program month_exe use M_kracken95 , only : kracken , iget , lget , sget ! command line parsing use M_time , only : box_month , mo2v ! date and time implicit none character ( len =* ), parameter :: ident = \"@(#)month(1f):print calendar\" character ( len = 21 ) :: calen ( 8 ) = '                    ' ! character array to hold month character ( len = ( 21 + 2 ) * 3 ) :: calenyear ( 8 * 4 ) = '                      ' ! character array to hold year integer :: month ! values of command line options integer :: dat_values ( 8 ) ! date array integer :: r , c ! row and column for month in one-year calendar character ( len = 21 ) :: cscr call date_and_time ( values = dat_values ) ! get current time and date call kracken ( 'month' , ' -year -month 0 -help .f. -version .f.' ) ! crack command line arguments call help_usage ( lget ( 'month_help' )) ! print help information and stop if requested call help_version ( lget ( 'month_version' )) ! print version information and stop if requested !----------------------------------------------------------------------------------------------------------------------------------- ! use user-specified year date instead of current year. Try reading year from two places (-oo and -year) on command line if ( sget ( 'month_year' ). ne . ' ' ) then ! check -year option for a year value dat_values ( 1 ) = iget ( 'month_year' ) ! if value was specified use it elseif ( sget ( 'month_oo' ). ne . ' ' ) then dat_values ( 1 ) = iget ( 'month_oo' ) ! check -oo option for a year value if did not find -year VALUE endif !write(*,*)'YEAR=',dat_values(1) !----------------------------------------------------------------------------------------------------------------------------------- cscr = sget ( 'month_month' ) ! get month as string so can see if name or number or blank if ( cscr . ne . '' ) then select case ( cscr ( 1 : 1 )) case ( 'A' : 'Z' , 'a' : 'z' ) ! assume month name instead of month number month = mo2v ( trim ( cscr )) case default ! month is number month = iget ( 'month_month' ) end select else ! keyword given but no value, default to current month month = dat_values ( 2 ) endif !----------------------------------------------------------------------------------------------------------------------------------- if ( month . eq . 0 ) then ! no month specified, display an entire year do r = 1 , 4 ! display year in four rows do c = 1 , 3 ! three months per row dat_values ( 2 ) = c + ( r - 1 ) * 3 call box_month ( dat_values , calen ) calenyear ( 8 * r - 7 : 8 * r )( 23 * c - 22 : 23 * c ) = calen ! copy month into large year array enddo enddo write ( * , '(a)' ) calenyear else ! do a month dat_values ( 2 ) = month call box_month ( dat_values , calen ) write ( * , '(a)' ) calen endif !----------------------------------------------------------------------------------------------------------------------------------- contains !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                                                                            ' ,& '   month(1f) - [TIME] display a calendar                                                                                        ' ,& '   (LICENSE:PD)                                                                                                                 ' ,& '                                                                                                                                ' ,& 'SYNOPSIS                                                                                                                        ' ,& '   month [[ -year] NNNN] [ -month NN|month_name]                                                                                ' ,& '                                                                                                                                ' ,& 'DESCRIPTION                                                                                                                     ' ,& '   month(1) displays a simple calendar. If no arguments are specified,                                                          ' ,& '   the current year is displayed.                                                                                               ' ,& '                                                                                                                                ' ,& 'OPTIONS                                                                                                                         ' ,& '   -month      Display single month output. The month is numeric (1-12)                                                         ' ,& '               or a month name or blank. If blank the current month is assumed.                                                 ' ,& '                                                                                                                                ' ,& '   -year NNNN  Select the year to display. A year starts on Jan 1st.                                                            ' ,& '                                                                                                                                ' ,& '   -help       Display help text and exit.                                                                                      ' ,& '   -version    Display version information and exit.                                                                            ' ,& '                                                                                                                                ' ,& 'EXAMPLES                                                                                                                        ' ,& '      month -month 12                                                                                                           ' ,& '                                                                                                                                ' ,& '       >    December 2015                                                                                                       ' ,& '       >Mo Tu We Th Fr Sa Su                                                                                                    ' ,& '       >    1  2  3  4  5  6                                                                                                    ' ,& '       > 7  8  9 10 11 12 13                                                                                                    ' ,& '       >14 15 16 17 18 19 20                                                                                                    ' ,& '       >21 22 23 24 25 26 27                                                                                                    ' ,& '       >28 29 30 31                                                                                                             ' ,& '                                                                                                                                ' ,& '      month -month April # month names may be given instead of numbers                                                          ' ,& 'AUTHOR                                                                                                                          ' ,& '   John S. Urban                                                                                                                ' ,& 'LICENSE                                                                                                                         ' ,& '   Public Domain                                                                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    month(1f) - [TIME] display a calendar !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    month [[ -year] NNNN] [ -month NN|month_name] !! !!##DESCRIPTION !!    month(1) displays a simple calendar. If no arguments are specified, !!    the current year is displayed. !! !!##OPTIONS !!    -month      Display single month output. The month is numeric (1-12) !!                or a month name or blank. If blank the current month is assumed. !! !!    -year NNNN  Select the year to display. A year starts on Jan 1st. !! !!    -help       Display help text and exit. !!    -version    Display version information and exit. !! !!##EXAMPLES !! !!       month -month 12 !! !!        >    December 2015 !!        >Mo Tu We Th Fr Sa Su !!        >    1  2  3  4  5  6 !!        > 7  8  9 10 11 12 13 !!        >14 15 16 17 18 19 20 !!        >21 22 23 24 25 26 27 !!        >28 29 30 31 !! !!       month -month April # month names may be given instead of numbers !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        month(1f)>' ,& '@(#)DESCRIPTION:    displays simple calendar>' ,& '@(#)VERSION:        1.0, 2015-12-20>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2022-08-03 17:17:31 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- end program month_exe","tags":"","loc":"sourcefile/month.f90.html"},{"title":"demo_moon_fullness.f90 – M_time","text":"Contents Programs demo_moon_fullness Source Code demo_moon_fullness.f90 Source Code program demo_moon_fullness use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' )& & 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_moon_fullness","tags":"","loc":"sourcefile/demo_moon_fullness.f90.html"},{"title":"demo_mo2v.f90 – M_time","text":"Contents Programs demo_mo2v Source Code demo_mo2v.f90 Source Code program demo_mo2v use M_time , only : mo2v implicit none write ( * , * ) mo2v ( \"April\" ) write ( * , * ) mo2v ( 'Apr' ) ! NOTE: still matches September, as \"SE\" was enough write ( * , * ) mo2v ( 'sexember' ) write ( * , * ) mo2v ( 'unknown' ) ! returns -1 end program demo_mo2v","tags":"","loc":"sourcefile/demo_mo2v.f90.html"},{"title":"demo_ordinal_to_date.f90 – M_time","text":"Contents Programs demo_ordinal_to_date Source Code demo_ordinal_to_date.f90 Source Code program demo_ordinal_to_date use M_time , only : ordinal_to_date implicit none INTEGER :: yyyy , ddd , mm , dd , yy integer :: dat ( 8 ) integer :: ios INFINITE : do write ( * , '(a)' , advance = 'no' )& & 'Enter year YYYY and ordinal day of year DD ' read ( * , * , iostat = ios ) yyyy , ddd if ( ios . ne . 0 ) exit INFINITE ! recover month and day from year and day number. call ordinal_to_date ( yyyy , ddd , dat ) yy = dat ( 1 ) mm = dat ( 2 ) dd = dat ( 3 ) write ( * , '(*(g0))' ) 'For Year ' , yyyy , ' and Ordinal day ' , ddd , & & ' Month is ' , mm , ' and Day of Month is ' , dd , & & ' and Year is ' , yy enddo INFINITE end program demo_ordinal_to_date","tags":"","loc":"sourcefile/demo_ordinal_to_date.f90.html"},{"title":"demo_d2w.f90 – M_time","text":"Contents Programs demo_d2w Source Code demo_d2w.f90 Source Code program demo_d2w use M_time , only : d2w implicit none integer :: dat ( 8 ) ! input date array integer :: iso_year , iso_week , iso_weekday character ( len = 10 ) :: iso_name call date_and_time ( values = dat ) call d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) write ( * , '(\"ISO-8601 Week:   \",a)' ) iso_name write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday end program demo_d2w","tags":"","loc":"sourcefile/demo_d2w.f90.html"},{"title":"demo_phase_of_moon.f90 – M_time","text":"Contents Programs demo_phase_of_moon Source Code demo_phase_of_moon.f90 Source Code program demo_phase_of_moon use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' ) 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_phase_of_moon","tags":"","loc":"sourcefile/demo_phase_of_moon.f90.html"},{"title":"demo_o2d.f90 – M_time","text":"Contents Programs demo_o2d Source Code demo_o2d.f90 Source Code program demo_o2d use M_time , only : o2d , fmtdate implicit none integer :: year do year = 2004 , 2008 write ( * , * )& & '100th day of ' , year , ' is ' , fmtdate ( o2d ( 100 , year )) enddo write ( * , * ) '100th day of this year is ' , fmtdate ( o2d ( 100 )) end program demo_o2d","tags":"","loc":"sourcefile/demo_o2d.f90.html"},{"title":"demo_sec2days.f90 – M_time","text":"Contents Programs demo_sec2days Source Code demo_sec2days.f90 Source Code program demo_sec2days use M_time , only : sec2days implicit none integer , parameter :: dp = kind ( 0.0d0 ) write ( * , * ) sec2days ( 129860 ) write ( * , * ) sec2days ( 8000 0.0_dp ) write ( * , * ) sec2days ( 8000 0.0 , crop = . true .) write ( * , * ) sec2days ( '1 day 2.0hr 100 min 300.0seconds' ) end program demo_sec2days","tags":"","loc":"sourcefile/demo_sec2days.f90.html"},{"title":"demo_fmtdate_usage.f90 – M_time","text":"Contents Programs demo_fmtdate_usage Source Code demo_fmtdate_usage.f90 Source Code program demo_fmtdate_usage use M_time , only : fmtdate_usage implicit none call fmtdate_usage () ! see all formatting options end program demo_fmtdate_usage","tags":"","loc":"sourcefile/demo_fmtdate_usage.f90.html"},{"title":"demo_ordinal_seconds.f90 – M_time","text":"Contents Programs demo_ordinal_seconds Source Code demo_ordinal_seconds.f90 Source Code program demo_ordinal_seconds use M_time , only : ordinal_seconds implicit none character ( len = 1 ) :: paws integer :: ios integer :: istart , iend istart = ordinal_seconds () write ( * , '(a)' , advance = 'no' ) 'now pause. Enter return to continue ...' read ( * , '(a)' , iostat = ios ) paws iend = ordinal_seconds () write ( * , * ) 'that took ' , iend - istart , 'seconds' write ( * , * ) istart , iend end program demo_ordinal_seconds","tags":"","loc":"sourcefile/demo_ordinal_seconds.f90.html"},{"title":"demo_d2u.f90 – M_time","text":"Contents Programs demo_d2u Source Code demo_d2u.f90 Source Code program demo_d2u use M_time , only : d2u implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Unix Epoch time is ' , d2u ( dat ) end program demo_d2u","tags":"","loc":"sourcefile/demo_d2u.f90.html"},{"title":"demo_julian_to_date.f90 – M_time","text":"Contents Programs demo_julian_to_date Source Code demo_julian_to_date.f90 Source Code program demo_julian_to_date use M_time , only : julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr ! set sample Julian Date juliandate = 245758 9.129_dp ! create DAT array for this date call julian_to_date ( juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call julian_to_date ( juliandate - 1.0_dp , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call julian_to_date ( juliandate + 1.0_dp , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_julian_to_date","tags":"","loc":"sourcefile/demo_julian_to_date.f90.html"},{"title":"demo_system_sleep.f90 – M_time","text":"Contents Programs demo_system_sleep Source Code demo_system_sleep.f90 Source Code program demo_system_sleep use M_time , only : system_sleep , now implicit none integer :: i ! write ( * , '(a)' ) \"Time before integer call is: \" , now () call system_sleep ( 4 ) write ( * , '(a)' ) \"Time after  integer call is: \" , now () ! write ( * , '(a)' ) \"Time before real call is: \" , now () call system_sleep ( 4.0 ) write ( * , '(a)' ) \"Time after  real call is: \" , now () ! write ( * , '(a)' ) \"Time before loop is: \" , now () do i = 1 , 1000 call system_sleep ( 4.0 / 100 0.0 ) enddo write ( * , '(a)' ) \"Time after loop  is: \" , now () ! end program demo_system_sleep","tags":"","loc":"sourcefile/demo_system_sleep.f90.html"},{"title":"demo_fmtdate.f90 – M_time","text":"Contents Programs demo_fmtdate Source Code demo_fmtdate.f90 Source Code program demo_fmtdate use M_time , only : fmtdate implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , * ) fmtdate ( dat , \"current date: %w, %l %d, %Y %H:%m:%s %N\" ) call showme () contains subroutine showme () use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine showme end program demo_fmtdate","tags":"","loc":"sourcefile/demo_fmtdate.f90.html"},{"title":"demo_dow.f90 – M_time","text":"Contents Programs demo_dow Source Code demo_dow.f90 Source Code program demo_dow use M_time , only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) call dow ( dat , weekday , day , ierr ) write ( * , '(a,i0)' ) 'weekday=' , weekday write ( * , '(a,a)' ) 'day=' , trim ( day ) write ( * , '(a,i0)' ) 'ierr=' , ierr end program demo_dow","tags":"","loc":"sourcefile/demo_dow.f90.html"},{"title":"demo_v2mo.f90 – M_time","text":"Contents Programs demo_v2mo Source Code demo_v2mo.f90 Source Code program demo_v2mo use M_time , only : v2mo implicit none integer :: i write ( * , * )( v2mo ( i ), i = 1 , 13 ) end program demo_v2mo","tags":"","loc":"sourcefile/demo_v2mo.f90.html"},{"title":"demo_d2j.f90 – M_time","text":"Contents Programs demo_d2j Source Code demo_d2j.f90 Source Code program demo_d2j use M_time , only : d2j implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Julian Date is ' , d2j ( dat ) end program demo_d2j","tags":"","loc":"sourcefile/demo_d2j.f90.html"},{"title":"demo_days2sec.f90 – M_time","text":"Contents Programs demo_days2sec Source Code demo_days2sec.f90 Source Code program demo_days2sec use M_time , only : days2sec implicit none write ( * , * ) days2sec ( '1-12:04:20' ) write ( * , * ) 'one second ' , days2sec ( '1' ) write ( * , * ) 'one minute ' , days2sec ( '1:00' ) write ( * , * ) 'one hour ' , days2sec ( '1:00:00' ) write ( * , * ) 'one day ' , days2sec ( '1-00:00:00' ) write ( * , * ) nint ( days2sec ( ' 1-12:04:20              ' )) . eq . 129860 write ( * , * ) nint ( days2sec ( ' 1.5 days                ' )) . eq . 129600 write ( * , * ) nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) . eq . 145800 write ( * , * ) nint ( days2sec ( ' 1.5d                    ' )) . eq . 129600 write ( * , * ) nint ( days2sec ( ' 1d2h3m4s                ' )) . eq . 93784 ! duplicates write ( * , * ) nint ( days2sec ( ' 1d1d1d                  ' )) . eq . 259200 ! negative values write ( * , * ) nint ( days2sec ( ' 4d-12h                  ' )) . eq . 302400 end program demo_days2sec","tags":"","loc":"sourcefile/demo_days2sec.f90.html"},{"title":"demo_date_to_unix.f90 – M_time","text":"Contents Programs demo_date_to_unix Source Code demo_date_to_unix.f90 Source Code program demo_date_to_unix use M_time , only : date_to_unix , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: unixtime integer :: ierr call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat call date_to_unix ( dat , unixtime , ierr ) write ( * , * ) 'Unix Epoch time is ' , unixtime write ( * , * ) 'ierr is ' , ierr end program demo_date_to_unix","tags":"","loc":"sourcefile/demo_date_to_unix.f90.html"},{"title":"demo_M_time_oop.f90 – M_time","text":"Contents Programs demo_M_time_oop Source Code demo_M_time_oop.f90 Source Code program demo_M_time_oop ! ! This is an example using the object-oriented class/type model ! This is essentially the same functionality as the procedures ! in the procedural module M_time(3fm), but allows for Object ! Oriented syntax: ! use M_time_oop , only : date_time !!use M_time_oop,only : operator(+),operator(-),operator(>),operator(<) !!use M_time_oop,only : operator(<=),operator(>=),operator(==),operator(/=) implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer :: dat ( 8 ) TYPE ( date_time ) :: event TYPE ( date_time ) :: otherdate TYPE ( date_time ) :: answer character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' ! DIFFERENT INITIALIZATION STYLES ! (Still debating on how best to do this) write ( * , * ) write ( * , '(a)' ) 'Various initialization styles' ! DEFINE type(date_time) WITH CONSTRUCTOR otherdate = date_time () print * , 'DEFAULT CONSTRUCTOR %format()               ' ,& & otherdate % format () print * , 'DEFAULT CONSTRUCTOR %format(\"\")             ' ,& & otherdate % format ( \"\" ) print * , 'DEFAULT CONSTRUCTOR %format(user-specified) ' ,& & otherdate % format ( iso_fmt ) print * , 'DEFAULT CONSTRUCTOR %format(\"USA\")          ' ,& & otherdate % format ( \"USA\" ) otherdate = date_time ( 1492 , 10 , 12 , 0 , 0 , 0 , 0 , 0 ) print * , 'DEFAULT CONSTRUCTOR setting values          ' ,& & otherdate % format () otherdate = date_time ( 2016 , 6 , 11 ) print * , 'DEFAULT CONSTRUCTOR with partial values     ' ,& & otherdate % format () otherdate = date_time ( year = 2016 , month = 6 , day = 11 , tz =- 240 ,& & hour = 21 , minute = 09 , second = 11 , millisecond = 500 ) print * , 'DEFAULT CONSTRUCTOR with values by name     ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 , 0 , 0 , 0 , 0 , 0 ]) print * , 'CONSTRUCTOR with a dat array                ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 ]) print * , 'CONSTRUCTOR with a partial dat array        ' ,& & otherdate % format () ! the init() method supports several methods ! initialize to current time using INIT call otherdate % init () ! initialize to current time using INIT call otherdate % init ( type = \"now\" ) ! initialize to beginning of Unix Epoch Time call otherdate % init ( type = \"epoch\" ) ! Note ! currently, DATE_TIME DATE array is set to Unix Epoch ! start USING LOCAL TIMEZONE ! whereas default constructor is using default of Unix Epoch ! start using Z time (GMT or UTC time) ! initialize with a DAT array using INIT, ! compatible with DATE_AND_TIME VALUES(8) call otherdate % init ( dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) ! using INIT with ordered values call otherdate % init ( 2016 , 6 , 11 , - 300 , 23 , 1 , 0 , 0 ) ! using INIT with names call otherdate % init ( year = 2016 , month = 6 , day = 11 ,& & tz =- 300 , hour = 23 , minute = 1 , second = 0 , millisecond = 0 ) ! ! take current date and exercise the OOP interface ! initialize to current time using INIT call event % init () write ( * , * ) write ( * , * ) 'Print members of type(DATE_TIME)' ! show derived type write ( * , 404 ) 'EVENT=' , event 404 format ( 1 x , a , i0 , * ( \",\" , i0 :)) ! MEMBERS ( basic time values are all integers) ! print members of type write ( * , 101 ) '%year        Year................... ' , event % year write ( * , 101 ) '%month       Month.................. ' , event % month write ( * , 101 ) '%day         Day.................... ' , event % day write ( * , 101 ) '%tz          Timezone............... ' , event % tz write ( * , 101 ) '%hour        Hour................... ' , event % hour write ( * , 101 ) '%minute      Minute................. ' , event % minute write ( * , 101 ) '%second      Second................. ' , event % second write ( * , 101 ) '%millisecond Millisecond............ ' , event % millisecond ! PRINT METHODS OF TYPE write ( * , * ) 'Print methods of type(DATE_TIME)' write ( * , 101 ) '%ordinal     Ordinal day of year.... ' , event % ordinal () write ( * , 101 ) '%weekday     Weekday................ ' , event % weekday () 101 format ( 1 x , a , i0 ) ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY write ( * , 202 ) '%epoch      Unix epoch time........ ' , event % epoch () write ( * , 202 ) '%julian     Julian date............ ' , event % julian () 202 format ( 1 x , a , g0 ) ! FORMATTED STRINGS (many strings possible. ! Takes the same format string as fmtdate(3f)) write ( * , * ) write ( * , '(a)' ) ' Formatted Strings (%format(\"STRING\") & & -- see fmtdate(3f) for format descriptions' ! abbreviated month name             %l  Dec write ( * , 303 ) 'Short month............ ' ,& & event % format ( \"%l\" ) ! ! full month name                    %L  December write ( * , 303 ) 'Month.................. ' ,& & event % format ( \"%L\" ) ! ! first three characters of weekday  %w  Sat write ( * , 303 ) 'Short week............. ' ,& & event % format ( \"%w\" ) ! ! weekday name                       %W  Saturday write ( * , 303 ) 'Week .................. ' ,& & event % format ( \"%W\" ) ! ! with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( \"Y-M-D h:m:s.x z\" ) ! ! keywords with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( '\"year-month-day & & hour:minute:second.millisecond timezone\"' ) ! write ( * , * ) event % format ( 'Longer format.......... & &\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! a nice friendly format ! 303 format ( 1 x , a , '\"' , a , '\"' ) ! convert date_time to integer array ! (maybe to use with module M_TIME base procedures) dat = event % datout () write ( * , * ) write ( * , 404 ) 'DAT=' , dat ! OVERLOADED OPERATORS (add and subtract) ! a date_time object can have seconds added answer = event + 1 * 8640 0.0_dp ! ! a nice friendly format write ( * , * ) answer % format ( 'TOMORROW=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! a date_time object can have seconds subtracted answer = event - 1 * 8640 0.0_dp ! a nice friendly format write ( * , * ) answer % format ( 'YESTERDAY=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! if both operands are DATE_TIME objects a subtraction ! finds the time in seconds between the two dates write ( * , * ) 'DIFFERENCE (subtracting one date_time from another)=' ,& & answer - event ! OVERLOADED OPERATORS (logical comparisons) ! NOTE COMPARISONS ARE PERFORMED BY ! CONVERTING TIMES TO INTEGER SECONDS write ( * , * ) '> ' , event . eq . event , event . lt . event , event . gt . event & & , event . le . event , event . ge . event , event . ne . event ! write ( * , * ) '> ' , event . eq . answer , event . lt . answer , event . gt . answer & & , event . le . answer , event . ge . answer , event . ne . answer ! write ( * , * ) '> ' , answer . eq . event , answer . lt . event , answer . gt . event & & , answer . le . event , answer . ge . event , answer . ne . event ! %DELTA easily lets you change dates by common increments write ( * , * ) write ( * , 404 ) '%DELTA tests starting with date ' , event % delta () ! write ( * , * ) event % format ( \"                             & &%W, %L %d, %Y %H:%m:%s %N\" ) write ( * , * ) 'Remember years and months are not constant units' answer = event % delta ( year = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( month = 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( month =- 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( week = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( week =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( day = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( day =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = 4 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour =- 4 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( minute = 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( minute =- 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( second = 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( second =- 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( millisecond = 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( millisecond =- 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = 3 , month = 2 , day = 100 , hour = 200 ,& & week =- 1 , minute = 300 , second = 1000 , millisecond =- 10000 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(year=3,month=2,day=100,hour=200,& &week=-1,minute=300,second=1000,millisecond=100000)& & %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( duration = \"1-20:30:40.50\" ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DURATION='1-20:30:40.50')& & %W, %L %d, %Y %H:%m:%s %N\" ) end program demo_M_time_oop","tags":"","loc":"sourcefile/demo_m_time_oop.f90.html"},{"title":"demo_u2d.f90 – M_time","text":"Contents Programs demo_u2d Source Code demo_u2d.f90 Source Code program demo_u2d use M_time , only : u2d , d2u , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) ! get the date using intrinsic call date_and_time ( values = dat ) ! convert today to Julian Date today = d2u ( dat ) write ( * , * ) 'Today=' , fmtdate ( u2d ( today )) ! subtract day write ( * , * ) 'Yesterday=' , fmtdate ( u2d ( today - 8640 0.0_dp )) ! add day write ( * , * ) 'Tomorrow=' , fmtdate ( u2d ( today + 8640 0.0_dp )) end program demo_u2d","tags":"","loc":"sourcefile/demo_u2d.f90.html"},{"title":"demo_unix_to_date.f90 – M_time","text":"Contents Programs demo_unix_to_date Source Code demo_unix_to_date.f90 Source Code program demo_unix_to_date use M_time , only : unix_to_date , u2d , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: unixtime ! seconds in a day real ( kind = realtime ), parameter :: DAY = 8640 0.0_dp integer :: dat ( 8 ) integer :: ierr ! sample Unix Epoch time unixtime = 146893903 8.4639933_dp ! create DAT array for today call unix_to_date ( unixtime , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call unix_to_date ( unixtime - DAY , dat , ierr ) ! subtract day and print write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call unix_to_date ( unixtime + DAY , dat , ierr ) ! add day print write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_unix_to_date","tags":"","loc":"sourcefile/demo_unix_to_date.f90.html"},{"title":"demo_d2o.f90 – M_time","text":"Contents Programs demo_d2o Source Code demo_d2o.f90 Source Code program demo_d2o use M_time , only : d2o implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Day of year is:' , d2o ( dat ) ! year,month,day,timezone,hour,minute,seconds,milliseconds dat = [ 2020 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2021 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2022 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2023 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2024 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) end program demo_d2o","tags":"","loc":"sourcefile/demo_d2o.f90.html"},{"title":"demo_mo2d.f90 – M_time","text":"Contents Programs demo_mo2d Source Code demo_mo2d.f90 Source Code program demo_mo2d use M_time , only : mo2d implicit none write ( * , '(*(i0:,\":\"))' ) mo2d ( 'March' ) end program demo_mo2d","tags":"","loc":"sourcefile/demo_mo2d.f90.html"},{"title":"demo_j2d.f90 – M_time","text":"Contents Programs demo_j2d Source Code demo_j2d.f90 Source Code program demo_j2d use M_time , only : j2d , d2j , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2j ( dat ) ! convert today to Julian Date write ( * , * ) 'Today=' , fmtdate ( j2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) 'Yesterday=' , fmtdate ( j2d ( today - 1.0_dp )) write ( * , * ) 'Tomorrow=' , fmtdate ( j2d ( today + 1.0_dp )) end program demo_j2d","tags":"","loc":"sourcefile/demo_j2d.f90.html"},{"title":"demo_easter.f90 – M_time","text":"Contents Programs demo_easter Source Code demo_easter.f90 Source Code program demo_easter use M_time , only : easter , fmtdate implicit none integer :: year integer :: dat ( 8 ) ! year,month,day,tz,hour,minute,second,millisecond call date_and_time ( values = dat ) ! get current year year = dat ( 1 ) call easter ( year , dat ) write ( * , * ) fmtdate ( dat ,& \"Easter day: the %d day of %L in the year of our Lord %Y\" ) end program demo_easter","tags":"","loc":"sourcefile/demo_easter.f90.html"},{"title":"demo_now.f90 – M_time","text":"Contents Programs demo_now Source Code demo_now.f90 Source Code program demo_now use M_time , only : now implicit none write ( * , * ) now ( \"The current date is %w, %l %d, %Y %H:%m:%s %N\" ) call showme () contains subroutine showme () ! see all formatting options use M_time , only : fmtdate_usage call fmtdate_usage () ! see all formatting options end subroutine end program demo_now","tags":"","loc":"sourcefile/demo_now.f90.html"},{"title":"demo_box_month.f90 – M_time","text":"Contents Programs demo_box_month Source Code demo_box_month.f90 Source Code program demo_box_month use M_time , only : box_month implicit none integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) call date_and_time ( values = dat ) call box_month ( dat , calendar ) write ( * , '(a)' ) calendar end program demo_box_month","tags":"","loc":"sourcefile/demo_box_month.f90.html"},{"title":"demo_w2d.f90 – M_time","text":"Contents Programs demo_w2d Source Code demo_w2d.f90 Source Code program demo_w2d use M_time , only : w2d , fmtdate implicit none write ( * , '(a)' )& & 'Given Monday 29 December 2008 is written \"2009-W01-1\"' call printit ( 2009 , 1 , 1 ) write ( * , '(a)' )& & 'Given Sunday 3 January 2010 is written \"2009-W53-7\"' call printit ( 2009 , 53 , 7 ) write ( * , '(a)' )& & 'Given the Gregorian date Sun 31 December 2006 & &is written 2006-W52-7' call printit ( 2006 , 52 , 7 ) write ( * , '(a)' )& & 'Given 27 September 2008 is 2008-W39-6' call printit ( 2008 , 39 , 6 ) contains subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO-8601 Week: 2016-W29-1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * , '(a,i0)' ) 'GIVEN:           ' write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) end subroutine printit end program demo_w2d","tags":"","loc":"sourcefile/demo_w2d.f90.html"},{"title":"demo_date_to_julian.f90 – M_time","text":"Contents Programs demo_date_to_julian Source Code demo_date_to_julian.f90 Source Code program demo_date_to_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: juliandate integer :: ierr ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , * ) 'Julian Date is ' , juliandate write ( * , * ) 'ierr is ' , ierr end program demo_date_to_julian","tags":"","loc":"sourcefile/demo_date_to_julian.f90.html"},{"title":"demo_guessdate.f90 – M_time","text":"Contents Programs demo_guessdate Source Code demo_guessdate.f90 Source Code program demo_guessdate use M_time , only : guessdate , fmtdate implicit none character ( len = 20 ), allocatable :: datestrings (:) character ( len = :), allocatable :: answer integer :: dat ( 8 ) integer :: i datestrings = [ & & 'January 9th, 2001   ' ,& & ' Tue Jul 19 2016    ' ,& & ' 21/12/2016         ' ,& & ' 4th of Jul 2004    ' ] do i = 1 , size ( datestrings ) write ( * , '(a)' ) repeat ( '-' , 80 ) write ( * , * ) 'TRYING ' , datestrings ( i ) call guessdate ( datestrings ( i ), dat ) write ( * , * ) 'DAT ARRAY ' , dat answer = fmtdate ( dat ) write ( * , * ) 'FOR ' // datestrings ( i ) // ' GOT ' // trim ( answer ) enddo end program demo_guessdate","tags":"","loc":"sourcefile/demo_guessdate.f90.html"},{"title":"test_suite_M_time.F90 – M_time","text":"Contents Programs runtest Subroutines test_suite_M_time Source Code test_suite_M_time.F90 Source Code program runtest use M_msg use M_verify use M_verify , only : unit_check , unit_check_start , unit_check_good , unit_check_bad , unit_check_done use M_verify , only : unit_check_level use M_time implicit none unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_time () contains end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_suite_M_time use M_verify , only : unit_check , unit_check_good , unit_check_bad , unit_check_done , unit_check_start , unit_check_msg , unit_check_level use M_verify , only : unit_check_stop use , intrinsic :: iso_c_binding , only : c_int , c_char , c_null_char use M_time implicit none integer :: dat ( 8 ) integer :: ierr character ( len =* ), parameter :: SAME = '-library libGPF -section 3 -description' !! no not use M_system version or will create a circular dependency call put_environment_variable ( 'TZ' , 'America/New_York' , ierr ) ! some of the test values assume EST call put_environment_variable ( 'TZ' , 'UTC+04:00' , ierr ) ! some of the test values assume EST call unit_check_msg ( 'M_time' , 'This section contains unit tests for procedures in the M_time(3f) module.' ) call unit_check_start ( 'box_month      ' , SAME // ' \"print specified month into character array\" ' ) call test_box_month () call unit_check_start ( 'd2j            ' , SAME // ' \"Convert date array to Julian Date\" ' ) call test_d2j () call unit_check_start ( 'd2o            ' , SAME // ' \"Converts date-time array to Ordinal day\" ' ) call test_d2o () call unit_check_start ( 'd2u            ' , SAME // ' \"Convert date array to Unix Time\" ' ) call test_d2u () call unit_check_start ( 'd2w            ' , SAME // ' \"Calculate iso-8601 Week-numbering year date yyyy-Www-d\" ' ) call test_d2w () call unit_check_start ( 'date_to_julian ' , SAME // ' \"Converts Proleptic Gregorian date array to Julian Date\" ' ) call test_date_to_julian () call unit_check_start ( 'date_to_unix   ' , SAME // ' \"Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970, UTC)\" ' ) call test_date_to_unix () call unit_check_start ( 'days2sec       ' , SAME // ' \"converts string D-HH:MM:SS to seconds from small to large\" ' ) call test_days2sec () call unit_check_start ( 'dow            ' , SAME // ' \"Return the day of the week\" ' ) call test_dow () call unit_check_start ( 'easter         ' , SAME // ' \"Determine month and day Easter falls on for given year\" ' ) call test_easter () !!call unit_check_start('ephemeris      ',SAME//' \"ephemeris position of planets for adjusting an equatorial telescope\" ') !!call test_ephemeris() call unit_check_start ( 'fmtdate        ' , SAME // ' \"given date array return date as string using format\" ' ) call test_fmtdate () call unit_check_start ( 'fmtdate_usage  ' , SAME // ' \"display macros recognized by fmtdate(3f)\" ' ) call test_fmtdate_usage () call unit_check_start ( 'guessdate      ' , SAME // ' \"Reads in a date, in various formats\" ' ) call test_guessdate () call unit_check_start ( 'j2d            ' , SAME // ' \"Convert Julian Date to date array\" ' ) call test_j2d () call unit_check_start ( 'julian_to_date ' , SAME // ' \"Converts Julian Date to (year, month, day, hour, minute, second)\" ' ) call test_julian_to_date () call unit_check_start ( 'mo2d           ' , SAME // ' \"return date array for beginning of given month name in specified year\" ' ) call test_mo2d () call unit_check_start ( 'mo2v           ' , SAME // ' \"given month as name return month number (1-12) of that month\" ' ) call test_mo2v () call unit_check_start ( 'moon_fullness  ' , SAME // ' \"return name for phase of moon for given date\" ' ) call test_moon_fullness () call unit_check_start ( 'now            ' , SAME // ' \"return string representing current time given format\" ' ) call test_now () call unit_check_start ( 'now_ex         ' , SAME // ' \"use of now(3f) outside of a module\" ' ) call test_now_ex () call unit_check_start ( 'o2d            ' , SAME // ' \"given ordinal day of year return date array, Jan 1st=1\" ' ) call test_o2d () call unit_check_start ( 'ordinal_to_date' , SAME // ' \"given ordinal day of year return date array, Jan 1st=1\" ' ) call test_ordinal_to_date () call unit_check_start ( 'phase_of_moon  ' , SAME // ' \"percentage of moon phase from new to full\" ' ) call test_phase_of_moon () call unit_check_start ( 'sec2days       ' , SAME // ' \"converts seconds to string D-HH:MM:SS\" ' ) call test_sec2days () call unit_check_start ( 'u2d            ' , SAME // ' \"Convert Unix Time to date array\" ' ) call test_u2d () call unit_check_start ( 'unix_to_date   ' , SAME // ' \"Converts Unix Time to date array\" ' ) call test_unix_to_date () call unit_check_start ( 'v2mo           ' , SAME // ' \"returns the month name of a Common month\" ' ) call test_v2mo () call unit_check_start ( 'w2d            ' , SAME // ' \"Given iso-8601 Week-numbering year date yyyy-Www-d calculate date\" ' ) call test_w2d () call unit_check_stop ( 'M_time tests completed' ) contains !=================================================================================================================================== #ifndef _WIN32 subroutine put_environment_variable ( name , value , status ) !  This is an private copy of the set_environment_variable routine(3f) routine from !  M_system.FF that is duplicated in order to prevent a circular dependency. ! ident_33=\"@(#)M_system::put_environment_variable(3f): call setenv(3c) to set environment variable\" character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS integer :: loc_err character ( kind = c_char , len = 1 ), allocatable :: temp_chars1 (:) character ( kind = c_char , len = 1 ), allocatable :: temp_chars2 (:) interface integer ( kind = c_int ) function c_setenv ( c_name , c_VALUE ) bind ( C , NAME = \"setenv\" ) import c_int , c_char character ( kind = c_char ) :: c_name ( * ) character ( kind = c_char ) :: c_VALUE ( * ) end function end interface temp_chars1 = str2arr ( trim ( NAME )) temp_chars2 = str2arr ( VALUE ) loc_err = c_setenv ( temp_chars1 , temp_chars2 ) if ( present ( STATUS )) STATUS = loc_err end subroutine put_environment_variable #else subroutine put_environment_variable ( name , value , status ) character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS write ( * , * ) '<WARNING>put_environment_variable is not working on this platform' if ( present ( STATUS )) STATUS = - 1 end subroutine put_environment_variable #endif !=================================================================================================================================== pure function str2arr ( string ) result ( array ) ! ident_34=\"@(#)M_system::str2arr(3fp): function copies string to null terminated char array\" character ( len =* ), intent ( in ) :: string character ( len = 1 , kind = c_char ) :: array ( len ( string ) + 1 ) integer :: i do i = 1 , len_trim ( string ) array ( i ) = string ( i : i ) enddo array ( size ( array )) = c_null_char end function str2arr !=================================================================================================================================== !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_julian () !!use M_time,    only : date_to_julian, now, fmtdate, date_to_unix, realtime implicit none real ( kind = realtime ) :: julian integer :: ierr call unit_check_start ( 'date_to_julian' , msg = 'Checking Julian Date' ) ! assume if got here passed checks call date_to_julian ( [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , abs ( julian - 244058 7.5d0 ). lt . 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) call date_to_julian ( [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) call date_to_julian ( [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) call date_to_julian ( [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) call date_to_julian ( [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) call date_to_julian ( [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] , julian , ierr ) call unit_check ( 'date_to_julian' , int ( julian ). eq . 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_check_done ( 'date_to_julian' ) end subroutine test_date_to_julian !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_julian_to_date () !!use M_time, only : julian_to_date, fmtdate, realtime implicit none real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected call unit_check_start ( 'julian_to_date' ) juliandate = 245758 9.129d0 ! set sample Julian Date call julian_to_date ( juliandate , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_check ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ). eq . expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_check ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ). eq . expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_check ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ). eq . expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_check_done ( 'julian_to_date' ) end subroutine test_julian_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_unix real ( kind = realtime ) :: unixtime integer :: ierr call unit_check_start ( 'date_to_unix' ) call date_to_unix ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ], unixtime , ierr ) call unit_check ( 'd2u' , abs ( unixtime - 1490766407 ). lt . 0.001 , d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'date_to_unix' ) end subroutine test_date_to_unix !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unix_to_date call unit_check_start ( 'unix_to_date' ) call unit_check ( 'unix_to_date' , all ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]. eq . u2d ( 1490766407 )), msg = d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'unix_to_date' ) end subroutine test_unix_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2o () !!use M_time, only : d2o implicit none integer :: iday , iyear , omonth , oday , rday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme call unit_check_start ( 'd2o' ) do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) rday = d2o ( dat ) call unit_check ( 'd2o' , iday . eq . rday , msg = tests ( i )) enddo call unit_check_done ( 'd2o' ) end subroutine test_d2o !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_seconds () !!use M_time, only : ordinal_seconds implicit none integer :: rday call unit_check_start ( 'ordinal_seconds' ) rday = ordinal_seconds () / ( 60 * 60 * 24 ) call unit_check ( 'ordinal_seconds' , rday . eq . d2o (), rday , d2o ()) call unit_check_done ( 'ordinal_seconds' ) end subroutine test_ordinal_seconds !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_to_date () !!use M_time, only : o2d, ordinal_to_date, d2o implicit none integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme call unit_check_start ( 'ordinal_to_date' ) do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday call ordinal_to_date ( iyear , iday , dat ) call unit_check ( 'ordinal_to_date' , dat ( 2 ). eq . omonth . and . dat ( 3 ). eq . oday , 'year' , iyear , 'ordinal' , iday ) enddo call unit_check_done ( 'ordinal_to_date' ) end subroutine test_ordinal_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_o2d () !!use M_time, only : o2d, ordinal_to_date, d2o implicit none integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme call unit_check_start ( 'o2d' ) do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) call unit_check ( 'o2d' , dat ( 1 ). eq . iyear . and . dat ( 2 ). eq . omonth . and . dat ( 3 ). eq . oday , msg = tests ( i )) enddo call unit_check_done ( 'o2d' ) end subroutine test_o2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_v2mo call unit_check_start ( 'v2mo' ) call unit_check ( 'v2mo' , v2mo ( 1 ). eq . 'January' , msg = 'January' ) call unit_check ( 'v2mo' , v2mo ( 2 ). eq . 'February' , msg = 'February' ) call unit_check ( 'v2mo' , v2mo ( 3 ). eq . 'March' , msg = 'March' ) call unit_check ( 'v2mo' , v2mo ( 4 ). eq . 'April' , msg = 'April' ) call unit_check ( 'v2mo' , v2mo ( 5 ). eq . 'May' , msg = 'May' ) call unit_check ( 'v2mo' , v2mo ( 6 ). eq . 'June' , msg = 'June' ) call unit_check ( 'v2mo' , v2mo ( 7 ). eq . 'July' , msg = 'July' ) call unit_check ( 'v2mo' , v2mo ( 8 ). eq . 'August' , msg = 'August' ) call unit_check ( 'v2mo' , v2mo ( 9 ). eq . 'September' , msg = 'September' ) call unit_check ( 'v2mo' , v2mo ( 10 ). eq . 'October' , msg = 'October' ) call unit_check ( 'v2mo' , v2mo ( 11 ). eq . 'November' , msg = 'November' ) call unit_check ( 'v2mo' , v2mo ( 12 ). eq . 'December' , msg = 'December' ) call unit_check_done ( 'v2mo' ) end subroutine test_v2mo !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2d integer :: dat ( 8 ) call unit_check_start ( 'mo2d' ) call date_and_time ( values = dat ) call unit_check ( 'mo2d' , all ( mo2d ( 'january' , 2019 ). eq .[ 2019 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'January    2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'february' , 2019 ). eq .[ 2019 , 02 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'February   2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'march' , 2019 ). eq .[ 2019 , 03 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'March      2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'april' , 2019 ). eq .[ 2019 , 04 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'April      2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'may' , 2019 ). eq .[ 2019 , 05 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'May        2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'june' , 2019 ). eq .[ 2019 , 06 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'June       2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'july' , 2019 ). eq .[ 2019 , 07 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'July       2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'august' , 2019 ). eq .[ 2019 , 08 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'August     2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'september' , 2019 ). eq .[ 2019 , 09 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'September  2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'october' , 2019 ). eq .[ 2019 , 10 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'October    2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'november' , 2019 ). eq .[ 2019 , 11 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'November   2019' ) call unit_check ( 'mo2d' , all ( mo2d ( 'december' , 2019 ). eq .[ 2019 , 12 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'December   2019' ) call unit_check_done ( 'mo2d' ) end subroutine test_mo2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2v () !!use M_time,     only: mo2v call unit_check_start ( 'mo2v' ) call unit_check ( 'mo2v' , mo2v ( 'jan' ) . eq . 1 , msg = 'Check January' ) call unit_check ( 'mo2v' , mo2v ( 'Feb' ) . eq . 2 , msg = 'Check February' ) call unit_check ( 'mo2v' , mo2v ( 'March' ) . eq . 3 , msg = 'Check March' ) call unit_check ( 'mo2v' , mo2v ( 'APR' ) . eq . 4 , msg = 'Check April' ) call unit_check ( 'mo2v' , mo2v ( 'may' ) . eq . 5 , msg = 'Check May' ) call unit_check ( 'mo2v' , mo2v ( 'jun' ) . eq . 6 , msg = 'Check Jun' ) call unit_check ( 'mo2v' , mo2v ( 'july' ) . eq . 7 , msg = 'Check July' ) call unit_check ( 'mo2v' , mo2v ( 'Aug' ) . eq . 8 , msg = 'Check August' ) call unit_check ( 'mo2v' , mo2v ( 'Sept' ) . eq . 9 , msg = 'Check September' ) call unit_check ( 'mo2v' , mo2v ( 'Oct' ) . eq . 10 , msg = 'Check October' ) call unit_check ( 'mo2v' , mo2v ( 'Nov' ) . eq . 11 , msg = 'Check November' ) call unit_check ( 'mo2v' , mo2v ( 'December' ) . eq . 12 , msg = 'Check December' ) call unit_check ( 'mo2v' , mo2v ( 'jax' ) . eq . 1 , msg = 'Check \"jax\"' ) call unit_check ( 'mo2v' , mo2v ( 'ja' ) . eq . 1 , msg = 'Check \"ja\"' ) call unit_check ( 'mo2v' , mo2v ( 'j' ) . eq . - 1 , msg = 'Check \"j\"' ) call unit_check ( 'mo2v' , mo2v ( '' ) . eq . - 1 , msg = 'Check \"\"' ) call unit_check_done ( 'mo2v' ) ! assume if got here passed checks end subroutine test_mo2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now call unit_check_start ( 'now' ) call unit_check_done ( 'now' ) end subroutine test_now !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate !!use M_time, only: guessdate, fmtdate implicit none character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] call unit_check_start ( 'fmtdate' ) do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment if ( unit_check_level . gt . 0 ) then call unit_check_msg ( 'fmtdate' , 'GIVEN:' // trim ( date1 ) // ' ' // trim ( comment )) endif call guessdate ( date1 , dat ) ! convert date string to DAT call unit_check ( 'fmtdate' , fmtdate ( dat , 'year-month-day' ). eq . trim ( date2 ), 'GOT' , fmtdate ( dat , 'year-month-day' ), 'expected' , date2 ) ! convert DAT to ISO week date, all generated dates should match ISO week date call unit_check ( 'fmtdate' , fmtdate ( dat , \"%I\" ). eq . iso_week_date , msg = iso_week_date ) enddo call unit_check_done ( 'fmtdate' ) end subroutine test_fmtdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate_usage call unit_check_start ( 'fmtdate_usage' ) call unit_check_done ( 'fmtdate_usage' ) end subroutine test_fmtdate_usage !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_guessdate !!use M_time, only: guessdate, w2d, d2w, fmtdate implicit none character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i call unit_check_start ( 'guessdate' ) ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment call guessdate ( date1 , dat ) ! convert date string to DAT call unit_check ( 'guessdate' ,& & fmtdate ( dat , \"%I\" ). eq . iso_week_date , 'input' , date1 , 'produced' , fmtdate ( dat , \"%I\" ), 'expected' , iso_week_date ) call unit_check ( 'guessdate' ,& & fmtdate ( dat , \"year-month-day\" ). eq . date2 , 'input' , date1 , 'produced' , fmtdate ( dat , \"year-month-day\" ), 'expected' , date2 ) enddo call unit_check_done ( 'guessdate' ) end subroutine test_guessdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dow !!use M_time, only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call unit_check_start ( 'dow' ) call date_and_time ( values = dat ) call dow ([ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ], weekday , day , ierr ) call unit_check ( 'dow' , day . eq . 'Saturday' . and . weekday . eq . 6 , msg = 'Saturday' ) call unit_check_done ( 'dow' ) end subroutine test_dow !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_w2d !!use M_time, only: w2d implicit none character ( len = 372 ), allocatable :: line (:) integer :: y , m , d integer :: iso_year integer :: iso_week integer :: iso_weekday integer :: dat ( 8 ) integer :: i call unit_check_start ( 'w2d' ) ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' 2005 01 01  2004 53 6   ' , & & ' 2005 01 02  2004 53 7   ' , & & ' 2005 12 31  2005 52 6   ' , & & ' 2007 01 01  2007 01 1   ' , & & ' 2007 12 30  2007 52 7   ' , & & ' 2007 12 31  2008 01 1   ' , & & ' 2008 01 01  2008 01 2   ' , & & ' 2008 12 28  2008 52 7   ' , & & ' 2008 12 29  2009 01 1   ' , & & ' 2008 12 30  2009 01 2   ' , & & ' 2008 12 31  2009 01 3   ' , & & ' 2009 01 01  2009 01 4   ' , & & ' 2009 12 31  2009 53 4   ' , & & ' 2010 01 01  2009 53 5   ' , & & ' 2010 01 02  2009 53 6   ' , & & ' 2010 01 03  2009 53 7   ' , & & '                          ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) y , m , d , iso_year , iso_week , iso_weekday call w2d ( iso_year , iso_week , iso_weekday , dat ) ! convert ISO week date to DAT call unit_check ( 'w2d' , dat ( 1 ). eq . y . and . dat ( 2 ). eq . m . and . dat ( 3 ). eq . d , msg = line ( i )) ! all should match enddo call unit_check_done ( 'w2d' ) end subroutine test_w2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_box_month integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) character ( len = 21 ) :: mnth ( 8 ) dat = [ 2016 , 07 , 01 , - 240 , 12 , 0 , 0 , 0 ] mnth = [ & '      July 2016      ' , & 'Mo Tu We Th Fr Sa Su ' , & '             1  2  3 ' , & ' 4  5  6  7  8  9 10 ' , & '11 12 13 14 15 16 17 ' , & '18 19 20 21 22 23 24 ' , & '25 26 27 28 29 30 31 ' , & '                     ' ] call unit_check_start ( 'box_month' ) call box_month ( dat , calendar ) if ( unit_check_level . gt . 0 ) then write ( * , '(a)' ) calendar write ( * , '(a)' ) mnth endif call unit_check ( 'box_month' , all ( calendar . eq . mnth ), msg = 'July 2016' ) call unit_check_done ( 'box_month' ) end subroutine test_box_month !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2j real ( kind = realtime ) :: julian call unit_check_start ( 'd2j' ) call unit_check_start ( 'd2j' , msg = 'Checking Julian Date' ) ! assume if got here passed checks julian = d2j ( [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , abs ( julian - 244058 7.5d0 ). lt . 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) julian = d2j ( [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) julian = d2j ( [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) julian = d2j ( [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) julian = d2j ( [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) julian = d2j ( [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ]) call unit_check ( 'd2j' , int ( julian ). eq . 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_check_done ( 'd2j' ) end subroutine test_d2j !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_j2d real ( kind = realtime ) :: juliandate character ( len = :), allocatable :: expected call unit_check_start ( 'j2d' ) juliandate = 245758 9.129d0 ! set sample Julian Date expected = '2016-07-19 11:05:45' call unit_check ( 'j2d' , fmtdate ( j2d ( juliandate ), 'year-month-day hour:minute:second' ). eq . expected , & & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( j2d ( juliandate ), 'year-month-day hour:minute:second' )) ! go back one day expected = '2016-07-18 11:05:45' call unit_check ( 'j2d' , fmtdate ( j2d ( juliandate - 1.0d0 ), 'year-month-day hour:minute:second' ). eq . expected , & & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( j2d ( juliandate - 1.0d0 ), 'year-month-day hour:minute:second' )) ! go forward one day expected = '2016-07-20 11:05:45' call unit_check ( 'j2d' , fmtdate ( j2d ( juliandate + 1.0d0 ), 'year-month-day hour:minute:second' ). eq . expected , & & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( j2d ( juliandate + 1.0d0 ), 'year-month-day hour:minute:second' )) call unit_check_done ( 'j2d' ) end subroutine test_j2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2u () !!use M_time, only : d2u implicit none !  Note that time zones are usually -HHMM or -HH:MM and not MM, which is what the DAT array uses !  Comparing to Unix date(1) command: !    date --date \"Wed Mar 29 01:46:47 EDT 2017\" +%s      ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 2017\" +%s          ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 -400 2017\" +%s     ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-400 2017\" +%s  ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-4:00 2017\" +%s ! 1490766407 call unit_check_start ( 'd2u' ) call unit_check ( 'd2u' , nint ( d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) + 0.5 ). eq . 1490766407 , d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'd2u' ) end subroutine test_d2u !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_u2d call unit_check_start ( 'u2d' ) call unit_check ( 'u2d' , all ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]. eq . u2d ( 1490766407 )),& & d2u ([ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ]) ) call unit_check_done ( 'u2d' ) end subroutine test_u2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sec2days () !!use M_time, only: sec2days implicit none call unit_check_start ( 'sec2days' ) call unit_check ( 'sec2days' , sec2days ( 129860 ). eq . '1-12:04:20' , '129860 is 1-12:04:20' ) call unit_check ( 'sec2days' , sec2days ( 8000 0.0d0 ). eq . '0-22:13:20' , '80000.0d0 is 0-22:13:20' ) call unit_check ( 'sec2days' , sec2days ( 80000 , crop = . true .). eq . '22:13:20' , '80000 is 22:13:20' ) call unit_check ( 'sec2days' , sec2days ( '1day 2hr 3 min 4s' ). eq . '1-02:03:04' , '1day 2hr 3 min 4s is 1-02:03:04' ) call unit_check_done ( 'sec2days' ) end subroutine test_sec2days !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_days2sec () !!use M_time, only  : days2sec, realtime implicit none call unit_check_start ( 'days2sec' ) call unit_check ( 'days2sec' , nint ( days2sec ( '1' )). eq . 1 , 'expected' , 1 , 'got' , nint ( days2sec ( '1' ))) call unit_check ( 'days2sec' , nint ( days2sec ( '1:00' )). eq . 60 , 'expected' , 60 , 'got' , nint ( days2sec ( '1:00' ))) call unit_check ( 'days2sec' , nint ( days2sec ( '1:00:00' )). eq . 3600 , 'expected' , 3600 , 'got' , nint ( days2sec ( '1:00:00' ))) call unit_check ( 'days2sec' , nint ( days2sec ( '1-00:00:00' )). eq . 86400 , 'expected' , 86400 , 'got' , nint ( days2sec ( '1-00:00:00' ))) call unit_check ( 'days2sec' ,& & nint ( days2sec ( '1d2h 3.0 minutes 4sec' )). eq . 93784 , 'expected' , 1 , 'got' , nint ( days2sec ( '1d2h 3.0 minutes 4sec' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1-12:04:20              ' )) . eq . 129860 , & & 'expected' , 129860 , 'got' , nint ( days2sec ( '1.12:03:20' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1.5 days                ' )) . eq . 129600 , & & 'expected' , 129600 , 'got' , nint ( days2sec ( '1.5 days' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) . eq . 145800 , & & 'expected' , 145800 , 'got' , nint ( days2sec ( '1.5 days 4hrs 30minutes' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1.5d                    ' )) . eq . 129600 , & & 'expected' , 129600 , 'got' , nint ( days2sec ( '1.5d' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1d2h3m4s                ' )) . eq . 93784 , & & 'expected' , 93784 , 'got' , nint ( days2sec ( '1d2h3m4s' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 1d1d1d                  ' )) . eq . 259200 , & & 'expected' , 259200 , 'got' , nint ( days2sec ( '1d1d1d' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 4d-12h                  ' )) . eq . 302400 , & & 'expected' , 302400 , 'got' , nint ( days2sec ( '4d-12h' ))) call unit_check ( 'days2sec' , nint ( days2sec ( ' 3  d  1 2   h           ' )) . eq . 302400 , & & 'expected' , 302400 , 'got' , nint ( days2sec ( '3 d 1 s  h' ))) call unit_check_done ( 'days2sec' ) end subroutine test_days2sec !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_phase_of_moon integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_check_start ( 'phase_of_moon' ) call unit_check ( 'phase_of_moon' , phase_of_moon ( dat ). eq . 'Waning crescent' ) call unit_check_done ( 'phase_of_moon' ) end subroutine test_phase_of_moon !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_moon_fullness integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_check_start ( 'moon_fullness' ) call unit_check ( 'moon_fullness' , moon_fullness ( dat ). eq . - 30 ) call unit_check_done ( 'moon_fullness' ) end subroutine test_moon_fullness !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_easter () !!use M_time,  only : easter implicit none character ( len = 20 ), parameter :: tests ( * ) = [ & '1980,4,6  ' , & '1981,4,19 ' , & '1982,4,11 ' , & '1983,4,3  ' , & '1984,4,22 ' , & '1985,4,7  ' , & '1986,3,30 ' , & '1987,4,19 ' , & '1988,4,3  ' , & '1989,3,26 ' , & '1990,4,15 ' , & '1991,3,31 ' , & '1992,4,19 ' , & '1993,4,11 ' , & '1994,4,3  ' , & '1995,4,16 ' , & '1996,4,7  ' , & '1997,3,30 ' , & '1998,4,12 ' , & '1999,4,4  ' , & '2000,4,23 ' , & '2001,4,15 ' , & '2002,3,31 ' , & '2003,4,20 ' , & '2004,4,11 ' , & '2005,3,27 ' , & '2006,4,16 ' , & '2007,4,8  ' , & '2008,3,23 ' , & '2009,4,12 ' , & '2010,4,4  ' , & '2011,4,24 ' , & '2012,4,8  ' , & '2013,3,31 ' , & '2014,4,20 ' , & '2015,4,5  ' , & '2016,3,27 ' , & '2017,4,16 ' , & '2018,4,1  ' , & '2019,4,21 ' , & '2020,4,12 ' , & '2021,4,4  ' , & '2022,4,17 ' , & '2023,4,9  ' , & '2024,3,31 ' ] character ( len = 20 ) :: readme integer :: tmonth , tday integer :: inyear , outmonth , outday integer :: ii integer :: dat ( 8 ) character ( len = 5 ) :: mon ( 3 : 4 ) = ( / 'march' , 'april' / ) call unit_check_start ( 'easter' ) ! assume if got here passed checks do ii = 1 , size ( tests ) readme = tests ( ii ) ! cannot do internal read on a parameter read ( readme , * ) inyear , tmonth , tday call easter ( inyear , dat ) outmonth = dat ( 2 ) outday = dat ( 3 ) call unit_check ( 'easter' , tmonth . eq . outmonth . and . tday . eq . outday , tests ( ii ), 'month=' , mon ( outmonth )) enddo call unit_check_done ( 'easter' ) ! assume if got here passed checks end subroutine test_easter !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now_ex call unit_check_start ( 'now_ex' ) call unit_check_done ( 'now_ex' ) end subroutine test_now_ex !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2w () use M_verify , only : unit_check , unit_check_good , unit_check_bad , unit_check_done , unit_check_start , unit_check_msg , unit_check_level implicit none call unit_check_start ( 'd2w' , msg = 'Examples of contemporary dates around New Year''s Day' ) call date_and_time ( values = dat ) dat = [ 2005 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 1 Jan 2005 2005-01-01 2004-W53-6 call showme ( \"2004-W53-6\" ) dat = [ 2005 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 2 Jan 2005 2005-01-02 2004-W53-7 call showme ( \"2004-W53-7\" ) dat = [ 2005 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 31 Dec 2005 2005-12-31 2005-W52-6 call showme ( \"2005-W52-6\" ) dat = [ 2007 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 1 Jan 2007 2007-01-01 2007-W01-1 Both years 2007 start with the same day. call showme ( \"2007-W01-1\" ) dat = [ 2007 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 30 Dec 2007 2007-12-30 2007-W52-7 call showme ( \"2007-W52-7\" ) dat = [ 2007 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 31 Dec 2007 2007-12-31 2008-W01-1 call showme ( \"2008-W01-1\" ) dat = [ 2008 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 1 Jan 2008 2008-01-01 2008-W01-2 !     Gregorian year 2008 is a leap year. ... !     ISO year 2008 is 2 days shorter: 1 day longer at the start, 3 days shorter at the end. call showme ( \"2008-W01-2\" ) dat = [ 2008 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 28 Dec 2008 2008-12-28 2008-W52-7 ... !     ISO year 2009 begins three days before the end of Gregorian 2008. call showme ( \"2008-W52-7\" ) dat = [ 2008 , 12 , 29 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 29 Dec 2008 2008-12-29 2009-W01-1 call showme ( \"2009-W01-1\" ) dat = [ 2008 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 30 Dec 2008 2008-12-30 2009-W01-2 call showme ( \"2009-W01-2\" ) dat = [ 2008 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Wed 31 Dec 2008 2008-12-31 2009-W01-3 call showme ( \"2009-W01-3\" ) dat = [ 2009 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 1 Jan 2009 2009-01-01 2009-W01-4 call showme ( \"2009-W01-4\" ) dat = [ 2009 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 31 Dec 2009 2009-12-31 2009-W53-4  ... !     ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010. call showme ( \"2009-W53-4\" ) dat = [ 2010 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Fri 1 Jan 2010 2010-01-01 2009-W53-5 call showme ( \"2009-W53-5\" ) dat = [ 2010 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 2 Jan 2010 2010-01-02 2009-W53-6 call showme ( \"2009-W53-6\" ) dat = [ 2010 , 01 , 03 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 3 Jan 2010 2010-01-03 2009-W53-7 call showme ( \"2009-W53-7\" ) call unit_check_done ( 'd2w' ) ! assume if got here passed checks end subroutine test_d2w subroutine showme ( string ) use M_time , only : d2w implicit none character ( len =* ) :: string integer :: iyear , iweek , iweekday character ( len = 10 ) :: name call d2w ( dat , iyear , iweek , iweekday , name ) call unit_check ( 'd2w' , name . eq . string , iyear , iweek , iweekday , name , string ) end subroutine showme !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end subroutine test_suite_M_time !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","loc":"sourcefile/test_suite_m_time.f90.html"}]}