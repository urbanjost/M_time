var tipuesearch = {"pages":[{"title":" M_time ","text":"M_time M_time Name M_time - Fortran module for manipulating and presenting time and date values Description M_time(3f) displays Civilian Calendar dates in many formats. In addition to high-level date formatting, it can manipulate or read\nmany other date representations … Julian and Modified Julian Dates Baseday and Seconds Dates Unix Epoch Dates High-level date formatting Ordinal days of the year days of the week ISO-8601 week numbers month and weekday names (limited) internationalization Julian and Unix Epoch Dates are particularly useful for\nmanipulating dates in simple numeric expressions. They are numbers with\nunits of days and seconds respectively from a fixed date that you can\neasily convert to and from. So you can convert any date to a Julian Date,\nsubtract one and you have the date for the day before, for example. The M_time Fortran module complements the DATE_AND_TIME(3f) procedure\n( it is the standard Fortran intrinsic subroutine that returns the\ncurrent date and time in the Gregorian calendar). That is, the primary\nway this module represents dates is as an integer array with the same\nmeaning for elements as defined by the DATE_AND_TIME(3f) routine. The extensive formatting options include showing SYSTEM_CLOCK(3f) and CPU_USAGE(3f) information along with Gregorian date information,\nallowing for the easy incorporation of timing information into program\nmessages. In addition to conventional Civilian Calendar dates, the module supports\nthe ISO-8601 standard. Procedural, Functional, and OOP (Object Oriented Programming) interfaces\nare provided. Each routine is accompanied by a man(1) page which includes a sample\nprogram for that procedure. An HTML manual, the source, and example\nprograms for each procedure are included in the package. Procedures Epoch Time (UT starts at 0000 on 1 Jan. 1970) date_to_unix (dat,UNIXTIME,IERR) ! Convert date array to Unix Time unix_to_date (unixtime,DAT,IERR) ! Convert Unix Time to date array d2u (dat) result (UNIXTIME) ! Convert date array to Unix Time u2d (unixtime) result (DAT) ! Convert Unix Time to date array Julian julian_to_date (julian,DAT,IERR) ! Convert Julian Date to date array date_to_julian (dat,JULIAN,IERR) ! Convert date array to Julian Date d2j (dat) result (JULIAN) ! Convert date array to Julian Date j2d (julian) result (DAT) ! Convert Julian Date to date array Modified Julian modified_julian_to_date (modified_julian,DAT,IERR) ! Convert Modified Julian Date to date array date_to_modified_julian (dat,MODIFIED_JULIAN,IERR) ! Convert date array to Modified Julian Date d2m (dat) result (MODIFIED_JULIAN) ! Convert date array to Modified Julian Date m2d (modified_julian) result (DAT) ! Convert Modified Julian Date to date array Baseday and Seconds bas_to_date (bas,DAT,IERR) ! Convert Baseday and Seconds to date array date_to_bas (dat,bas,IERR) ! Convert date array to Baseday and Seconds type d2b (dat) result (bas) ! Convert date array to Baseday and Seconds b2d (bas) result (DAT) ! Convert Baseday and Seconds to date array Day of Week dow (dat,[WEEKDAY],[DAY],IERR) ! Convert date array to day of the week as number and name Week of Year d2w (dat,ISO_YEAR,ISO_WEEK,ISO_WEEKDAY,ISO_NAME) ! Calculate iso-8601 Week-numbering year date yyyy-Www-d w2d ([iso8601_week]|[iso_year,iso_week,iso_weekday],DAT) ! given iso-8601 Week as numeric year, week and day_of_week, or string “yyyy-Www-d” calculate date as a DAT array Ordinal Day d2o (dat) result(ORDINAL) ! given date array return ordinal day of year, Jan 1st=1 o2d (ordinal) result(DAT) ! given ordinal day of year return date array, Jan 1st=1 ordinal_to_date (year,ordinal_day,DAT) ! given ordinal day of year return date array, Jan 1st=1 ordinal_seconds () ! seconds since the beginning of current year Printing Dates fmtdate (dat,format) result (TIMESTR) ! Convert date array to string using format fmtdate_usage (indent) ! display macros recognized by fmtdate locale (name,mths,wks,mths,short,wks_short,ierr) ! allow substituting other strings for month and weekday names, including predefined sets for languages representable in extended ASCII. now (format) result (NOW) ! return string representing current time given format box_month (dat,CALEN) ! print specified month into character array Printing Durations sec2days (seconds) result (DHMS) ! converts seconds to string D-HH:MM:SS days2sec (str) result (SECONDS) ! converts strings like “D-HH:MM:SS” or “4 days 2 hrs” to seconds Month Name mo2v (month_name) result (MONTH_NUMBER) ! given month name return month number v2mo (month_number) result (MONTH_NAME) ! given month number return month name mo2d (month_name) result (DAT) ! given month name and year return date array for 1st day of month Astrological easter (year,dat) ! calculate month and day Easter falls on for given year moon_fullness (datin) result(FULLNESS) ! percentage of moon phase from new to full phase_of_moon (datin) result(PHASE) ! return name for phase of moon for given date Reading Dates guessdate (anot,dat) ! Converts a date string to a date array, in various formats Convenient Constants for use with + and - Operators integer , parameter , public :: realtime = kind ( 0.0d0 ) ! type for unix epoch time and julian days real ( kind = realtime ), public , parameter :: dt_minute = 6 0.0_dp ! one minute in seconds real ( kind = realtime ), public , parameter :: dt_hour = 360 0.0_dp ! one hour in seconds real ( kind = realtime ), public , parameter :: dt_day = 8640 0.0_dp ! 24:00:00 hours in seconds real ( kind = realtime ), public , parameter :: dt_week = dt_day * 7.0_dp ! one week in seconds –> Example A simple program that formats the current time as desired, and displays\nthe built-in help text for the formatting options is as simple as program demo_now use M_time , only : now implicit none write ( * , * ) now ( \"The current date is %w, %l %d, %Y %H:%m:%s %N\" ) ! % macros write ( * , * ) now ( \"year-month-day\" ) ! or, if macros not found then keywords write ( * , * ) now ( \"Y-M-D h:m:s\" ) ! and if that is not found, abbreviations call locale ( 'french' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) call locale ( 'slovak' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) call locale ( 'spanish' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) end program demo_now The current date is Wed, Feb 5th, 2025 8:57:07 AM\n    2025-02-05\n    2025-02-05 08:57:07\n    mercredi, février 05, 2025 08:57:07\n    streda, február 05, 2025 08:57:07\n    miércoles, febrero 05, 2025 08:57:07 A built-in description of the macro and keyword substitution rules\ncan be called to easily add the information to program help messages\nand documentation. program builtin_macrohelp use M_time , only : fmtdate_usage implicit none ! built-in usage descriptions can be displayed as well call fmtdate_usage () ! see all formatting options end program builtin_macrohelp Description                                        Example\n\n   Base time array:\n    1) %Y | year, yyyy                             2025\n    2) %M | month of year, 01 to 12                02\n    3) %D | day of month, 01 to 31                 19\n       %d | day of month with suffix (1st,2nd,...) 19th\n       %K | day of month in English (eg. first)    757554556\n    4) %Z | minutes from UTC                       -0300m\n       %z | -+hh:mm from UTC                       -05:00\n       %T | -+hhmm  from UTC                       -0500\n    5) %h | hours, 00 to 23                        16\n       %H | hour (1 to 12, or twelve-hour clock)   4\n       %N | midnight<AM<=noon; noon<=PM<midnight   PM\n    6) %m | minutes, 00 to 59                      41\n    7) %s | sec, 00 to 59                          53\n    8) %x | milliseconds 000 to 999                150\n   Conversions:\n       %E | Unix Epoch time                        1740001313.1499977\n       %e | integer value of Unix Epoch time       1740001313\n       %F | Modified Julian date                   60725.904087384231\n       %f | integer value of Modified Julian Date  60725\n       %G | Baseday and Seconds                    (60725,78113.151003420353)\n       %g | Baseday seconds                        78113.151003420353\n       %J | Julian  date                           2460726.4040873959\n       %j | integer Julian Date(Julian Day)        2460726\n       %O | Ordinal day (day of year)              050\n       %o | Whole days since Unix Epoch date       20138\n       %U | day of week, 1..7 Sunday=1             4\n       %u | day of week, 1..7 Monday=1             3\n       %i | ISO week of year 1..53                 8\n       %I | iso-8601 week with weekday: yyyy-Www-d 2025-W08-3\n    Names:\n       %l | abbreviated month name                 Feb\n       %L | full month name                        February\n       %w | first three characters of weekday      Wed\n       %W | weekday name                           Wednesday\n       %p | phase of moon                          Last quarter\n       %P | percent of way from new to full moon   -54%\n       %X | day of the month in English            nineteenth\n    Literals:\n       %% | a literal %                             %\n       %t | tab character                           \n       %b | blank character\n       %B | exclamation(bang) character            !\n       %n | new line (system dependent)            \n\n       %q | single quote (apostrophe)              '\n       %Q | double quote                           \"\n    Duration:\n       %a | Time since now as d-hh:mm:ss           0-00:00:00\n       %A | Time since now as seconds              0.0000000000000000\n    Program timing:\n       %c | CPU_TIME(3f) output                    0.45703999999999995E-1\n       %C | number of times this routine is used   1\n       %S | seconds since last use of this format  0.0000000000000000\n       %k | time in seconds from SYSTEM_CLOCK(3f)  757554.562\n       %K | time in clicks from SYSTEM_CLOCK(3f)   757554565\n    Help:\n       %? | call fmtdate_usage()\n\n   If no percent (%) is found in the format one of several\n   alternate substitutions occurs.\n\n   If the format is composed entirely of one of the following\n   keywords the following substitutions occur:\n    iso-8601,\n    iso          ==> %Y-%M-%DT%h:%m:%s%z ==> 2025-02-19T16:41:53-05:00\n    iso-8601W,\n    isoweek      ==> %I ==> 2025-W08-3\n    sql          ==> %Y-%M-%D %h:%m:%s.%x ==> 2025-02-19 16:41:53.158\n    sqlday       ==> %Y-%M-%D ==> 2025-02-19\n    sqltime      ==> %h:%m:%s.%x ==> 16:41:53.159\n    dash         ==> %Y-%M-%D ==> 2025-02-19\n    rfc-2822     ==> %w, %D %l %Y %h:%m:%s %T\n                       Wed, 19 Feb 2025 16:41:53 -0500\n    rfc-3339     ==> %Y-%M-%DT%h:%m:%s%z ==> 2025-02-19T16:41:53-05:00\n    date         ==> %w %l %D %h:%m:%s UTC%z %Y\n                       Wed Feb 19 16:41:53 UTC-05:00 2025\n    short        ==> %w, %l %d, %Y %H:%m:%s %N UTC%z\n                       Wed, Feb 19th, 2025 4:41:53 PM UTC-05:00\n    long,\" \"     ==> %W, %L %d, %Y %H:%m:%s %N UTC%z\n                       Wednesday, February 19th, 2025 4:41:53 PM UTC-05:00\n    suffix       ==> %Y%D%M%h%m%s ==> 20251902164153\n    formal       ==> The %d of %L %Y ==> The 19th of February 2025\n    lord         ==> the %d day of %L in the year of our Lord %Y\n                       the 19th day of February in the year of our Lord 2025\n    easter       ==> FOR THE YEAR OF THE CURRENT DATE:\n                       Easter day: the %d day of %L in the year of our Lord %Y\n    all          ==> A SAMPLE OF DATE FORMATS\n    usage|help|? ==> call fmtdate_usage\n   otherwise the following words are replaced with the most\n   common macros:\n      year                        %Y  2025\n      month                       %M  02\n      day                         %D  19\n      timezone                    %z  -05:00\n      hour                        %h  16\n      minute                      %m  41\n      second                      %s  53\n      millisecond                 %x  164\n      epoch                       %e  1740001313\n      julian                      %j  2460726\n      ordinal                     %O  050\n      weekday                     %u  3\n      longmonth|MONTH             %L  February\n      shortmonth|Month|Mth        %l  Feb\n      shortday|DAY                %d  19th\n      longday                     %X  nineteenth\n      goodhour|HOUR               %H  4\n      GOOD                        %N  PM\n      shortweekday|Weekday|wkday  %w  Wed\n      longweekday|WEEKDAY         %W  Wednesday\n      Timezone                    %Z  -0300m\n      TIMEZONE                    %z  -05:00\n      age                         %a  0-00:00:00\n      AGE                         %A  0.0000000000000000 If none of these keywords are found then every letter that\n   is a macro is assumed to have an implied percent in front\n   of it. For example: YMDhms ==> %Y%M%D%h%m%s ==> 20250219164153 Documentation User man-page index BOOK_M_time is a consolidated\n  single-page version of the man-pages for ease in printing and searching( requires javascript ) Furthermore there are actual man-pages that can be installed on ULS (Unix-Like Systems): manpages.tgz manpages.zip Developer Documentation doxygen output . ford output . CHANGELOG Download tarball or zip file archive files containing released\n  versions in tar(1) and zip(1) format. Download and Build using gmake To build the modules download the github repository, enter the src/\ndirectory and run make(1): git clone https://github.com/urbanjost/M_time.git\n     cd M_time/src\n\n     make clean\n     # change Makefile if not using one of the listed compilers\n     # COMPILER_NAME={ifort, nvfortran, or gfortran}\n     make $COMPILER_NAME\n\n     # optionally\n     make help # see other developer options\n     make run  # run all the demo programs from the man-pages This will compile the M_time module and optionally build all the example programs from\nthe document pages (in the example/ sub-directory) and run the unit tests. Download and Build using fpm To download the github repository and build and test it with fpm : git clone https://github.com/urbanjost/M_time.git cd M_time # on MSWindows: fpm test -flag \"-D _WIN32\" # on other platforms fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_time = { git = \"https://github.com/urbanjost/M_time.git\" } Download and Build using cmake To download the github repository and build and install with cmake\n(you may wish to change the install path in src/CMakeLists.txt first) : git clone https://github.com/urbanjost/M_time.git cd M_time # Create a Build Directory: mkdir -p build cd build cmake -S ../src -B . # Configure the Build, specifying your preferred compiler (ifort, flang, etc.): cmake . -DCMAKE_Fortran_COMPILER = gfortran # Build the Project: cmake --build . #This creates: # #    build/lib/libM_time.a (the static library). #    build/include/*.mod (module files). #    build/test/* (test executables). #    build/example/* (example executables). # OPTIONAL SECTION: # Verify build ls build/lib/libM_time.a ls build/include/*.mod ls build/test/* ls build/example/* #Optionally Run Tests and Examples: for name in ./test/* ./example/* do $name done #Install (Optional): # This installs the library and module files to the system # (e.g., /usr/local/lib/ and /usr/local/include/). cmake --install . # if you have insufficient permissions sudo(1) may be required # to perform the install #sudo cmake --install . # Verify installation ls /usr/local/lib/libM_time.a ls /usr/local/include/*.mod # Cleaning Up: To clean artifacts, remove the build/ directory: rm -rf build Demo Programs Each man-page contains a small sample program that has been extracted\nand placed in the example/ directory.  The small example programs\ndemonstrate how easily you can generate a variety of output formats: Sun, Jan 5th, 2020 10:48:33 AM UTC-05:00\n\n    Sunday, January 5th, 2020 10:48:53 AM UTC-05:00\n\n        January 2020\n    Mo Tu We Th Fr Sa Su\n           1  2  3  4  5\n     6  7  8  9 10 11 12\n    13 14 15 16 17 18 19\n    20 21 22 23 24 25 26\n    27 28 29 30 31\n\n    Julian Date is 2458854.1545532290\n\n    Unix Epoch time is 1578238955.5700049\n\n    ISO-8601 Week: 2020-W01-7\n\n    Day of year is: 5\n\n    for year 2020 days in year is: 366\n\n    weekday=7 day=Sunday\n\n    Easter day: the 12th day of April in the year of our Lord 2020 In particular, the example program “now” easily lets you try out various\noptions. With no options it displays allowed formats. For example: ./now year month day\n      ./now 'julian epoch ordinal'\n      ./now 'The year is %Y and the month is %M (%L) %h:%m:%s'\n      ./now formal\n\n       20200105\n       2458854 1578240100 005\n       The year is 2020 and the month is 01 (January) 11:01:39\n       The 5th of January 2020 Definitions A “date_and_time” array “DAT” has the same format as the array of\nvalues generated by the Fortran intrinsic DATE_AND_TIME(3f). That is,\nit is an 8-element integer array containing year, month, day, Time zone\ndifference from UTC in minutes, hour, minutes, seconds, and milliseconds\nof the second. This array represents a date on the Proleptic Gregorian\nCalendar. The Proleptic Gregorian Calendar assumes the Gregorian Calendar\nexisted back to the beginning of the Julian Day calendar (4713 BC). This\nmeans historic dates will often be confused, as the Julian Calendar was\nused in the USA until 1752-09-03, for example. The Gregorian Calendar was\nformally decreed on 1582-10-15 but was not adapted in many countries. The\nJulian Calendar was first used around 45 BC. Note that the Proleptic\nGregorian Calendar includes a year zero (0). It is frequently used in\ncomputer software to simplify the handling of older dates. For example,\nit is the calendar used by MySQL, SQLite, PHP, CIM, Delphi, Python and\nCOBOL. The Proleptic Gregorian Calendar is explicitly required for all\ndates before 1582 by ISO 8601:2004 (clause 4.3.2.1 The Gregorian calendar)\nif the partners to information exchange agree. Unix Epoch Time (UET) is defined as the number of seconds since\n00:00:00 on January 1st. 1970, UTC. A JD is defined as a Julian Date . JD days start at\nnoon (not at midnight). 4713-01-01 BC at noon is defined as JD 0.0. If you are not familiar with them, in this context Julian Dates and Unix\nEpoch Times are scalar numbers that allow for easy computations using\ndates (to go back one day just subtract one from a Julian Date, for\nexample). Since these values are generally not considered intelligible,\nroutines are included to convert between these scalar values and the\ndate array so human-readable results can be obtained. Modified Julian Date (MJD) measures days (and fractional days) since\nthe start of 17 Nov 1858 CE in Universal Time (UTC). Julian Date (JD)\nmeasures days (and fractional days) since noon on 1 January, 4713 BCE\nin Universal Time (UTC). Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5 Baseday and Seconds (BAS) dates are an alternate form of the MJD\n(Modified Julian Date) where the date is stored as a structure named\n“ BAStime ”, containing the number of days since the beginning of the MJD\nEpoch and a double representing the seconds offset from the start of\nthis day. type BAStime integer :: base_day ! number of days since the MJD Epoch date real ( kind = real64 ) :: secs ! seconds from start of base_day end type BAStime This allows for storing a date at a higher precision that the other\nformats used by the library, although sometimes that lower precision\nis limited primarily by the definition (ie. the milliseconds in a DAT\ncould be smaller units). BAS (and MJD) starts at midnight (00:00:00) so truncating the\nfractional component of BAS always gives the same Civil Calendar day\nwhatever the time of day (unlike JD). The seconds offset may take any double-precision value, so that any\ndate/time may be expressed in terms of an offset from the same MJD\nday. The seconds field thus may exceed a single day, and may also be\nnegative. Note that in floating-point math larger numbers will have\na wider spacing between representable values, possibly decreasing\nthe precision of results. Coordinated Universal Time (French: Temps universel coordonn’\be),\nabbreviated as UTC , is the primary time standard by which the world\nregulates clocks and time. It is within about 1 second of mean solar\ntime at 0o longitude;[1] it does not observe daylight saving time. It\nis one of several closely related successors to Greenwich Mean Time\n(GMT). For most purposes, UTC is considered interchangeable with GMT,\nbut GMT is no longer precisely defined by the scientific community. Limitations Like most collections of date and time procedures M_time is not a\nhigh- precision library that accounts internally for leap seconds and\nrelativistic effects. M_time(3f) is intended for use in the recent era and is not appropriate\nfor use with historical dates that used some other calendar scheme such\nas the Julian Calendar. That is, you have to remember to account for\nconversions to other calendar systems when using historical dates. When Daylight Savings is in effect calculations will generally be correct,\nas the date model includes a timezone value; but you are responsible for\nensuring dates you create use the correct timezone value or otherwise\naccount for Daylight Savings Time as needed. Currently, dates are manipulated using the current system timezone, which\ncan typically be set using the environment variable TZ. So if you desire\nto set the default timezone you generally set the environment variable before executing your program. This is compatible with current observed\nbehavior for the intrinsic procedure DATE_AND_TIME(3f) with compilers I\nhave tested with, but does not seem to be a specified behavior as far as\nthe standard is concerned. That is, DATE_AND_TIME(3f) returns a vector\nthat contains a current time zone, but does not specify how a current\ntime zone can be explicitly set.  Since this library is intentionally\ndesigned to complement DATE_AND_TIME(3f) it adopts the same behavior. Status CD/CI STATUS See Also The ISO-8601 standard is often used for business-related transactions. There are (of course) the C/C++ intrinsics which provide much of the same\nfunctionality that should be bindable to Fortran via the ISO_C_BINDING\nmodule. If you are looking for a high-precision Fortran library that is well\ntested for manipulating dates I would suggest looking at the NASA\nSPICElib library.  If you care about Leap Seconds, Orbital Mechanics,\nGPS/Satellite communications, and Astronomy it is worth a look. The Fortran Wiki fortranwiki.org contains\ninformation on other libraries and modules that provide date-time\nprocedures. References Gregorian Calendar(Wikipedia) Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"date_time – M_time ","text":"type, public :: date_time Components Type Visibility Attributes Name Initial integer, public :: day = 1 integer, public :: hour = 0 integer, public :: millisecond = 0 integer, public :: minute = 0 integer, public :: month = 1 integer, public :: second = 0 integer, public :: tz = 0 integer, public :: year = 1970 Constructor public        interface date_time private  function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (:) Return Value type( date_time ) Type-Bound Procedures procedure, public :: datout => dt2d_ private  function dt2d_(self) result(dat) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value integer, (8) procedure, public :: delta private  function delta(self, year, month, day, tz, hour, minute, second, millisecond, week, duration) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: tz integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond integer, intent(in), optional :: week character(len=*), intent(in), optional :: duration Return Value type( date_time ) procedure, public :: epoch => epoch_ private  function epoch_(self) result(epoch_seconds) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value real(kind=realtime) procedure, public :: format private  function format(self, fmt) result(string) usually used in a WRITE(3f) or PRINT(3f) so should not write output Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable procedure, public :: init => init_dt private  subroutine init_dt(self, year, month, day, tz, hour, minute, second, millisecond, type, dat) Arguments Type Intent Optional Attributes Name class( date_time ) :: self integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: tz integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: millisecond character(len=*), intent(in), optional :: type integer, intent(in), optional :: dat (8) procedure, public :: julian => julian_ private  function julian_(self) result(julian_days) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value real(kind=realtime) procedure, public :: mjd => mjd_ private  function mjd_(self) result(mjd_days) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value real(kind=realtime) generic, public :: operator(+) => plus_seconds private  function plus_seconds(self, seconds) result(dattim) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self real(kind=realtime), intent(in) :: seconds Return Value type( date_time ) generic, public :: operator(-) => minus_seconds private  function minus_seconds(self, seconds) result(dattim) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self real(kind=realtime), intent(in) :: seconds Return Value type( date_time ) generic, public :: operator(-) => minus_date_time private  function minus_date_time(self, other) result(seconds) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value real(kind=realtime) generic, public :: operator(/=) => ne private  function ne(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(<) => lt private  function lt(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(<=) => le private  function le(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(==) => eq private  function eq(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(>) => gt private  function gt(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical generic, public :: operator(>=) => ge private  function ge(self, other) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self type( date_time ), intent(in) :: other Return Value logical procedure, public :: ordinal private  function ordinal(self) result(ordinal_days) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value integer procedure, public :: weekday private  function weekday(self) result(iday) Arguments Type Intent Optional Attributes Name class( date_time ), intent(in) :: self Return Value integer","tags":"","url":"type/date_time.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   sec2days(1f) - [TIME] Convert durations of time to string of form dd-hh:mm:ss' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   sec2days nnnn[.xxx] [ -crop]| --version| --help                              ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a numeric string representing seconds or labeled units of time         ' ,& '   convert it to a string of the form                                           ' ,& '                                                                                ' ,& '      dd-hh:mm:ss                                                               ' ,& '                                                                                ' ,& '   where dd is days, hh hours, mm minutes and ss seconds.                       ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   nnnn[.xxx]  Defaults to number of seconds to convert to string of            ' ,& '               form dd-hh:mm:ss.  nnnn may be interspersed with unit            ' ,& '               codes d,h,m,s. Spaces, commas and case are ignored. Allowed      ' ,& '               aliases for the unit codes are                                   ' ,& '                                                                                ' ,& '                 d  days and day                                                ' ,& '                 h  hours,hour,hrs, and hr                                      ' ,& '                 m  minutes,minute and min                                      ' ,& '                 s  seconds,second and sec                                      ' ,& '                                                                                ' ,& '   -crop       trim leading zero values from output                             ' ,& '   -radix      character used as decimal separator                              ' ,& '   --help      display this help and exit                                       ' ,& '   --version   output version information and exit                              ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& ' usage                                                                          ' ,& '                                                                                ' ,& '   sec2days 129860                                                              ' ,& '   1-12:04:20                                                                   ' ,& '   sec2days 1d2h3m4s                                                            ' ,& '   1-02:03:04                                                                   ' ,& '   sec2days 1.0 days 2 hours 3 minutes 4 seconds                                ' ,& '   1-02:03:04                                                                   ' ,& '   sec2days 1.5d                                                                ' ,& '   1-12:00:00                                                                   ' ,& '                                                                                ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","url":"proc/help_usage.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME sec2days ( 1 f ) - [ TIME ] Convert durations of time to string of form dd - hh : mm : ss ( LICENSE : PD ) SYNOPSIS sec2days nnnn[.xxx] [ -crop]| --version| --help DESCRIPTION Given a numeric string representing seconds or labeled units of time\nconvert it to a string of the form\n\n   dd-hh:mm:ss\n\nwhere dd is days, hh hours, mm minutes and ss seconds. OPTIONS nnnn [. xxx ] Defaults to number of seconds to convert to string of form dd - hh : mm : ss . nnnn may be interspersed with unit codes d , h , m , s . Spaces , commas and case are ignored . Allowed aliases for the unit codes are d days and day h hours , hour , hrs , and hr m minutes , minute and min s seconds , second and sec - crop trim leading zero values from output - radix character used as decimal separator -- help display this help and exit -- version output version information and exit EXAMPLES usage sec2days 129860\n1-12:04:20\nsec2days 1d2h3m4s\n1-02:03:04\nsec2days 1.0 days 2 hours 3 minutes 4 seconds\n1-02:03:04\nsec2days 1.5d\n1-12:00:00 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        sec2days(1f)>' ,& '@(#)DESCRIPTION:    convert seconds to string of form dd-hh:mm:ss>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds                ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& ' Forms:                                                                         ' ,& '                                                                                ' ,& '    days2sec dd-hh:mm:ss                                                        ' ,& '    days2sec NNdNNhNNmNNs                                                       ' ,& '    days2sec --version| --help                                                  ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss where dd is days, hh hours,         ' ,& '   mm minutes and ss seconds convert it to seconds. Many utilities (ps(1),      ' ,& '   for example) show times in this format to make it more intelligible;         ' ,& '   but it generally easier to perform math on values represented in             ' ,& '   seconds.                                                                     ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   dd-hh:mm:ss  Given a string representing a duration of time in the           ' ,& '                following forms:                                                ' ,& '                                                                                ' ,& '                  dd-hh:mm:ss                                                   ' ,& '                     hh:mm:ss                                                   ' ,& '                        mm:ss                                                   ' ,& '                           ss                                                   ' ,& '                                                                                ' ,& '                convert it to seconds.                                          ' ,& '                                                                                ' ,& '                The numeric values may represent floating point numbers.        ' ,& '                                                                                ' ,& '                Spaces are ignored.                                             ' ,& '                                                                                ' ,& '    NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes;    ' ,& '                  where s,m,h, or d represents seconds, minutes, hours          ' ,& '                  or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are' ,& '                                                                                ' ,& '                   w -  weeks,week,wk,wks                                       ' ,& '                   d -  days,day                                                ' ,& '                   m -  minutes,minute,min                                      ' ,& '                   h -  hours,hour,hrs,hr                                       ' ,& '                   s -  seconds,second,sec,secs                                 ' ,& '                                                                                ' ,& '                  The numeric values may represent floating point numbers.      ' ,& '                                                                                ' ,& '                  Spaces, commas  and case are ignored.                         ' ,& '                                                                                ' ,& '   --denominator  divide the result by this value. Default is one(1).           ' ,& '   --help         display this help and exit                                    ' ,& '   --version      output version information and exit                           ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '  Usage                                                                         ' ,& '                                                                                ' ,& '    days2sec 1-12:04:20                                                         ' ,& '    129860                                                                      ' ,& '    days2sec 1.5 days                                                           ' ,& '    129600                                                                      ' ,& '    days2sec 1.5 days 4hrs 30minutes                                            ' ,& '    145800                                                                      ' ,& '    days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED                    ' ,& '    30                                                                          ' ,& '    days2sec 1 1 1  # SPACES ARE IGNORED                                        ' ,& '    111                                                                         ' ,& 'SEE ALSO                                                                        ' ,& '    sec2days(1)                                                                 ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","url":"proc/help_usage~2.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME days2sec(1f) - [ TIME ] Convert [[ - ] dd - ][[ hh: ] mm: ] ss to seconds (LICENSE:PD) SYNOPSIS Forms: days2sec dd-hh:mm:ss\n days2sec NNdNNhNNmNNs\n days2sec --version| --help DESCRIPTION Given a duration in the form dd-hh : mm : ss where dd is days , hh hours , mm minutes and ss seconds convert it to seconds . Many utilities ( ps ( 1 ), for example ) show times in this format to make it more intelligible ; but it generally easier to perform math on values represented in seconds . OPTIONS dd - hh : mm : ss Given a string representing a duration of time in the following forms : dd - hh : mm : ss hh : mm : ss mm : ss ss convert it to seconds . The numeric values may represent floating point numbers . Spaces are ignored . NNdNNhNNmNNs Simple numeric values may also be used with unit suffixes ; where s , m , h , or d represents seconds , minutes , hours or days and w represents weeks . Allowed aliases for w , d , h , m , and s units are w - weeks , week , wk , wks d - days , day m - minutes , minute , min h - hours , hour , hrs , hr s - seconds , second , sec , secs The numeric values may represent floating point numbers . Spaces , commas and case are ignored . -- denominator divide the result by this value . Default is one ( 1 ). -- help display this help and exit -- version output version information and exit EXAMPLES Usage days2sec 1-12:04:20\n 129860\n days2sec 1.5 days\n 129600\n days2sec 1.5 days 4hrs 30minutes\n 145800\n days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED\n 30\n days2sec 1 1 1  # SPACES ARE IGNORED\n 111 SEE ALSO sec2days(1) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        days2sec(1f)>' ,& '@(#)DESCRIPTION:    convert dd-hh:mm:ss string to seconds>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version~2.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '       today(1f) - [TIME] output current time for uses such as file suffixes.   ' ,& '       (LICENSE:PD)                                                             ' ,& 'SYNOPSIS                                                                        ' ,& '       today format|--help|--version|--test                                     ' ,& 'DESCRIPTION                                                                     ' ,& '       Outputs the current date using the specified format. Typically used      ' ,& '       to generate a string to be used in building filenames containing         ' ,& '       date information.                                                        ' ,& 'OPTIONS                                                                         ' ,& '       format     any allowable format for the fmtdate(3) routine.              ' ,& '                  defaults to \"Y-M-D\".                                          ' ,& '       --help     display this help and exit                                    ' ,& '       --version  output version information and exit                           ' ,& '       --test     display allowed options for building a format                 ' ,& 'EXAMPLES                                                                        ' ,& '       Sample commands:                                                         ' ,& '                                                                                ' ,& '        $today                                                                  ' ,& '        2024-05-27                                                              ' ,& '                                                                                ' ,& '        $mv -v myfile myfile.`today`                                            ' ,& '        renamed ''myfile'' -> ''myfile.2024-05-27''                             ' ,& '                                                                                ' ,& '        $find . -ls > MANIFEST.`today epoch`; ls MANIFEST.*                     ' ,& '        MANIFEST.1716840303                                                     ' ,& '                                                                                ' ,& '        $mkdir `today YMDhms`                                                   ' ,& '        20240527160333                                                          ' ,& '                                                                                ' ,& '        $today yearmonthdayhourminutesecond                                     ' ,& '        20240527160442                                                          ' ,& '                                                                                ' ,& '        $today --test                          # show formatting options        ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","url":"proc/help_usage~3.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME today ( 1 f ) - [ TIME ] output current time for uses such as file suffixes . ( LICENSE : PD ) SYNOPSIS today format|--help|--version|--test DESCRIPTION Outputs the current date using the specified format. Typically used\n    to generate a string to be used in building filenames containing\n    date information. OPTIONS format any allowable format for the fmtdate ( 3 ) routine . defaults to \"Y-M-D\" . -- help display this help and exit -- version output version information and exit -- test display allowed options for building a format EXAMPLES Sample commands : $today 2024 - 05 - 27 $mv - v myfile myfile . `today` renamed 'myfile' -> 'myfile.2024-05-27' $find . - ls > MANIFEST . `today epoch` ; ls MANIFEST . * MANIFEST .1716840303 $mkdir `today YMDhms` 20240527160333 $today yearmonthdayhourminutesecond 20240527160442 $today -- test # show formatting options AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        today(1f)>' ,& '@(#)DESCRIPTION:    output current time for uses such as file suffixes.>' ,& '@(#)VERSION:        1.0, 2009, 1.0.1 2024>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version~3.html"},{"title":"main – M_time","text":"subroutine main() Uses M_time M_kracken95 Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: options Source Code subroutine main () use M_time , only : now , fmtdate_usage , locale use M_kracken95 , only : kracken , lget , sget ! add command-line parser module ! ident_1=\"@(#) today(1f) output current time for uses such as file suffixes.\" character ( len = :), allocatable :: options call locale ( 'LANGUAGE' ) call kracken ( 'today' , '-help .F. -version .F. -test .F.' ) ! define command arguments,default values and crack command line call help_usage ( lget ( 'today_help' )) ! if -help option is present, display help text and exit call help_version ( lget ( 'today_version' )) ! if -version option is present, display version text and exit if ( lget ( 'today_test' )) then ! special option to list date format documentation call fmtdate_usage () ! see all formatting options else options = sget ( 'today_oo' ) ! get -oo STRING if ( options == '' ) options = 'Y-M-D' ! if options are blank set a default write ( * , '(a)' ) now ( options ) ! display current date using format from command line endif end subroutine main","tags":"","url":"proc/main.html"},{"title":"pr – M_time","text":"subroutine pr(left, right) Arguments Type Intent Optional Attributes Name type(BAStime), intent(in) :: left type(BAStime), intent(in) :: right Source Code subroutine pr ( left , right ) type ( BAStime ), intent ( in ) :: left , right write ( * , g ) 'eq' , left . eq . right , & 'gt' , left . gt . right , & 'lt' , left . lt . right , & 'ge' , left . ge . right , & 'le' , left . le . right , & 'ne' , left . ne . right end subroutine pr","tags":"","url":"proc/pr.html"},{"title":"mine – M_time","text":"subroutine mine() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ierr character(len=*), public, parameter :: months (12) = [character(len=9)::'JANUARY', 'FEBRUARY', 'MARCH    ', 'APRIL  ', 'MAY     ', 'JUNE    ', 'JULY   ', 'AUGUST  ', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'] character(len=3), public, parameter :: short_months (12) = months(:)(1:3) character(len=3), public, parameter :: short_weekdays (7) = weekdays(:)(1:3) character(len=*), public, parameter :: weekdays (7) = [character(len=9)::'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'] Source Code subroutine mine () character ( len =* ), parameter :: months ( 12 ) = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH    ' , 'APRIL  ' , 'MAY     ' , 'JUNE    ' , & & 'JULY   ' , 'AUGUST  ' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] character ( len =* ), parameter :: weekdays ( 7 ) = [ character ( len = 9 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , 'SATURDAY' , 'SUNDAY' ] character ( len = 3 ), parameter :: short_months ( 12 ) = months (:)( 1 : 3 ) character ( len = 3 ), parameter :: short_weekdays ( 7 ) = weekdays (:)( 1 : 3 ) integer :: ierr call locale ( 'user' , months , short_months , weekdays , short_weekdays , ierr ) end subroutine mine","tags":"","url":"proc/mine.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   paws(1f) - [TIME] pause until specified time or for specified duration       ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   paws [dd-hh:mm:ss[.xxx]|xxx.yyy[s|m|h|d]][ -msg message][ -cmd command][ -repeat TIMES[ -fmt ]]|...' ,& '   [ -uet|-jd|-dat|[ -date|-until]]                                             ' ,& '   paws --version|--help                                                        ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss.xxx where dd is days, hh hours,     ' ,& '   mm minutes and ss.xxx seconds convert it to seconds. Then, pause for that    ' ,& '   many seconds. Alternatively, pause until specified date has passed.          ' ,& '   If no duration is specified wait until a carriage return is entered.         ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   dd-hh:mm:ss   Given a string representing a duration of time in the          ' ,& '                 following forms:                                               ' ,& '                                                                                ' ,& '                   dd-hh:mm:ss[.xx]                                             ' ,& '                      hh:mm:ss[.xx]                                             ' ,& '                         mm:ss[.xx]                                             ' ,& '                            ss[.xx]                                             ' ,& '                      or                                                        ' ,& '                   xx[.yy]SUFFIX                                                ' ,& '                                                                                ' ,& '                 convert it to seconds and pause for that amount of time.       ' ,& '                 Suffix may be s for seconds, m for minutes, h for hours,       ' ,& '                 or d for days.                                                 ' ,& '   -date|-until  wait until the specified date has passed (before starting      ' ,& '                 optional pause). See guessdate(3f) for syntax allowed for      ' ,& '                 the date.                                                      ' ,& '   -uet          wait until the specified Unix Epoch Time has passed            ' ,& '   -jd           wait until the specified Julian Date has passed                ' ,& '   -dat          wait until the specified date vector has passed                ' ,& '                 (year month day timezone hour minutes seconds milliseconds)    ' ,& '   -repeat NNN   The duration is repeated NNN times with the date displayed     ' ,& '                 at the end of each pause.                                      ' ,& '   --msg         message to display before pausing                              ' ,& '   --cmd         command to execute after a pause                               ' ,& '   --fmt         date format (see fmtdate(3f) for details)                      ' ,& '   --help        display this help and exit                                     ' ,& '   --version     output version information and exit                            ' ,& '                                                                                ' ,& '   For more information on the format of the dates, see the now(1) command.     ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& ' Typical usage:                                                                 ' ,& '                                                                                ' ,& '  paws 2:00:00              # pause for two hours                               ' ,& '  paws 3600                 # pause one hour                                    ' ,& '  paws 0.10                 # pause one tenth of a second                       ' ,& '  paws 1 -repeat 60         # pause sixty seconds, displaying date each second  ' ,& '  paws -until 23:59:59      # pause until midnight                              ' ,& '  paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes  ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","url":"proc/help_usage~4.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME paws ( 1 f ) - [ TIME ] pause until specified time or for specified duration ( LICENSE : PD ) SYNOPSIS paws [ dd - hh : mm : ss [. xxx ] | xxx . yyy [ s | m | h | d ]][ - msg message ][ - cmd command ][ - repeat TIMES [ - fmt ]] | ...\n[ - uet |- jd |- dat | [ - date |- until ]] paws -- version |-- help DESCRIPTION Given a duration in the form dd - hh : mm : ss . xxx where dd is days , hh hours , mm minutes and ss . xxx seconds convert it to seconds . Then , pause for that many seconds . Alternatively , pause until specified date has passed . If no duration is specified wait until a carriage return is entered . OPTIONS dd-hh:mm:ss Given a string representing a duration of time in the following forms: dd-hh:mm:ss [. xx ] hh:mm:ss [. xx ] mm : ss [. xx ] ss [. xx ] or xx [. yy ] SUFFIX convert it to seconds and pause for that amount of time . Suffix may be s for seconds , m for minutes , h for hours , or d for days .\n- date |- until wait until the specified date has passed ( before starting optional pause ). See guessdate ( 3 f ) for syntax allowed for the date .\n- uet wait until the specified Unix Epoch Time has passed - jd wait until the specified Julian Date has passed - dat wait until the specified date vector has passed ( year month day timezone hour minutes seconds milliseconds )\n- repeat NNN The duration is repeated NNN times with the date displayed at the end of each pause .\n-- msg message to display before pausing -- cmd command to execute after a pause -- fmt date format ( see fmtdate ( 3 f ) for details )\n-- help display this help and exit -- version output version information and exit For more information on the format of the dates , see the now ( 1 ) command . EXAMPLES Typical usage: paws 2:00:00              # pause for two hours\n   paws 3600                 # pause one hour\n   paws 0.10                 # pause one tenth of a second\n   paws 1 -repeat 60         # pause sixty seconds, displaying date each second\n   paws -until 23:59:59      # pause until midnight\n   paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        paws(1f)>' ,& '@(#)DESCRIPTION:    pause until specified time or for specified duration>' ,& '@(#)VERSION:        1.0, 20160731>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version~4.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        now(1f)>' ,& '@(#)DESCRIPTION:    Report a date in a variety of formats>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version~5.html"},{"title":"usage – M_time","text":"subroutine usage() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i character(len=*), public, parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character(len=80), public, allocatable :: text (:) Source Code subroutine usage () ! character ( len =* ), parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character ( len = 80 ), allocatable :: text (:) integer :: i ! NOTE: Without the type specification this constructor would have to specify all of the constants with the same character length. text = [ character ( len = len ( text ( 1 ))) :: & & 'NAME                                                                            ' ,& & '   now(1f)  - [TIME] print the date and time                                    ' ,& & '   (LICENSE:PD)                                                                 ' ,& & '                                                                                ' ,& & 'SYNOPSIS                                                                        ' ,& & '  now [Format [ -date date_str|-ued Unix_time|-jd Julian_Date|-dat date_vector] ' ,& & '      [ -delta dd-hh:mm:ss]]|--help |--version|-test]                           ' ,& & '                                                                                ' ,& & 'DESCRIPTION                                                                     ' ,& & '   Report the current time or a Fortran date vector in a variety of formats.    ' ,& & '   Julian dates, Unix Epoch time, weekdays, monthnames, ordinal days,           ' ,& & '   AM/PM and iso-8601 week-numbering are supported by building a format         ' ,& & '   string containing the desired macros.                                        ' ,& & 'OPTIONS                                                                         ' ,& & '   Format  :                                                                    ' ,& & '     This string, containing macro names or keywords, creates the format used   ' ,& & '     to print the specified date.                                               ' ,& & '                                                                                ' ,& & '     The FORMAT string is expanded using the following macros:                  ' ,& & '                                                                                ' ,& & 'CALL FMTDATE_USAGE                                                              ' ,& & '                                                                                ' ,& & '   -dat date_vector  :                                                          ' ,& & '      A date vector is eight integers representing a date in the same manner as ' ,& & '      the Fortran DATE_AND_TIME(3f) function:                                   ' ,& & '          yyyy mm dd zone hh mm ss mss                                          ' ,& & '      only numeric time zones are supported.                                    ' ,& & '                                                                                ' ,& & '      When present, the specified date is used instead of the current time.     ' ,& & '                                                                                ' ,& & '   -uet Unix_Epoch_Time  :                                                      ' ,& & '      When present a value is used as the Unix Epoch Time. This date is         ' ,& & '      is then adjusted using any -delta value and then printed using            ' ,& & '      the specified format.                                                     ' ,& & '                                                                                ' ,& & '   -jd Julian_Date  :                                                           ' ,& & '      When present a value is used as the Julian Date.                          ' ,& & '                                                                                ' ,& & '   -delta dd-hh:mm:ss  :                                                        ' ,& & '      Add the specified duration to the date.                                   ' ,& & '                                                                                ' ,& & '   -date date_str  :                                                            ' ,& & '      The guessdate(3f) routine is used to try to convert a date description    ' ,& & '      to a date vector. For the guess to work, dates must either be in the      ' ,& & '      form YYYY-MM-DD or the order of numeric values must be \"\"dd yy yyy\".      ' ,& & '      Only four-digit years are supported. Month names are preferred over       ' ,& & '      numeric values. See the guessdate(3f) documentation for further details.  ' ,& & '                                                                                ' ,& & '   -test :                                                                      ' ,& & '      To list allowed macros use the -test switch.                              ' ,& & '                                                                                ' ,& & '   When present, the specified date is used instead of the current time.        ' ,& & 'EXAMPLES                                                                        ' ,& & ' Sample commands:                                                               ' ,& & '                                                                                ' ,& & '  now                                                                           ' ,& & '    Friday, June 17th, 2016 03:22:53 PM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta  1-0:0:0  # Tomorrow                                               ' ,& & '    Sunday, June 19th, 2016 11:32:26 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta -1-0:0:0  # Yesterday                                              ' ,& & '    Friday, June 17th, 2016 11:32:43 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now long -delta  7-0:0:0  # Next week                                         ' ,& & '    Saturday, June 25th, 2016 11:32:57 AM UTC-04:00                             ' ,& & '                                                                                ' ,& & '  now The date is %Y/%M/%D %h:%m:%s  # user-specified formats using macros      ' ,& & '    The date is 2009/08/10 00:33:48                                             ' ,& & '                                                                                ' ,& & '  now Y/M/D h:m:s # user-specified format with no % character                   ' ,& & '    2009/08/10 00:33:48                                                         ' ,& & '                                                                                ' ,& & '  now year-month-day # user-specified format with no % with long keywords       ' ,& & '  2016-07-29                                                                    ' ,& & '                                                                                ' ,& & '  now -dat 2016 07 23 -240 1 01 00 00  # alternate date                         ' ,& & '  Saturday, July 23rd, 2016 1:01:00 AM UTC-4:00                                 ' ,& & '                                                                                ' ,& & '  now -uet  1469250060                 # alternate Unix Epoch date              ' ,& & '  now -date January 4th, 1999 10:20:30 # try to determine date from description.' ,& & '                                                                                ' ,& & '  now YEAR=%Y MONTH=%M DAY=%D          # YEAR=2009 MONTH=08 DAY=10              ' ,& & '                                                                                ' ,& & '  now HOUR=%h MINUTES=%m SECONDS=%s MILLISECONDS=%x                             ' ,& & '      HOUR=01 MINUTES=18 SECONDS=44 MILLISECONDS=946                            ' ,& & '                                                                                ' ,& & '  # double-quotes are tricky (double them) to put in literally in this program: ' ,& & '  now ''\"\"year-month-day\"\",\"\"hour-minute-second\"\"'' #  \"2017-04-23\",\"14-41-09\"  ' ,& & '                                                                                ' ,& & '  # quotes are easier to control using the single-letter macros(use %q and %Q): ' ,& & '  now QY-M-DQ,Qh:m:sQ                                                           ' ,& & '     \"2017-04-23\",\"14-41-09\"                                                    ' ,& & '                                                                                ' ,& & '  now -test       # Show formatting options, handy way to look up macro names   ' ,& & '                                                                                ' ,& & 'LIMITS                                                                          ' ,& & '  See the M_time module description. Basically, A Gregorian Calendar is         ' ,& & '  assumed, and Leap Seconds are not specifically accounted for.                 ' ,& & 'SEE ALSO                                                                        ' ,& & '   month(1), sec2days(1), days2sec(1), easter(1), paws(1), today(1), ttee(1)    ' ,& & 'AUTHOR                                                                          ' ,& & '   John S. Urban                                                                ' ,& & 'LICENSE                                                                         ' ,& & '   Public Domain                                                                ' ,& & '                                                                                ' ] do i = 1 , size ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 6 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo stop end subroutine usage","tags":"","url":"proc/usage.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        ttee(1f)>' ,& '@(#)DESCRIPTION:    split stdout to a file with optional timestamp labeling>' ,& '@(#)VERSION:        1.0, 2015-09-13>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version~6.html"},{"title":"stderr – M_time","text":"subroutine stderr(msg) Uses iso_fortran_env Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Variables Type Visibility Attributes Name Initial integer, public :: iostat Source Code subroutine stderr ( msg ) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT implicit none ! @(#) M_verify stderr(3f) writes a message to standard error character ( len =* ), intent ( in ) :: msg integer :: iostat write ( error_unit , '(a)' , iostat = iostat ) trim ( msg ) flush ( unit = output_unit , iostat = iostat ) flush ( unit = error_unit , iostat = iostat ) end subroutine stderr","tags":"","url":"proc/stderr.html"},{"title":"usage – M_time","text":"subroutine usage() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i character(len=132), public, allocatable :: text (:) Source Code subroutine usage () ! \"@(#) usage(3f90) writes program help to stdout and exits !character(len=132),parameter :: text(:)= [& character ( len = 132 ), allocatable :: text (:) integer :: i text = [& & 'NAME                                                                            ' , & & '   ttee(1f) - [TIME] write input to stdout and a file with timing info.         ' , & & '   (LICENSE:PD)                                                                 ' , & & '                                                                                ' , & & 'SYNOPSIS                                                                        ' , & & '   ttee [[ -o|--output] filename(s)] [ -a|--append] [ --timestamp FLAG]] ...    ' , & & '        [ -fmt FORMAT] [ --help | --version]                                    ' , & & '                                                                                ' , & & 'DESCRIPTION                                                                     ' , & & '   Read from standard input and write to standard output and files              ' , & & '   with an optional timestamp in front of each line.                            ' , & & '                                                                                ' , & & '   -o|--output FILENAME(S)                                                      ' , & & '         specify name of output file(s). If the filenames are first the         ' , & & '         keyword -o|--output is optional.                                       ' , & & '                                                                                ' , & & '   -a|--append                                                                  ' , & & '         append to the given output file(s), do not overwrite                   ' , & & '                                                                                ' , & & '   -t|--timestamp FLAG                                                          ' , & & '         which files to add the timestamp to. Default is \"all\"                  ' , & & '         Allowed values are stdout, output, all, none.                          ' , & & '                                                                                ' , & & '   -fmt FORMAT                                                                  ' , & & '         Change format for timestamp prefix using a call to now(3f).            ' , & & '                                                                                ' , & & 'CALL FMTDATE_USAGE                                                              ' , & & '   --help     display this help and exit                                        ' , & & '   --version  output version information and exit                               ' , & & 'LIMITS                                                                          ' , & & '    Program limits:                                                             ' , & & '                                                                                ' , & & '    o  Input line width maximum is 1024 characters.                             ' , & & '    o  Maximum length of output filenames is 4098, individual filename is 1024. ' , & & '    o  Minimum number of output files is probably at least 90; but is           ' , & & '       system dependent.                                                        ' , & & '                                                                                ' , & & 'EXAMPLES                                                                        ' , & & '   Basic command usage:                                                         ' , & & '                                                                                ' , & & '    # write stdout of \"program\" to ttee.out with a timestamp and stdout         ' , & & '    program|ttee --output ttee.out --timestamp output|grep -i iteration         ' , & & '                                                                                ' , & & '    # write stdout of \"program\" to log.txt and stdout with a Julian Day         ' , & & '    program|ttee log.txt -fmt \"%J :\"                                            ' , & & '    2457565.488 :Iteration 1 : Error: 1.20                                      ' , & & '    2457565.558 :Iteration 2 : Error: 0.08                                      ' , & & '    2467569.684 :Iteration 3 : Error: 1.2e-3                                    ' , & & 'AUTHOR                                                                          ' , & & '  John S. Urban                                                                 ' , & & 'LICENSE                                                                         ' , & & '  Public Domain                                                                 ' , & & '                                                                                ' ] do i = 1 , SIZE ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 10 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo end subroutine usage","tags":"","url":"proc/usage~2.html"},{"title":"str2arr – M_time","text":"pure function str2arr(string) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=c_char, len=1), (len(string)+1) Variables Type Visibility Attributes Name Initial integer, public :: i Source Code pure function str2arr ( string ) result ( array ) ! ident_34=\"@(#)M_system::str2arr(3fp): function copies string to null terminated char array\" character ( len =* ), intent ( in ) :: string character ( len = 1 , kind = c_char ) :: array ( len ( string ) + 1 ) integer :: i do i = 1 , len_trim ( string ) array ( i ) = string ( i : i ) enddo array ( size ( array )) = c_null_char end function str2arr","tags":"","url":"proc/str2arr.html"},{"title":"put_environment_variable – M_time","text":"subroutine put_environment_variable(NAME, VALUE, STATUS) Arguments Type Intent Optional Attributes Name character(len=*) :: NAME character(len=*) :: VALUE integer, intent(out), optional :: STATUS Variables Type Visibility Attributes Name Initial integer, public :: loc_err character(kind=c_char, len=1), public, allocatable :: temp_chars1 (:) character(kind=c_char, len=1), public, allocatable :: temp_chars2 (:) Interfaces interface function c_setenv(c_name, c_VALUE) bind(C,NAME=\"setenv\") Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1) :: c_name (*) character(kind=c_char, len=1) :: c_VALUE (*) Return Value integer(kind=c_int) Source Code subroutine put_environment_variable ( name , value , status ) !  This is an private copy of the set_environment_variable routine(3f) routine from !  M_system.FF that is duplicated in order to prevent a circular dependency. ! ident_33=\"@(#)M_system::put_environment_variable(3f): call setenv(3c) to set environment variable\" character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS integer :: loc_err character ( kind = c_char , len = 1 ), allocatable :: temp_chars1 (:) character ( kind = c_char , len = 1 ), allocatable :: temp_chars2 (:) interface integer ( kind = c_int ) function c_setenv ( c_name , c_VALUE ) bind ( C , NAME = \"setenv\" ) import c_int , c_char character ( kind = c_char ) :: c_name ( * ) character ( kind = c_char ) :: c_VALUE ( * ) end function end interface temp_chars1 = str2arr ( trim ( NAME )) temp_chars2 = str2arr ( VALUE ) loc_err = c_setenv ( temp_chars1 , temp_chars2 ) if ( present ( STATUS )) STATUS = loc_err end subroutine put_environment_variable","tags":"","url":"proc/put_environment_variable.html"},{"title":"showme – M_time","text":"subroutine showme(string) Arguments Type Intent Optional Attributes Name character(len=*) :: string Variables Type Visibility Attributes Name Initial integer, public :: iweek integer, public :: iweekday integer, public :: iyear character(len=10), public :: name Source Code subroutine showme ( string ) character ( len =* ) :: string integer :: iyear , iweek , iweekday character ( len = 10 ) :: name call d2w ( dat , iyear , iweek , iweekday , name ) call unit_test ( 'd2w' , name == string , iyear , iweek , iweekday , name , string ) end subroutine showme","tags":"","url":"proc/showme.html"},{"title":"test_b2d – M_time","text":"subroutine test_b2d() Arguments None Variables Type Visibility Attributes Name Initial type(BAStime), public :: bas integer, public :: dat (8) character(len=:), public, allocatable :: expected real(kind=realtime), public :: mjd character(len=:), public, allocatable :: resulted Source Code subroutine test_b2d type ( BAStime ) :: bas real ( kind = realtime ) :: mjd character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) mjd = 245758 9.129d0 - 240000 0.5_realtime ! set sample Modified Julian Date bas = BAStime ( int ( mjd ), mod ( mjd , 1.0d0 ) * 8640 0.0_realtime ) expected = '2016-07-19 11:05:45' dat = b2d ( bas ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = b2d ( bas - 8640 0.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd - 1.0 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = b2d ( bas + 8640 0.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd + 1.0 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'b2d' ) end subroutine test_b2d","tags":"","url":"proc/test_b2d.html"},{"title":"test_bas_to_date – M_time","text":"subroutine test_bas_to_date() Arguments None Variables Type Visibility Attributes Name Initial type(BAStime), public :: bas real(kind=realtime), public, parameter :: conv = 2400000.5_realtime integer, public :: dat (8) character(len=:), public, allocatable :: expected integer, public :: ierr real(kind=realtime), public :: mjd Source Code subroutine test_bas_to_date () type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime mjd = 245758 9.129d0 - conv ! set sample Modified Julian Date bas = BAStime ( int ( mjd ), mod ( mjd , 1.0d0 ) * 8640 0.0_realtime ) call bas_to_date ( bas , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call bas_to_date ( bas - 8640 0.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call bas_to_date ( bas + 8640 0.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'bas_to_date' ) end subroutine test_bas_to_date","tags":"","url":"proc/test_bas_to_date.html"},{"title":"test_box_month – M_time","text":"subroutine test_box_month() Arguments None Variables Type Visibility Attributes Name Initial character(len=21), public :: calendar (8) integer, public :: dat (8) character(len=21), public :: mnth (8) Source Code subroutine test_box_month integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) character ( len = 21 ) :: mnth ( 8 ) dat = [ 2016 , 07 , 01 , - 240 , 12 , 0 , 0 , 0 ] mnth = [ & '      July 2016      ' , & 'Mo Tu We Th Fr Sa Su ' , & '             1  2  3 ' , & ' 4  5  6  7  8  9 10 ' , & '11 12 13 14 15 16 17 ' , & '18 19 20 21 22 23 24 ' , & '25 26 27 28 29 30 31 ' , & '                     ' ] call box_month ( dat , calendar ) if ( unit_test_level > 0 ) then write ( * , '(a)' ) calendar write ( * , '(a)' ) mnth endif call unit_test ( 'box_month' , all ( calendar == mnth ), 'July 2016' ) call unit_test_end ( 'box_month' ) end subroutine test_box_month","tags":"","url":"proc/test_box_month.html"},{"title":"test_d2b – M_time","text":"subroutine test_d2b() Arguments None Variables Type Visibility Attributes Name Initial integer, public, parameter :: array (1:12,2000:2009) = reshape([51543, 51909, 52274, 52639, 53004, 53370, 53735, 54100, 54465, 54831, 51574, 51940, 52305, 52670, 53035, 53401, 53766, 54131, 54496, 54862, 51603, 51968, 52333, 52698, 53064, 53429, 53794, 54159, 54525, 54890, 51634, 51999, 52364, 52729, 53095, 53460, 53825, 54190, 54556, 54921, 51664, 52029, 52394, 52759, 53125, 53490, 53855, 54220, 54586, 54951, 51695, 52060, 52425, 52790, 53156, 53521, 53886, 54251, 54617, 54982, 51725, 52090, 52455, 52820, 53186, 53551, 53916, 54281, 54647, 55012, 51756, 52121, 52486, 52851, 53217, 53582, 53947, 54312, 54678, 55043, 51787, 52152, 52517, 52882, 53248, 53613, 53978, 54343, 54709, 55074, 51817, 52182, 52547, 52912, 53278, 53643, 54008, 54373, 54739, 55104, 51848, 52213, 52578, 52943, 53309, 53674, 54039, 54404, 54770, 55135, 51878, 52243, 52608, 52973, 53339, 53704, 54069, 54434, 54800, 55165], shape=shape(array), order=[2, 1]) type(BAStime), public :: bas real(kind=realtime), public, parameter :: conv = 2400000.5_realtime integer, public :: dat (8) real(kind=realtime), public :: mjd integer, public :: month integer, public :: year Source Code subroutine test_d2b type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime !                            Modified Julian Dates ! !   To use this table, add the day-of-month to the tabulated entry. !   For example, 30 Jan 2000 = MJD 51573. ! __________________________________________________________________ !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009 integer , parameter :: array ( 1 : 12 , 2000 : 2009 ) = reshape ([ & 51543 , 51909 , 52274 , 52639 , 53004 , 53370 , 53735 , 54100 , 54465 , 54831 , & ! Jan 51574 , 51940 , 52305 , 52670 , 53035 , 53401 , 53766 , 54131 , 54496 , 54862 , & ! Feb 51603 , 51968 , 52333 , 52698 , 53064 , 53429 , 53794 , 54159 , 54525 , 54890 , & ! Mar 51634 , 51999 , 52364 , 52729 , 53095 , 53460 , 53825 , 54190 , 54556 , 54921 , & ! Apr 51664 , 52029 , 52394 , 52759 , 53125 , 53490 , 53855 , 54220 , 54586 , 54951 , & ! May 51695 , 52060 , 52425 , 52790 , 53156 , 53521 , 53886 , 54251 , 54617 , 54982 , & ! Jun 51725 , 52090 , 52455 , 52820 , 53186 , 53551 , 53916 , 54281 , 54647 , 55012 , & ! Jul 51756 , 52121 , 52486 , 52851 , 53217 , 53582 , 53947 , 54312 , 54678 , 55043 , & ! Aug 51787 , 52152 , 52517 , 52882 , 53248 , 53613 , 53978 , 54343 , 54709 , 55074 , & ! Sep 51817 , 52182 , 52547 , 52912 , 53278 , 53643 , 54008 , 54373 , 54739 , 55104 , & ! Oct 51848 , 52213 , 52578 , 52943 , 53309 , 53674 , 54039 , 54404 , 54770 , 55135 , & ! Nov 51878 , 52243 , 52608 , 52973 , 53339 , 53704 , 54069 , 54434 , 54800 , 55165 ],& ! Dec shape = shape ( array ), order = [ 2 , 1 ]) integer :: month , year dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2449719 , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450010 , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450083 , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450084 , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450449 , msg = \"Dec 31th, 1996 12:00\" ) do month = 1 , 12 do year = 2000 , 2009 !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds] dat = [ year , month , 1 , 0 , 0 , 0 , 0 , 0 ] bas = d2b ( dat ) call unit_test ( 'd2b' , array ( month , year ) + 1 == bas % base_day , year , month , array ( month , year ) + 1 , bas % base_day ) enddo enddo call unit_test_end ( 'd2b' ) end subroutine test_d2b","tags":"","url":"proc/test_d2b.html"},{"title":"test_d2j – M_time","text":"subroutine test_d2j() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) real(kind=realtime), public :: julian Source Code subroutine test_d2j real ( kind = realtime ) :: julian integer :: dat ( 8 ) dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , abs ( julian - 244058 7.5d0 ) < 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_test_end ( 'd2j' ) end subroutine test_d2j","tags":"","url":"proc/test_d2j.html"},{"title":"test_d2m – M_time","text":"subroutine test_d2m() Arguments None Variables Type Visibility Attributes Name Initial real(kind=realtime), public, parameter :: conv = 2400000.5_realtime integer, public :: dat (8) real(kind=realtime), public :: mjd Source Code subroutine test_d2m real ( kind = realtime ) :: mjd integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2449719 - conv ) , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450010 - conv ), msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450083 - conv ), msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450084 - conv ), msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450449 - conv ), msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'd2m' ) end subroutine test_d2m","tags":"","url":"proc/test_d2m.html"},{"title":"test_d2o – M_time","text":"subroutine test_d2o() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) integer, public :: i integer, public :: iday integer, public :: iyear integer, public :: oday integer, public :: omonth integer, public :: rday character(len=40), public :: readme character(len=40), public, parameter :: tests (*) = ['ordinal  year  month  month_day  ', '100      2004  4      9          ', '100      2005  4      10         ', '100      2006  4      10         ', '100      2007  4      10         ', '100      2008  4      9          ', '100      2016  4      9          '] Source Code subroutine test_d2o () integer :: iday , iyear , omonth , oday , rday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) rday = d2o ( dat ) call unit_test ( 'd2o' , iday == rday , msg = tests ( i )) enddo call unit_test_end ( 'd2o' ) end subroutine test_d2o","tags":"","url":"proc/test_d2o.html"},{"title":"test_d2u – M_time","text":"subroutine test_d2u() Arguments None Variables Type Visibility Attributes Name Initial integer, public, parameter :: aday (*) = [2017, 03, 29, -240, 01, 46, 47, 0] Source Code subroutine test_d2u () integer , parameter :: aday ( * ) = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] !  Note that time zones are usually -HHMM or -HH:MM and not MM, which is what the DAT array uses !  Comparing to Unix date(1) command: !    date --date \"Wed Mar 29 01:46:47 EDT 2017\" +%s      ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 2017\" +%s          ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 -400 2017\" +%s     ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-400 2017\" +%s  ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-4:00 2017\" +%s ! 1490766407 ! nint() changed to int(anint() to avoid gfortran OpenBSD bug on i386 call unit_test ( 'd2u' , int ( anint ( d2u ( aday ))) == 1490766407 , d2u ( aday ) ) call unit_test_end ( 'd2u' ) end subroutine test_d2u","tags":"","url":"proc/test_d2u.html"},{"title":"test_d2w – M_time","text":"subroutine test_d2w() Arguments None Source Code subroutine test_d2w () call date_and_time ( values = dat ) dat = [ 2005 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 1 Jan 2005 2005-01-01 2004-W53-6 call showme ( \"2004-W53-6\" ) dat = [ 2005 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 2 Jan 2005 2005-01-02 2004-W53-7 call showme ( \"2004-W53-7\" ) dat = [ 2005 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 31 Dec 2005 2005-12-31 2005-W52-6 call showme ( \"2005-W52-6\" ) dat = [ 2007 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 1 Jan 2007 2007-01-01 2007-W01-1 Both years 2007 start with the same day. call showme ( \"2007-W01-1\" ) dat = [ 2007 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 30 Dec 2007 2007-12-30 2007-W52-7 call showme ( \"2007-W52-7\" ) dat = [ 2007 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 31 Dec 2007 2007-12-31 2008-W01-1 call showme ( \"2008-W01-1\" ) dat = [ 2008 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 1 Jan 2008 2008-01-01 2008-W01-2 !     Gregorian year 2008 is a leap year. ... !     ISO year 2008 is 2 days shorter: 1 day longer at the start, 3 days shorter at the end. call showme ( \"2008-W01-2\" ) dat = [ 2008 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 28 Dec 2008 2008-12-28 2008-W52-7 ... !     ISO year 2009 begins three days before the end of Gregorian 2008. call showme ( \"2008-W52-7\" ) dat = [ 2008 , 12 , 29 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 29 Dec 2008 2008-12-29 2009-W01-1 call showme ( \"2009-W01-1\" ) dat = [ 2008 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 30 Dec 2008 2008-12-30 2009-W01-2 call showme ( \"2009-W01-2\" ) dat = [ 2008 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Wed 31 Dec 2008 2008-12-31 2009-W01-3 call showme ( \"2009-W01-3\" ) dat = [ 2009 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 1 Jan 2009 2009-01-01 2009-W01-4 call showme ( \"2009-W01-4\" ) dat = [ 2009 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 31 Dec 2009 2009-12-31 2009-W53-4  ... !     ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010. call showme ( \"2009-W53-4\" ) dat = [ 2010 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Fri 1 Jan 2010 2010-01-01 2009-W53-5 call showme ( \"2009-W53-5\" ) dat = [ 2010 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 2 Jan 2010 2010-01-02 2009-W53-6 call showme ( \"2009-W53-6\" ) dat = [ 2010 , 01 , 03 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 3 Jan 2010 2010-01-03 2009-W53-7 call showme ( \"2009-W53-7\" ) call unit_test_end ( 'd2w' ) ! assume if got here passed checks end subroutine test_d2w","tags":"","url":"proc/test_d2w.html"},{"title":"test_date_to_bas – M_time","text":"subroutine test_date_to_bas() Arguments None Variables Type Visibility Attributes Name Initial type(BAStime), public :: bas real(kind=realtime), public, parameter :: conv = 2400000.5_realtime integer, public :: dat (8) integer, public :: ierr real(kind=realtime), public :: mjd Source Code subroutine test_date_to_bas () type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: ierr integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2449719 , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450010 , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450083 , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450084 , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450449 , msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'date_to_bas' ) end subroutine test_date_to_bas","tags":"","url":"proc/test_date_to_bas.html"},{"title":"test_date_to_julian – M_time","text":"subroutine test_date_to_julian() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) integer, public :: ierr real(kind=realtime), public :: julian Source Code subroutine test_date_to_julian () real ( kind = realtime ) :: julian integer :: ierr integer :: dat ( 8 ) dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , abs ( julian - 244058 7.5d0 ) < 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_test_end ( 'date_to_julian' ) end subroutine test_date_to_julian","tags":"","url":"proc/test_date_to_julian.html"},{"title":"test_date_to_modified_julian – M_time","text":"subroutine test_date_to_modified_julian() Arguments None Variables Type Visibility Attributes Name Initial real(kind=realtime), public, parameter :: conv = 2400000.5_realtime integer, public :: dat (8) integer, public :: ierr real(kind=realtime), public :: mjd Source Code subroutine test_date_to_modified_julian () real ( kind = realtime ) :: mjd integer :: ierr integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , abs ( mjd - 244058 7.5d0 - conv ) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2449719 - conv , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450010 - conv , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450083 - conv , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450084 - conv , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450449 - conv , msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'date_to_modified_julian' ) end subroutine test_date_to_modified_julian","tags":"","url":"proc/test_date_to_modified_julian.html"},{"title":"test_date_to_unix – M_time","text":"subroutine test_date_to_unix() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: expected integer, public :: ierr integer, public :: in (8) real(kind=realtime), public :: unixtime Source Code subroutine test_date_to_unix real ( kind = realtime ) :: unixtime integer :: ierr integer :: in ( 8 ) integer :: expected in = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] expected = 1490766407 call date_to_unix ( in , unixtime , ierr ) call unit_test ( 'date_to_unix' , abs ( unixtime - expected ) < 0.001 , 'EXPECTED' , expected , 'RESULT' , unixtime ) call unit_test_end ( 'date_to_unix' ) end subroutine test_date_to_unix","tags":"","url":"proc/test_date_to_unix.html"},{"title":"test_days2sec – M_time","text":"subroutine test_days2sec() Arguments None Source Code subroutine test_days2sec () ! add 0 to nint function because of gfortran-11 bug passing some arguments with functions to class(*) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1' )) == 1 , 'expected' , 1 , 'got' , 0 + nint ( days2sec ( '1' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1:00' )) == 60 , 'expected' , 60 , 'got' , 0 + nint ( days2sec ( '1:00' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1:00:00' )) == 3600 , 'expected' , 3600 , 'got' , 0 + nint ( days2sec ( '1:00:00' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1-00:00:00' )) == 86400 , 'expected' , 86400 , 'got' , 0 + nint ( days2sec ( '1-00:00:00' ))) call unit_test ( 'days2sec' ,& & nint ( days2sec ( '1d2h 3.0 minutes 4sec' )) == 93784 , 'expected' , 1 , 'got' , 0 + nint ( days2sec ( '1d2h 3.0 minutes 4sec' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1-12:04:20              ' )) == 129860 , & & 'expected' , 129860 , 'got' , 0 + nint ( days2sec ( '1.12:03:20' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5 days                ' )) == 129600 , & & 'expected' , 129600 , 'got' , 0 + nint ( days2sec ( '1.5 days' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) == 145800 , & & 'expected' , 145800 , 'got' , 0 + nint ( days2sec ( '1.5 days 4hrs 30minutes' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5d                    ' )) == 129600 , & & 'expected' , 129600 , 'got' , 0 + nint ( days2sec ( '1.5d' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1d2h3m4s                ' )) == 93784 , & & 'expected' , 93784 , 'got' , 0 + nint ( days2sec ( '1d2h3m4s' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1d1d1d                  ' )) == 259200 , & & 'expected' , 259200 , 'got' , 0 + nint ( days2sec ( '1d1d1d' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 4d-12h                  ' )) == 302400 , & & 'expected' , 302400 , 'got' , 0 + nint ( days2sec ( '4d-12h' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 3  d  1 2   h           ' )) == 302400 , & & 'expected' , 302400 , 'got' , 0 + nint ( days2sec ( '3 d 1 s  h' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 3h10''20\"' )) == 11420 , & & 'expected' , 11420 , 'got' , 0 + nint ( days2sec ( '3 h 10''20\"' ))) call unit_test_end ( 'days2sec' ) end subroutine test_days2sec","tags":"","url":"proc/test_days2sec.html"},{"title":"test_dow – M_time","text":"subroutine test_dow() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) character(len=9), public :: day integer, public :: ierr integer, public :: weekday Source Code subroutine test_dow integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) dat = [ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ] call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Saturday' . and . weekday == 6 , ' expected Saturday,6 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Sunday' . and . weekday == 7 , ' expected Sunday,7 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Monday' . and . weekday == 1 , ' expected Monday,1 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Tuesday' . and . weekday == 2 , ' expected Tuesday,2 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Wednesday' . and . weekday == 3 , ' expected Wednesday,3 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Thursday' . and . weekday == 4 , ' expected Thursday,4 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Friday' . and . weekday == 5 , ' expected Friday,5 and got ' , day , weekday ) call unit_test_end ( 'dow' ) end subroutine test_dow","tags":"","url":"proc/test_dow.html"},{"title":"test_easter – M_time","text":"subroutine test_easter() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) integer, public :: ii integer, public :: inyear character(len=5), public :: mon (3:4) = (/'march', 'april'/) integer, public :: outday integer, public :: outmonth character(len=20), public :: readme integer, public :: tday character(len=20), public, parameter :: tests (*) = ['1980,4,6  ', '1981,4,19 ', '1982,4,11 ', '1983,4,3  ', '1984,4,22 ', '1985,4,7  ', '1986,3,30 ', '1987,4,19 ', '1988,4,3  ', '1989,3,26 ', '1990,4,15 ', '1991,3,31 ', '1992,4,19 ', '1993,4,11 ', '1994,4,3  ', '1995,4,16 ', '1996,4,7  ', '1997,3,30 ', '1998,4,12 ', '1999,4,4  ', '2000,4,23 ', '2001,4,15 ', '2002,3,31 ', '2003,4,20 ', '2004,4,11 ', '2005,3,27 ', '2006,4,16 ', '2007,4,8  ', '2008,3,23 ', '2009,4,12 ', '2010,4,4  ', '2011,4,24 ', '2012,4,8  ', '2013,3,31 ', '2014,4,20 ', '2015,4,5  ', '2016,3,27 ', '2017,4,16 ', '2018,4,1  ', '2019,4,21 ', '2020,4,12 ', '2021,4,4  ', '2022,4,17 ', '2023,4,9  ', '2024,3,31 '] integer, public :: tmonth Source Code subroutine test_easter () character ( len = 20 ), parameter :: tests ( * ) = [ & '1980,4,6  ' , & '1981,4,19 ' , & '1982,4,11 ' , & '1983,4,3  ' , & '1984,4,22 ' , & '1985,4,7  ' , & '1986,3,30 ' , & '1987,4,19 ' , & '1988,4,3  ' , & '1989,3,26 ' , & '1990,4,15 ' , & '1991,3,31 ' , & '1992,4,19 ' , & '1993,4,11 ' , & '1994,4,3  ' , & '1995,4,16 ' , & '1996,4,7  ' , & '1997,3,30 ' , & '1998,4,12 ' , & '1999,4,4  ' , & '2000,4,23 ' , & '2001,4,15 ' , & '2002,3,31 ' , & '2003,4,20 ' , & '2004,4,11 ' , & '2005,3,27 ' , & '2006,4,16 ' , & '2007,4,8  ' , & '2008,3,23 ' , & '2009,4,12 ' , & '2010,4,4  ' , & '2011,4,24 ' , & '2012,4,8  ' , & '2013,3,31 ' , & '2014,4,20 ' , & '2015,4,5  ' , & '2016,3,27 ' , & '2017,4,16 ' , & '2018,4,1  ' , & '2019,4,21 ' , & '2020,4,12 ' , & '2021,4,4  ' , & '2022,4,17 ' , & '2023,4,9  ' , & '2024,3,31 ' ] character ( len = 20 ) :: readme integer :: tmonth , tday integer :: inyear , outmonth , outday integer :: ii integer :: dat ( 8 ) character ( len = 5 ) :: mon ( 3 : 4 ) = ( / 'march' , 'april' / ) do ii = 1 , size ( tests ) readme = tests ( ii ) ! cannot do internal read on a parameter read ( readme , * ) inyear , tmonth , tday call easter ( inyear , dat ) outmonth = dat ( 2 ) outday = dat ( 3 ) call unit_test ( 'easter' , tmonth == outmonth . and . tday == outday , tests ( ii ), 'month=' , mon ( outmonth )) enddo call unit_test_end ( 'easter' ) ! assume if got here passed checks end subroutine test_easter","tags":"","url":"proc/test_easter.html"},{"title":"test_fmtdate – M_time","text":"subroutine test_fmtdate() Arguments None Variables Type Visibility Attributes Name Initial character(len=132), public :: comment integer, public :: dat (8) character(len=80), public :: date1 character(len=80), public :: date2 character(len=:), public, allocatable :: expected integer, public :: i character(len=80), public :: iso_week_date character(len=372), public, allocatable :: line (:) character(len=:), public, allocatable :: returned Source Code subroutine test_fmtdate character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i character ( len = :), allocatable :: expected character ( len = :), allocatable :: returned ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment if ( unit_test_level > 0 ) then call unit_test_msg ( 'fmtdate' , 'GIVEN:' // trim ( date1 ) // ' ' // trim ( comment )) endif call guessdate ( date1 , dat ) ! convert date string to DAT call unit_test ( 'fmtdate' , fmtdate ( dat , 'year-month-day' ) == trim ( date2 ), 'GOT' , fmtdate ( dat , 'year-month-day' ), 'expected' , date2 ) ! convert DAT to ISO week date, all generated dates should match ISO week date call unit_test ( 'fmtdate' , fmtdate ( dat , \"%I\" ) == iso_week_date , msg = iso_week_date ) enddo dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|Mar|March|Sat|Saturday|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|March|Mar|Mar|Sat|Sat|Saturday|Sat|Saturday' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|shortweekday|longweekday' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) expected = '|2nd|second|02|' returned = fmtdate ( dat , '|shortday|longday|day|' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) call unit_test_end ( 'fmtdate' ) end subroutine test_fmtdate","tags":"","url":"proc/test_fmtdate.html"},{"title":"test_fmtdate_usage – M_time","text":"subroutine test_fmtdate_usage() Arguments None Source Code subroutine test_fmtdate_usage call unit_test_end ( 'fmtdate_usage' ) end subroutine test_fmtdate_usage","tags":"","url":"proc/test_fmtdate_usage.html"},{"title":"test_guessdate – M_time","text":"subroutine test_guessdate() Arguments None Variables Type Visibility Attributes Name Initial character(len=132), public :: comment integer, public :: dat (8) character(len=80), public :: date1 character(len=80), public :: date2 integer, public :: i character(len=80), public :: iso_week_date character(len=372), public, allocatable :: line (:) Source Code subroutine test_guessdate character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment call guessdate ( date1 , dat ) ! convert date string to DAT call unit_test ( 'guessdate' ,& & fmtdate ( dat , \"%I\" ) == iso_week_date , 'input' , date1 , 'produced' , fmtdate ( dat , \"%I\" ), 'expected' , iso_week_date ) call unit_test ( 'guessdate' ,& & fmtdate ( dat , \"year-month-day\" ) == date2 , 'input' , date1 , 'produced' , fmtdate ( dat , \"year-month-day\" ), 'expected' , date2 ) enddo call unit_test_end ( 'guessdate' ) end subroutine test_guessdate","tags":"","url":"proc/test_guessdate.html"},{"title":"test_j2d – M_time","text":"subroutine test_j2d() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) character(len=:), public, allocatable :: expected real(kind=realtime), public :: juliandate character(len=:), public, allocatable :: resulted Source Code subroutine test_j2d real ( kind = realtime ) :: juliandate character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) juliandate = 245758 9.129d0 ! set sample Julian Date expected = '2016-07-19 11:05:45' dat = j2d ( juliandate ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = j2d ( juliandate - 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate - 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = j2d ( juliandate + 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate + 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'j2d' ) end subroutine test_j2d","tags":"","url":"proc/test_j2d.html"},{"title":"test_julian_to_date – M_time","text":"subroutine test_julian_to_date() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) character(len=:), public, allocatable :: expected integer, public :: ierr real(kind=realtime), public :: juliandate Source Code subroutine test_julian_to_date () real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected juliandate = 245758 9.129d0 ! set sample Julian Date call julian_to_date ( juliandate , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate - 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate + 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'julian_to_date' ) end subroutine test_julian_to_date","tags":"","url":"proc/test_julian_to_date.html"},{"title":"test_locale – M_time","text":"subroutine test_locale() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) character(len=9), public :: day character(len=:), public, allocatable :: expected integer, public :: ierr real(kind=realtime), public :: julian character(len=:), public, allocatable :: returned integer, public :: weekday Source Code subroutine test_locale () integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr real ( kind = realtime ) :: julian character ( len = :), allocatable :: expected character ( len = :), allocatable :: returned call to_upper_extended_ascii () dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|MAR|MARCH|SAT|SATURDAY|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|MARCH|MAR|MAR|SAT|SAT|SATURDAY|' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|' ) call unit_test ( 'locale' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) ! go forward one day call date_to_julian ( dat , julian , ierr ) julian = julian + 1 dat = j2d ( julian ) expected = '|MAR|MARCH|SUN|SUNDAY|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|MARCH|MAR|MAR|SUN|SUN|SUNDAY|' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|' ) call unit_test ( 'locale' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) call unit_test ( 'locale' , v2mo ( 1 ) == 'JANUARY' , 'JANUARY' , 'expected  JANUARY    got' , v2mo ( 1 ) ) call unit_test ( 'locale' , v2mo ( 2 ) == 'FEBRUARY' , 'FEBRUARY' , 'expected  FEBRUARY   got' , v2mo ( 2 ) ) call unit_test ( 'locale' , v2mo ( 3 ) == 'MARCH' , 'MARCH' , 'expected  MARCH      got' , v2mo ( 3 ) ) call unit_test ( 'locale' , v2mo ( 4 ) == 'APRIL' , 'APRIL' , 'expected  APRIL      got' , v2mo ( 4 ) ) call unit_test ( 'locale' , v2mo ( 5 ) == 'MAY' , 'MAY' , 'expected  MAY        got' , v2mo ( 5 ) ) call unit_test ( 'locale' , v2mo ( 6 ) == 'JUNE' , 'JUNE' , 'expected  JUNE       got' , v2mo ( 6 ) ) call unit_test ( 'locale' , v2mo ( 7 ) == 'JULY' , 'JULY' , 'expected  JULY       got' , v2mo ( 7 ) ) call unit_test ( 'locale' , v2mo ( 8 ) == 'AUGUST' , 'AUGUST' , 'expected  AUGUST     got' , v2mo ( 8 ) ) call unit_test ( 'locale' , v2mo ( 9 ) == 'SEPTEMBER' , 'SEPTEMBER' , 'expected  SEPTEMBER  got' , v2mo ( 9 ) ) call unit_test ( 'locale' , v2mo ( 10 ) == 'OCTOBER' , 'OCTOBER' , 'expected  OCTOBER    got' , v2mo ( 10 ) ) call unit_test ( 'locale' , v2mo ( 11 ) == 'NOVEMBER' , 'NOVEMBER' , 'expected  NOVEMBER   got' , v2mo ( 11 ) ) call unit_test ( 'locale' , v2mo ( 12 ) == 'DECEMBER' , 'DECEMBER' , 'expected  DECEMBER   got' , v2mo ( 12 ) ) call date_and_time ( values = dat ) dat = [ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ] call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'SATURDAY' . and . weekday == 6 , 'expected SATURDAY,6 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'SUNDAY' . and . weekday == 7 , 'expected SUNDAY,7 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'MONDAY' . and . weekday == 1 , 'expected MONDAY,1 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'TUESDAY' . and . weekday == 2 , 'expected TUESDAY,2 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'WEDNESDAY' . and . weekday == 3 , 'expected WEDNESDAY,3 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'THURSDAY' . and . weekday == 4 , 'expected THURSDAY,4 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'FRIDAY' . and . weekday == 5 , 'expected FRIDAY,5 got ' , day , weekday ) if ( unit_test_level > 0 ) then call locale ( 'show' ) endif call locale ( 'reset' ) if ( unit_test_level > 0 ) then call locale ( 'show' ) endif dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|Mar|March|Sat|Saturday|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'after reset macros: expected' , expected , 'returned' , returned ) expected = '|March|Mar|Mar|Sat|Sat|Saturday|Sat|Saturday|Mar|March' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|shortweekday|longweekday|shortmonth|longmonth' ) call unit_test ( 'locale' , returned . eq . expected , 'after reset keywords: expected' , expected , 'returned' , returned ) call unit_test_end ( 'locale' ) end subroutine test_locale","tags":"","url":"proc/test_locale.html"},{"title":"test_m2d – M_time","text":"subroutine test_m2d() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) character(len=:), public, allocatable :: expected real(kind=realtime), public :: mjd character(len=:), public, allocatable :: resulted Source Code subroutine test_m2d real ( kind = realtime ) :: mjd character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) mjd = 245758 9.129d0 - 240000 0.5_realtime ! set sample Modified Julian Date expected = '2016-07-19 11:05:45' dat = m2d ( mjd ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = m2d ( mjd - 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd - 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = m2d ( mjd + 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd + 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'm2d' ) end subroutine test_m2d","tags":"","url":"proc/test_m2d.html"},{"title":"test_mo2d – M_time","text":"subroutine test_mo2d() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) Source Code subroutine test_mo2d integer :: dat ( 8 ) call date_and_time ( values = dat ) call unit_test ( 'mo2d' , all ( mo2d ( 'january' , 2019 ) == [ 2019 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'January    2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'february' , 2019 ) == [ 2019 , 02 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'February   2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'march' , 2019 ) == [ 2019 , 03 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'March      2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'april' , 2019 ) == [ 2019 , 04 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'April      2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'may' , 2019 ) == [ 2019 , 05 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'May        2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'june' , 2019 ) == [ 2019 , 06 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'June       2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'july' , 2019 ) == [ 2019 , 07 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'July       2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'august' , 2019 ) == [ 2019 , 08 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'August     2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'september' , 2019 ) == [ 2019 , 09 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'September  2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'october' , 2019 ) == [ 2019 , 10 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'October    2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'november' , 2019 ) == [ 2019 , 11 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'November   2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'december' , 2019 ) == [ 2019 , 12 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'December   2019' ) call unit_test_end ( 'mo2d' ) end subroutine test_mo2d","tags":"","url":"proc/test_mo2d.html"},{"title":"test_mo2v – M_time","text":"subroutine test_mo2v() Arguments None Source Code subroutine test_mo2v () call unit_test ( 'mo2v' , mo2v ( 'jan' ) == 1 , msg = 'Check January' ) call unit_test ( 'mo2v' , mo2v ( 'Feb' ) == 2 , msg = 'Check February' ) call unit_test ( 'mo2v' , mo2v ( 'March' ) == 3 , msg = 'Check March' ) call unit_test ( 'mo2v' , mo2v ( 'APR' ) == 4 , msg = 'Check April' ) call unit_test ( 'mo2v' , mo2v ( 'may' ) == 5 , msg = 'Check May' ) call unit_test ( 'mo2v' , mo2v ( 'jun' ) == 6 , msg = 'Check Jun' ) call unit_test ( 'mo2v' , mo2v ( 'july' ) == 7 , msg = 'Check July' ) call unit_test ( 'mo2v' , mo2v ( 'Aug' ) == 8 , msg = 'Check August' ) call unit_test ( 'mo2v' , mo2v ( 'Sept' ) == 9 , msg = 'Check September' ) call unit_test ( 'mo2v' , mo2v ( 'Oct' ) == 10 , msg = 'Check October' ) call unit_test ( 'mo2v' , mo2v ( 'Nov' ) == 11 , msg = 'Check November' ) call unit_test ( 'mo2v' , mo2v ( 'December' ) == 12 , msg = 'Check December' ) call unit_test ( 'mo2v' , mo2v ( 'ja' ) == 1 , msg = 'Check \"ja\"' ) call unit_test ( 'mo2v' , mo2v ( 'j' ) == - 1 , msg = 'Check \"j\"' ) call unit_test ( 'mo2v' , mo2v ( '' ) == - 1 , msg = 'Check \"\"' ) call unit_test ( 'mo2v' , mo2v ( 'jax' ) == - 1 , msg = 'Check \"jax\"' ) call unit_test_end ( 'mo2v' ) ! assume if got here passed checks end subroutine test_mo2v","tags":"","url":"proc/test_mo2v.html"},{"title":"test_modified_julian_to_date – M_time","text":"subroutine test_modified_julian_to_date() Arguments None Variables Type Visibility Attributes Name Initial real(kind=realtime), public, parameter :: conv = 2400000.5_realtime integer, public :: dat (8) character(len=:), public, allocatable :: expected integer, public :: ierr real(kind=realtime), public :: mjd Source Code subroutine test_modified_julian_to_date () real ( kind = realtime ) :: mjd integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime mjd = 245758 9.129d0 - conv ! set sample Modified Julian Date call modified_julian_to_date ( mjd , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call modified_julian_to_date ( mjd - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd - 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call modified_julian_to_date ( mjd + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd + 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'modified_julian_to_date' ) end subroutine test_modified_julian_to_date","tags":"","url":"proc/test_modified_julian_to_date.html"},{"title":"test_moon_fullness – M_time","text":"subroutine test_moon_fullness() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) = [2018, 11, 3, -240, 20, 18, 44, 245] Source Code subroutine test_moon_fullness integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_test ( 'moon_fullness' , moon_fullness ( dat ) == - 30 ) call unit_test_end ( 'moon_fullness' ) end subroutine test_moon_fullness","tags":"","url":"proc/test_moon_fullness.html"},{"title":"test_now – M_time","text":"subroutine test_now() Arguments None Source Code subroutine test_now call unit_test_end ( 'now' ) end subroutine test_now","tags":"","url":"proc/test_now.html"},{"title":"test_now_ex – M_time","text":"subroutine test_now_ex() Arguments None Source Code subroutine test_now_ex call unit_test_end ( 'now_ex' ) end subroutine test_now_ex","tags":"","url":"proc/test_now_ex.html"},{"title":"test_o2d – M_time","text":"subroutine test_o2d() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) integer, public :: i integer, public :: iday integer, public :: iyear integer, public :: oday integer, public :: omonth character(len=40), public :: readme character(len=40), public, parameter :: tests (*) = ['ordinal  year  month  month_day  ', '100      2004  4      9          ', '100      2005  4      10         ', '100      2006  4      10         ', '100      2007  4      10         ', '100      2008  4      9          ', '100      2016  4      9          '] Source Code subroutine test_o2d () integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) call unit_test ( 'o2d' , dat ( 1 ) == iyear . and . dat ( 2 ) == omonth . and . dat ( 3 ) == oday , msg = tests ( i )) enddo call unit_test_end ( 'o2d' ) end subroutine test_o2d","tags":"","url":"proc/test_o2d.html"},{"title":"test_ordinal_seconds – M_time","text":"subroutine test_ordinal_seconds() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: rday Source Code subroutine test_ordinal_seconds () integer :: rday rday = ordinal_seconds () / ( 60 * 60 * 24 ) call unit_test ( 'ordinal_seconds' , rday == d2o (), rday , d2o ()) call unit_test_end ( 'ordinal_seconds' ) end subroutine test_ordinal_seconds","tags":"","url":"proc/test_ordinal_seconds.html"},{"title":"test_ordinal_to_date – M_time","text":"subroutine test_ordinal_to_date() use M_time, only : o2d, ordinal_to_date, d2o Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) integer, public :: i integer, public :: iday integer, public :: iyear integer, public :: oday integer, public :: omonth character(len=40), public :: readme character(len=40), public, parameter :: tests (*) = ['ordinal  year  month  month_day  ', '100      2004  4      9          ', '100      2005  4      10         ', '100      2006  4      10         ', '100      2007  4      10         ', '100      2008  4      9          ', '100      2016  4      9          '] Source Code subroutine test_ordinal_to_date () !!use M_time, only : o2d, ordinal_to_date, d2o integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday call ordinal_to_date ( iyear , iday , dat ) call unit_test ( 'ordinal_to_date' , dat ( 2 ) == omonth . and . dat ( 3 ) == oday , 'year' , iyear , 'ordinal' , iday ) enddo call unit_test_end ( 'ordinal_to_date' ) end subroutine test_ordinal_to_date","tags":"","url":"proc/test_ordinal_to_date.html"},{"title":"test_phase_of_moon – M_time","text":"subroutine test_phase_of_moon() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) = [2018, 11, 3, -240, 20, 18, 44, 245] Source Code subroutine test_phase_of_moon integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_test ( 'phase_of_moon' , phase_of_moon ( dat ) == 'Waning crescent' ) call unit_test_end ( 'phase_of_moon' ) end subroutine test_phase_of_moon","tags":"","url":"proc/test_phase_of_moon.html"},{"title":"test_sec2days – M_time","text":"subroutine test_sec2days() Arguments None Source Code subroutine test_sec2days () call unit_test ( 'sec2days' , sec2days ( 129860 ) == '1-12:04:20' , '129860 is 1-12:04:20' ) call unit_test ( 'sec2days' , sec2days ( 8000 0.0d0 ) == '0-22:13:20' , '80000.0d0 is 0-22:13:20' ) call unit_test ( 'sec2days' , sec2days ( 80000 , crop = . true .) == '22:13:20' , '80000 is 22:13:20' ) call unit_test ( 'sec2days' , sec2days ( '1day 2hr 3 min 4s' ) == '1-02:03:04' , '1day 2hr 3 min 4s is 1-02:03:04' ) call unit_test_end ( 'sec2days' ) end subroutine test_sec2days","tags":"","url":"proc/test_sec2days.html"},{"title":"test_u2d – M_time","text":"subroutine test_u2d() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: ex (8) integer, public :: re (8) integer, public :: utime Source Code subroutine test_u2d integer :: ex ( 8 ) integer :: re ( 8 ) integer :: utime utime = 1490766407 ex = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] re = u2d ( 1490766407 ) call unit_test ( 'u2d' , all ( re == ex ),& & 'EXPECTED' , 1490766407 , & & 'GOT' , d2u ( ex ) ) call unit_test_end ( 'u2d' ) end subroutine test_u2d","tags":"","url":"proc/test_u2d.html"},{"title":"test_unix_to_date – M_time","text":"subroutine test_unix_to_date() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: dat (8) integer, public :: ierr integer, public :: result (8) integer, public :: unixtime Source Code subroutine test_unix_to_date integer :: ierr integer :: dat ( 8 ) integer :: result ( 8 ) integer :: unixtime dat = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] unixtime = 1490766407 call unix_to_date ( unixtime , result , ierr ) call unit_test ( 'unix_to_date' , all ( dat == result ), 'IN' , unixtime ) !JSU call unit_test ( 'unix_to_date' , ierr == 0 , 'IERR' , ierr ) call unit_test_end ( 'unix_to_date' ) end subroutine test_unix_to_date","tags":"","url":"proc/test_unix_to_date.html"},{"title":"test_v2mo – M_time","text":"subroutine test_v2mo() Arguments None Source Code subroutine test_v2mo call unit_test ( 'v2mo' , v2mo ( 1 ) == 'January' , 'January' , v2mo ( 1 ) ) call unit_test ( 'v2mo' , v2mo ( 2 ) == 'February' , 'February' , v2mo ( 2 ) ) call unit_test ( 'v2mo' , v2mo ( 3 ) == 'March' , 'March' , v2mo ( 3 ) ) call unit_test ( 'v2mo' , v2mo ( 4 ) == 'April' , 'April' , v2mo ( 4 ) ) call unit_test ( 'v2mo' , v2mo ( 5 ) == 'May' , 'May' , v2mo ( 5 ) ) call unit_test ( 'v2mo' , v2mo ( 6 ) == 'June' , 'June' , v2mo ( 6 ) ) call unit_test ( 'v2mo' , v2mo ( 7 ) == 'July' , 'July' , v2mo ( 7 ) ) call unit_test ( 'v2mo' , v2mo ( 8 ) == 'August' , 'August' , v2mo ( 8 ) ) call unit_test ( 'v2mo' , v2mo ( 9 ) == 'September' , 'September' , v2mo ( 9 ) ) call unit_test ( 'v2mo' , v2mo ( 10 ) == 'October' , 'October' , v2mo ( 10 ) ) call unit_test ( 'v2mo' , v2mo ( 11 ) == 'November' , 'November' , v2mo ( 11 ) ) call unit_test ( 'v2mo' , v2mo ( 12 ) == 'December' , 'December' , v2mo ( 12 ) ) call unit_test_end ( 'v2mo' ) end subroutine test_v2mo","tags":"","url":"proc/test_v2mo.html"},{"title":"test_w2d – M_time","text":"subroutine test_w2d() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: d integer, public :: dat (8) integer, public :: i integer, public :: iso_week integer, public :: iso_weekday integer, public :: iso_year character(len=372), public, allocatable :: line (:) integer, public :: m integer, public :: y Source Code subroutine test_w2d character ( len = 372 ), allocatable :: line (:) integer :: y , m , d integer :: iso_year integer :: iso_week integer :: iso_weekday integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' 2005 01 01  2004 53 6   ' , & & ' 2005 01 02  2004 53 7   ' , & & ' 2005 12 31  2005 52 6   ' , & & ' 2007 01 01  2007 01 1   ' , & & ' 2007 12 30  2007 52 7   ' , & & ' 2007 12 31  2008 01 1   ' , & & ' 2008 01 01  2008 01 2   ' , & & ' 2008 12 28  2008 52 7   ' , & & ' 2008 12 29  2009 01 1   ' , & & ' 2008 12 30  2009 01 2   ' , & & ' 2008 12 31  2009 01 3   ' , & & ' 2009 01 01  2009 01 4   ' , & & ' 2009 12 31  2009 53 4   ' , & & ' 2010 01 01  2009 53 5   ' , & & ' 2010 01 02  2009 53 6   ' , & & ' 2010 01 03  2009 53 7   ' , & & '                          ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) y , m , d , iso_year , iso_week , iso_weekday call w2d ( iso_year , iso_week , iso_weekday , dat ) ! convert ISO week date to DAT call unit_test ( 'w2d' , dat ( 1 ) == y . and . dat ( 2 ) == m . and . dat ( 3 ) == d , msg = line ( i )) ! all should match enddo call unit_test_end ( 'w2d' ) end subroutine test_w2d","tags":"","url":"proc/test_w2d.html"},{"title":"to_upper_extended_ascii – M_time","text":"subroutine to_upper_extended_ascii() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: month_names (:) character(len=:), public, allocatable :: month_names_abbr (:) character(len=:), public, allocatable :: weekday_names (:) character(len=:), public, allocatable :: weekday_names_abbr (:) Source Code subroutine to_upper_extended_ascii () character ( len = :), allocatable :: month_names (:), weekday_names (:), month_names_abbr (:), weekday_names_abbr (:) month_names = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH' , 'APRIL' , 'MAY' , 'JUNE' , 'JULY' , 'AUGUST' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] weekday_names = [ character ( len = 10 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , 'SATURDAY' , 'SUNDAY' ] month_names_abbr = month_names (:)( 1 : 3 ) weekday_names_abbr = weekday_names (:)( 1 : 3 ) call locale ( 'user' , month_names , weekday_names , month_names_abbr , weekday_names_abbr ) end subroutine to_upper_extended_ascii","tags":"","url":"proc/to_upper_extended_ascii.html"},{"title":"to_upper_extended_ascii – M_time","text":"subroutine to_upper_extended_ascii() Arguments None Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: month_names (*) = [character(len=9)::'JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'] character(len=*), public, parameter :: month_names_abbr (*) = month_names(:)(1:3) character(len=*), public, parameter :: weekday_names (*) = [character(len=10)::'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'] character(len=*), public, parameter :: weekday_names_abbr (*) = weekday_names(:)(1:3) Source Code subroutine to_upper_extended_ascii () character ( len =* ), parameter :: month_names ( * ) = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH' , 'APRIL' , 'MAY' , 'JUNE' ,& & 'JULY' , 'AUGUST' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] character ( len =* ), parameter :: weekday_names ( * ) = [ character ( len = 10 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , & & 'SATURDAY' , 'SUNDAY' ] character ( len =* ), parameter :: month_names_abbr ( * ) = month_names (:)( 1 : 3 ) character ( len =* ), parameter :: weekday_names_abbr ( * ) = weekday_names (:)( 1 : 3 ) call locale ( 'user' , month_names , weekday_names , month_names_abbr , weekday_names_abbr ) end subroutine to_upper_extended_ascii","tags":"","url":"proc/to_upper_extended_ascii~2.html"},{"title":"printit – M_time","text":"subroutine printit(iso_year, iso_week, iso_weekday) Arguments Type Intent Optional Attributes Name integer :: iso_year integer :: iso_week integer :: iso_weekday Variables Type Visibility Attributes Name Initial integer, public :: dat (8) Source Code subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO-8601 Week: 2016-W29-1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * , '(a,i0)' ) 'GIVEN:           ' write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) end subroutine printit","tags":"","url":"proc/printit.html"},{"title":"millisec2days – M_time","text":"function millisec2days(milliseconds) result(dhms) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: milliseconds Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: ONE_DAY = 86400 integer(kind=int64), public, parameter :: ONE_HOUR = 3600 integer(kind=int64), public, parameter :: ONE_MINUTE = 60 integer(kind=int64), public :: days integer(kind=int64), public :: hours integer(kind=int64), public :: left integer(kind=int64), public :: minutes character(len=40), public :: scratch integer(kind=int64), public :: secsleft Source Code function millisec2days ( milliseconds ) result ( dhms ) ! @(#) M_time millisec2days(3f) converts milliseconds to string showing days of form D-HH:MM:SS.SSS integer ( kind = int64 ), intent ( in ) :: milliseconds integer ( kind = int64 ) :: days , hours , minutes , secsleft , left integer ( kind = int64 ), parameter :: ONE_DAY = 86400 , ONE_HOUR = 3600 , ONE_MINUTE = 60 character ( len = :), allocatable :: dhms character ( len = 40 ) :: scratch secsleft = milliseconds / 1000 left = mod ( milliseconds , 1000 ) days = secsleft / ONE_DAY ! get whole number of days secsleft = secsleft - days * ONE_DAY ! calculate remainder hours = secsleft / ONE_HOUR ! get whole number of hours secsleft = secsleft - hours * ONE_HOUR minutes = secsleft / ONE_MINUTE ! get whole number of minutes secsleft = secsleft - minutes * ONE_MINUTE write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) days , hours , minutes , secsleft , left dhms = trim ( scratch ) end function millisec2days","tags":"","url":"proc/millisec2days.html"},{"title":"run – M_time","text":"function run(command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command Return Value integer Variables Type Visibility Attributes Name Initial character(len=256), public :: cmdmsg integer, public :: cmdstat integer, public :: exitstat Source Code function run ( command ) ! @(#) M_system run(3f) call execute_command_line as a function character ( len =* ), intent ( in ) :: command integer :: exitstat integer :: cmdstat integer :: run character ( len = 256 ) :: cmdmsg cmdmsg = ' ' call execute_command_line ( trim ( command ), wait = . true ., exitstat = exitstat , cmdstat = cmdstat , cmdmsg = cmdmsg ) if ( cmdstat . ne . 0 ) then write ( stderr , * ) trim ( cmdmsg ) endif run = cmdstat end function run","tags":"","url":"proc/run.html"},{"title":"get_cmd – M_time","text":"subroutine get_cmd(command, status) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: command integer, intent(out) :: status Variables Type Visibility Attributes Name Initial character(len=255), public :: errmsg character(len=*), public, parameter :: gen = '(*(g0))' integer, public :: i integer, public :: j integer, public :: length character(len=:), public, allocatable :: value character(len=:), public, allocatable :: valueb Source Code subroutine get_cmd ( command , status ) ! @(#) compose a command from all the arguments passed to the program character ( len =* ), parameter :: gen = '(*(g0))' character ( len = :), allocatable , intent ( out ) :: command ! string of all arguments to create integer , intent ( out ) :: status ! status (non-zero means error) integer :: i , j character ( len = :), allocatable :: value , valueb ! hold individual arguments one at a time character ( len = 255 ) :: errmsg integer :: length ! length of individual arguments command = \"\" ! initialize returned output string errmsg = \"\" status = 0 ERRORS : BLOCK do i = 1 , command_argument_count () !call get_command_argument(i,length=length,status=status,errmsg=errmsg)   ! get length of next argument call get_command_argument ( i , length = length , status = status ) ! get length of next argument if ( status . ne . 0 ) exit ERRORS value = repeat ( ' ' , length ) !call get_command_argument(i,value=value,status=status,errmsg=errmsg)     ! get next argument call get_command_argument ( i , value = value , status = status ) ! get next argument if ( status /= 0 ) exit ERRORS if ( length . gt . 0 ) then ! SIMPLISTIC GUESS AT RE-QUOTING STRING ! assuming an operating system shell that strips the quotes from quoted strings on the command line. ! if argument contains a space and does not contain a double-quote ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. if ( index ( value , ' ' ). ne . 0. and . index ( value , '\"' ). eq . 0 ) then value = '\"' // value // '\"' elseif ( index ( value , '\"' ). ne . 0 ) then ! assume you double doublequotes to escape them and short enough that reallocating a lot not an issue valueb = '' do j = 1 , len ( value ) if ( value ( j : j ) == '\"' ) valueb = valueb // '\"' valueb = valueb // value ( j : j ) enddo value = '\"' // valueb // '\"' endif command = command // ' ' // value ! append strings together else command = command // '\"\"' endif enddo return endblock ERRORS write ( stderr , gen ) '*get_cmd* error obtaining argument ' , i , 'errmsg=' , trim ( errmsg ) stop end subroutine get_cmd","tags":"","url":"proc/get_cmd.html"},{"title":"millijulian – M_time","text":"subroutine millijulian(jm, timestr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out) :: jm character(len=:), allocatable :: timestr Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: a integer, public :: dat (8) integer(kind=int64), public :: jdn integer(kind=int64), public :: m integer(kind=int64), public :: utc integer(kind=int64), public :: y Source Code subroutine millijulian ( jm , timestr ) ! @(#)millijulian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date in milliseconds in Zulu timezone integer :: dat ( 8 ) integer ( kind = int64 ) :: a , y , m , jdn , utc integer ( kind = int64 ), intent ( out ) :: jm character ( len = :), allocatable :: timestr call date_and_time ( values = dat ) timestr = fmtdate ( dat , 'wkday Mth day hour:minute:second year' ) associate & &( year => dat ( 1 ), month => dat ( 2 ), day => dat ( 3 ), hour => dat ( 5 ), minute => dat ( 6 ), second => dat ( 7 ), milli => dat ( 8 )) !  You must first compute the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) a = ( 14_int64 - month ) / 12_int64 ! A will be 1 for January or February, and 0 for other months, with integer truncation y = year + 4800_int64 - a m = month + 12_int64 * a - 3_int64 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero ! intentionally computing with integer truncation jdn = day + ( 153_int64 * m + 2_int64 ) / 5_int64 + 365_int64 * y + y / 4_int64 - y / 100_int64 + y / 400_int64 - 32045_int64 !  Finding the Julian time in milliseconds given the JDN (Julian day number) and time of day jm = ( jdn * 86400_int64 + hour * 3600_int64 + minute * 60_int64 + second ) * 1000_int64 + milli end associate utc = dat ( 4 ) * 60 * 1000 ! Time difference with UTC in minutes converted to milliseconds jm = jm + utc ! set all values to Zulu time end subroutine millijulian","tags":"","url":"proc/millijulian.html"},{"title":"say_hello – M_time","text":"subroutine say_hello() Uses iso_fortran_env Arguments None Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: all = '(*(g0,1x))' integer, public :: argument_length character(len=2), public :: ch character(len=*), public, parameter :: chs = '(*(g0))' integer, public :: dos integer, public :: i integer, public :: istat character(len=:), public, allocatable :: options integer, public :: posix character(len=:), public, allocatable :: progname character(len=2), public :: split Source Code subroutine say_hello () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options character ( len =* ), parameter :: all = '(*(g0,1x))' character ( len =* ), parameter :: chs = '(*(g0))' character ( len = 2 ) :: ch , split integer :: argument_length , istat , posix , dos , i character ( len = :), allocatable :: progname , options call get_command_argument ( number = 0 , length = argument_length ) if ( allocated ( progname )) deallocate ( progname ) allocate ( character ( len = argument_length ) :: progname ) call get_command_argument ( 0 , progname , status = istat ) if ( istat == 0 ) then print all , \"program name.:\" // trim ( progname ) else print all , \"Could not get the program name \" // trim ( progname ) endif print all , 'compiled by..:' , compiler_version () options = ' ' // compiler_options () if ( options /= '' ) then print all , 'using options:' ! guess which one posix = 0 dos = 0 do i = 2 , len ( options ) ch = options ( i - 1 : i ) select case ( ch ) case ( ' -' ); posix = posix + 1 case ( ' /' ); dos = dos + 1 end select enddo split = merge ( ' -' , ' /' , posix > 0 ) do i = 2 , len ( options ) ch = options ( i - 1 : i ) if ( ch == split ) then write ( * , chs , advance = 'no' ) char ( 10 ), ch else write ( * , chs , advance = 'no' ) ch ( 2 : 2 ) endif enddo print all endif print all end subroutine say_hello","tags":"","url":"proc/say_hello.html"},{"title":"millijulian – M_time","text":"function millijulian() Arguments None Return Value integer(kind=int64) Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: a integer, public :: dat (8) integer(kind=int64), public :: jdn integer(kind=int64), public :: m integer(kind=int64), public :: utc integer(kind=int64), public :: y Source Code function millijulian () ! @(#)millijulian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date in milliseconds in Zulu timezone integer :: dat ( 8 ) integer ( kind = int64 ) :: a , y , m , jdn , utc , millijulian call date_and_time ( values = dat ) associate & &( year => dat ( 1 ), month => dat ( 2 ), day => dat ( 3 ), hour => dat ( 5 ), minute => dat ( 6 ), second => dat ( 7 ), milli => dat ( 8 )) !  You must first compute the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) a = ( 14_int64 - month ) / 12_int64 ! A will be 1 for January or February, and 0 for other months, with integer truncation y = year + 4800_int64 - a m = month + 12_int64 * a - 3_int64 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero ! intentionally computing with integer truncation jdn = day + ( 153_int64 * m + 2_int64 ) / 5_int64 + 365_int64 * y + y / 4_int64 - y / 100_int64 + y / 400_int64 - 32045_int64 !  Finding the Julian time in milliseconds given the JDN (Julian day number) and time of day millijulian = ( jdn * 86400_int64 + hour * 3600_int64 + minute * 60_int64 + second ) * 1000_int64 + milli end associate utc = dat ( 4 ) * 60 * 1000 ! Time difference with UTC in minutes converted to milliseconds millijulian = millijulian + utc ! set all values to Zulu time end function millijulian","tags":"","url":"proc/millijulian~2.html"},{"title":"millisec2days – M_time","text":"function millisec2days(milliseconds) result(dhms) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: milliseconds Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: ONE_DAY = 86400 integer(kind=int64), public, parameter :: ONE_HOUR = 3600 integer(kind=int64), public, parameter :: ONE_MINUTE = 60 integer(kind=int64), public :: days integer(kind=int64), public :: hours integer(kind=int64), public :: left integer(kind=int64), public :: minutes character(len=40), public :: scratch integer(kind=int64), public :: secsleft Source Code function millisec2days ( milliseconds ) result ( dhms ) ! @(#) M_time millisec2days(3f) converts milliseconds to string showing days of form D-HH:MM:SS.SSS integer ( kind = int64 ), intent ( in ) :: milliseconds integer ( kind = int64 ) :: days , hours , minutes , secsleft , left integer ( kind = int64 ), parameter :: ONE_DAY = 86400 , ONE_HOUR = 3600 , ONE_MINUTE = 60 character ( len = :), allocatable :: dhms character ( len = 40 ) :: scratch secsleft = milliseconds / 1000 left = mod ( milliseconds , 1000 ) days = secsleft / ONE_DAY ! get whole number of days secsleft = secsleft - days * ONE_DAY ! calculate remainder hours = secsleft / ONE_HOUR ! get whole number of hours secsleft = secsleft - hours * ONE_HOUR minutes = secsleft / ONE_MINUTE ! get whole number of minutes secsleft = secsleft - minutes * ONE_MINUTE write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) days , hours , minutes , secsleft , left dhms = trim ( scratch ) end function millisec2days","tags":"","url":"proc/millisec2days~2.html"},{"title":"run – M_time","text":"function run(command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command Return Value integer Variables Type Visibility Attributes Name Initial character(len=256), public :: cmdmsg integer, public :: cmdstat integer, public :: exitstat Source Code function run ( command ) ! @(#) M_system run(3f) call execute_command_line as a function character ( len =* ), intent ( in ) :: command integer :: exitstat integer :: cmdstat integer :: run character ( len = 256 ) :: cmdmsg cmdmsg = ' ' call execute_command_line ( trim ( command ), wait = . true ., exitstat = exitstat , cmdstat = cmdstat , cmdmsg = cmdmsg ) if ( cmdstat . ne . 0 ) then write ( stderr , * ) trim ( cmdmsg ) endif run = cmdstat end function run","tags":"","url":"proc/run~2.html"},{"title":"get_cmd – M_time","text":"subroutine get_cmd(command, status) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: command integer, intent(out) :: status Variables Type Visibility Attributes Name Initial character(len=255), public :: errmsg character(len=*), public, parameter :: gen = '(*(g0))' integer, public :: i integer, public :: j integer, public :: length character(len=:), public, allocatable :: value character(len=:), public, allocatable :: valueb Source Code subroutine get_cmd ( command , status ) ! @(#) compose a command from all the arguments passed to the program character ( len =* ), parameter :: gen = '(*(g0))' character ( len = :), allocatable , intent ( out ) :: command ! string of all arguments to create integer , intent ( out ) :: status ! status (non-zero means error) integer :: i , j character ( len = :), allocatable :: value , valueb ! hold individual arguments one at a time character ( len = 255 ) :: errmsg integer :: length ! length of individual arguments command = \"\" ! initialize returned output string errmsg = \"\" status = 0 ERRORS : BLOCK do i = 1 , command_argument_count () !call get_command_argument(i,length=length,status=status,errmsg=errmsg)   ! get length of next argument call get_command_argument ( i , length = length , status = status ) ! get length of next argument if ( status . ne . 0 ) exit ERRORS value = repeat ( ' ' , length ) !call get_command_argument(i,value=value,status=status,errmsg=errmsg)     ! get next argument call get_command_argument ( i , value = value , status = status ) ! get next argument if ( status /= 0 ) exit ERRORS if ( length . gt . 0 ) then ! SIMPLISTIC GUESS AT RE-QUOTING STRING ! assuming an operating system shell that strips the quotes from quoted strings on the command line. ! if argument contains a space and does not contain a double-quote ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. if ( index ( value , ' ' ). ne . 0. and . index ( value , '\"' ). eq . 0 ) then value = '\"' // value // '\"' elseif ( index ( value , '\"' ). ne . 0 ) then ! assume you double doublequotes to escape them and short enough that reallocating a lot not an issue valueb = '' do j = 1 , len ( value ) if ( value ( j : j ) == '\"' ) valueb = valueb // '\"' valueb = valueb // value ( j : j ) enddo value = '\"' // valueb // '\"' endif command = command // ' ' // value ! append strings together else command = command // '\"\"' endif enddo return endblock ERRORS write ( stderr , gen ) '*get_cmd* error obtaining argument ' , i , 'errmsg=' , trim ( errmsg ) stop end subroutine get_cmd","tags":"","url":"proc/get_cmd~2.html"},{"title":"setup – M_time","text":"subroutine setup() Arguments None Source Code subroutine setup () help_text = [ CHARACTER ( LEN = 128 ) :: & 'help_text=[ CHARACTER(LEN=128) :: &' ,& '                                   ' ,& 'NAME                               ' ,& '  howlong(1) - display wallclock time taken to execute a system command' ,& '                                                                       ' ,& 'SYNOPIS                                                                ' ,& '                                                                       ' ,& '  howlong SYSTEM_COMMAND                                               ' ,& '                                                                       ' ,& '   or                                                                  ' ,& '                                                                       ' ,& '  howlong --help|--version                                             ' ,& '                                                                       ' ,& 'DESCRIPTION                                                            ' ,& '                                                                       ' ,& 'Perhaps the simplest performance metric is to just measure the         ' ,& 'wallclock time taken by a program. This could literally be measured    ' ,& 'using a conventional clock or stopwatch. This is difficult to automate!' ,& 'So typically a command like the GNU/Linux or Unix command time(1) is used.' ,& '                                                                          ' ,& 'Commands such as time(1)                                                  ' ,& 'often provide more than wallclock times too. But lets construct a wallclock' ,& 'timing tool of our own using standard Fortran (not even the ISO_C_Binding  ' ,& 'interface will be called upon) that will measure the run time of a command.' ,& '                                                                           ' ,& 'Once passed a command to time on the command line, it will then run        ' ,& 'the command and report the wallclock time use by the program, and echo     ' ,& 'the command.                                                               ' ,& '                                                                           ' ,& 'Next we provide a simple program that calls the routine(s) of interest     ' ,& 'enough times to get useful timing information and time it.                 ' ,& '                                                                           ' ,& 'So lets say we compiled up the test program using two different sets of    ' ,& 'compiler options:                                                          ' ,& '                                                                           ' ,& '    f90 little_test.f90 -O0 -o little_test0                                ' ,& '    f90 little_test.f90 -O3 -o little_test3                                ' ,& '                                                                           ' ,& 'Now to run the programs via our timing utility only takes a few commands:  ' ,& '                                                                           ' ,& '    howlong ./little_test0                                                 ' ,& '    Wallclock: 0-00:00:25.461 :command: ./little_test0                     ' ,& '    howlong ./little_test3                                                 ' ,& '    Wallclock: 0-00:00:10.274 :command: ./little_test3                     ' ,& '                                                                           ' ,& 'SAMPLE SUBJECT PROGRAM                                                     ' ,& '                                                                           ' ,& 'An uninstrumented test program for timing :                                ' ,& '                                                                           ' ,& '   program little_test                                                     ' ,& '   use,intrinsic :: iso_fortran_env, only : int8                           ' ,& '   implicit none                                                           ' ,& '   character(len=*),parameter             :: original = \"abcdxyz ZXYDCBA _!@\"' ,& '   integer,parameter                      :: how_many_times = 100000000      ' ,& '   character(len=:),volatile,allocatable  :: t                               ' ,& '   integer                                :: i                               ' ,& '      do i=1,how_many_times                                                  ' ,& '        t=upper(original)                                                    ' ,& '        t=lower(original)                                                    ' ,& '      enddo                                                                  ' ,& '   contains                                                                  ' ,& '   function upper(str) result(translated)                                    ' ,& '   integer(kind=int8), parameter :: &                                        ' ,& '   & ascii_diff = abs(iachar(''A'',kind=int8) - iachar(''a'',kind=int8))     ' ,& '   character(*), intent(in) :: str                                           ' ,& '   integer :: i                                                              ' ,& '   character(len=len(str)) :: translated                                     ' ,& '                                                                             ' ,& '      translated=str                                                         ' ,& '      do i = 1, len(str)                                                     ' ,& '        select case(str(i:i))                                                ' ,& '          case(\"a\":\"z\")                                                      ' ,& '            translated(i:i) = achar(iachar(str(i:i))-ascii_diff)             ' ,& '        end select                                                           ' ,& '      enddo                                                                  ' ,& '   end function upper                                                        ' ,& '                                                                             ' ,& '   function lower(str) result(translated)                                    ' ,& '   integer(kind=int8), parameter :: &                                        ' ,& '   & ascii_diff = abs(iachar(''A'',kind=int8) - iachar(''a'',kind=int8))     ' ,& '   character(*), intent(in) :: str                                           ' ,& '   integer :: i                                                              ' ,& '   character(len=len(str)) :: translated                                     ' ,& '                                                                             ' ,& '      translated=str                                                         ' ,& '      do i = 1, len(str)                                                     ' ,& '        select case(str(i:i))                                                ' ,& '          case(\"A\":\"Z\")                                                      ' ,& '            translated(i:i) = achar(iachar(str(i:i))+ascii_diff)             ' ,& '        end select                                                           ' ,& '      enddo                                                                  ' ,& '   end function lower                                                        ' ,& '                                                                             ' ,& '   end program little_test                                                   ' ,& '                                                                             ' ,& 'FOOTNOTES                                                                    ' ,& '                                                                             ' ,& 'Note that in many HPC environments programs are often run via a job          ' ,& 'scheduler like Slurm, LSF, PBS, Torque, ... . In these environments          ' ,& 'there are usually account records of each job that provide resource          ' ,& 'usage statistics.                                                            ' ,& '                                                                             ' ,& 'OPTIONS                                                                      ' ,& '   --help      display this help and exit                                    ' ,& '   --version   output version information and exit                           ' ,& '                                                                             ' ,& 'EXAMPLES                                                                     ' ,& '    howlong ./myprogram                                                      ' ,& '                                                                             ' ,& 'SEE ALSO                                                                     ' ,& '    gprof(1), gcov(1)                                                        ' ,& '' ] version_text = [ CHARACTER ( LEN = 128 ) :: & 'version_text=[ CHARACTER(LEN=128) :: &' ,& '@(#)PRODUCT:         GPF (General Purpose Fortran) utilities and examples' ,& '@(#)PROGRAM:         howlong(1)                                          ' ,& '@(#)DESCRIPTION:     run a system command and return wallclock time it took to execute' ,& '@(#)VERSION:         1.0.0, 2024-09-28                                                ' ,& '@(#)AUTHOR:          John S. Urban                                                    ' ,& '@(#)HOME PAGE:       https://github.com/urbanjost?tab=repositories                    ' ,& '@(#)LICENSE:         MIT License                                                      ' ,& '' ] end subroutine setup","tags":"","url":"proc/setup.html"},{"title":"help_usage – M_time","text":"subroutine help_usage(l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical, public :: stopit = .false. Source Code subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   month(1f) - [TIME] display a calendar                                        ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   month [[ -year] NNNN] [ -month NN|month_name]                                ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   month(1) displays a simple calendar. If no arguments are specified,          ' ,& '   the current year is displayed.                                               ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   -month NN   Display single month output. The month is numeric (1-12)         ' ,& '               or a month name or blank. If blank the current month is assumed. ' ,& '                                                                                ' ,& '   -year NNNN  Select the year to display. A year starts on Jan 1st.            ' ,& '                                                                                ' ,& '   -help       Display help text and exit.                                      ' ,& '   -version    Display version information and exit.                            ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '      month -month 12                                                           ' ,& '                                                                                ' ,& '       >    December 2015                                                       ' ,& '       >Mo Tu We Th Fr Sa Su                                                    ' ,& '       >    1  2  3  4  5  6                                                    ' ,& '       > 7  8  9 10 11 12 13                                                    ' ,& '       >14 15 16 17 18 19 20                                                    ' ,& '       >21 22 23 24 25 26 27                                                    ' ,& '       >28 29 30 31                                                             ' ,& '                                                                                ' ,& '      month -month April # month names may be given instead of numbers          ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage","tags":"","url":"proc/help_usage~5.html"},{"title":"help_version – M_time","text":"subroutine help_version(l_version) NAME month ( 1 f ) - [ TIME ] display a calendar ( LICENSE : PD ) SYNOPSIS month [[ -year] NNNN] [ -month NN|month_name] DESCRIPTION month ( 1 ) displays a simple calendar . If no arguments are specified , the current year is displayed . OPTIONS - month NN Display single month output . The month is numeric ( 1 - 12 ) or a month name or blank . If blank the current month is assumed . - year NNNN Select the year to display . A year starts on Jan 1 st . - help Display help text and exit . - version Display version information and exit . EXAMPLES month -month 12\n\n    >    December 2015\n    >Mo Tu We Th Fr Sa Su\n    >    1  2  3  4  5  6\n    > 7  8  9 10 11 12 13\n    >14 15 16 17 18 19 20\n    >21 22 23 24 25 26 27\n    >28 29 30 31\n\n   month -month April # month names may be given instead of numbers AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: help_text (:) integer, public :: i character(len=*), public, parameter :: ident = \"@(#)help_version(3f): prints version information\" logical, public :: stopit = .false. Source Code subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        month(1f)>' ,& '@(#)DESCRIPTION:    displays simple calendar>' ,& '@(#)VERSION:        1.0, 2015-12-20>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version","tags":"","url":"proc/help_version~7.html"},{"title":"adjustc – M_time","text":"public pure function adjustc(string, length) NAME adjustc(3f) - [M_strings:WHITESPACE] center text\n   (LICENSE:PD) SYNOPSIS pure function adjustc(string[,length]) character(len=*),intent(in)  :: string\ninteger,intent(in),optional  :: length\ncharacter(len=:),allocatable :: adjustc DESCRIPTION Centers input text in a string of the length specified. Returns a\n   string of length LENGTH if LENGTH is present. Otherwise returns a\n   string of the length of the input string. OPTIONS string  input string to trim and center\n length  line length to center text in, optional. RETURNS adjustc  centered output string EXAMPLES Sample Program:\n\n program demo_adjustc\n use M_strings, only : adjustc\n !  using length of the input string\n    write(*,'(a)')       '================================'\n    write(*,'(a)')adjustc('centered string                 ')\n    write(*,'(a)')adjustc('                 centered string')\n    write(*,'(a)')adjustc('  centered string               ')\n !  using explicit output string length\n    write(*,'(a)')repeat('=',50)\n    write(*,'(a)')adjustc('this is a centered string',50)\n    write(*,'(a)')repeat('=',50)\n end program demo_adjustc\n\nExpected output:\n\n \\================================\n         centered string\n         centered string\n         centered string\n \\==================================================\n             this is a centered string\n \\================================================== AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string PROCEDURE   adjustc(3f)\n DESCRIPTION center text using implicit or explicit length VERSION     2.0, 20160711 AUTHOR      John S. Urban integer, intent(in), optional :: length Return Value character(len=:), allocatable Source Code pure function adjustc ( string , length ) !character(len=*),parameter::ident_32=\"@(#)M_strings::adjustc(3f): center text\" !> !! PROCEDURE   adjustc(3f) !! DESCRIPTION center text using implicit or explicit length !!##VERSION     2.0, 20160711 !! AUTHOR      John S. Urban !=================================================================================================================================== !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string ! input string to trim and center integer , intent ( in ), optional :: length ! line length to center text in character ( len = :), allocatable :: adjustc ! output string integer :: inlen integer :: ileft ! left edge of string if it is centered !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( length )) then ! optional length inlen = length ! length will be requested length if ( inlen <= 0 ) then ! bad input length inlen = len ( string ) ! could not use input value, fall back to length of input string endif else ! output length was not explicitly specified, use input string length inlen = len ( string ) endif allocate ( character ( len = inlen ) :: adjustc ) ! create output at requested length adjustc ( 1 : inlen ) = ' ' ! initialize output string to all blanks !----------------------------------------------------------------------------------------------------------------------------------- ileft = ( inlen - len_trim ( adjustl ( string ))) / 2 ! find starting point to start input string to center it if ( ileft > 0 ) then ! if string will fit centered in output adjustc ( ileft + 1 : inlen ) = adjustl ( string ) ! center the input text in the output string else ! input string will not fit centered in output string adjustc ( 1 : inlen ) = adjustl ( string ) ! copy as much of input to output as can endif end function adjustc","tags":"","url":"proc/adjustc.html"},{"title":"compact – M_time","text":"public  function compact(str, char) result(outstr) NAME compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing)\n(LICENSE:PD) SYNOPSIS function compact(STR,CHAR) result ( OUTSTR ) character ( len = * ), intent ( in ) :: STR character ( len = * ), intent ( in ), optional :: CHAR character ( len = len ( str )) :: OUTSTR DESCRIPTION COMPACT(3f) converts multiple spaces, tabs and control characters\n   (called “whitespace”) to a single character or nothing. Leading\n   whitespace is removed. OPTIONS STR input string to reduce or remove whitespace from CHAR By default the character that replaces adjacent whitespace is a space . If the optional CHAR parameter is supplied it will be used to replace the whitespace . If a null character is supplied for CHAR whitespace is removed . RETURNS OUTSTR  string of same length as input string but with all contiguous whitespace\n        reduced to a single space and leading whitespace removed EXAMPLES Sample Program : program demo_compact use M_strings , only : compact implicit none ! produces ' This is a test ' write ( * , * ) compact ( ' This is a test ' ) ! produces ' Thisisatest ' write ( * , * ) compact ( ' This is a test ' , char = '' ) ! produces ' This : is : a : test ' write ( * , * ) compact ( ' This is a test ' , char = ':' ) ! note CHAR is used to replace the whitespace , but if CHAR is ! in the original string it is just copied write ( * , * ) compact ( ' A AA A AAAAA ' , char = 'A' ) ! produces ( original A characters are left as - is ) ' AAAAAAAAAAAA ' ! not 'A' end program demo_compact Expected output > This is a test > Thisisatest > This : is : a : test > AAAAAAAAAAAA AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: char Return Value character(len=len) Source Code function compact ( str , char ) result ( outstr ) !character(len=*),parameter::ident_38=\"@(#)M_strings::compact(3f): Converts white-space to single spaces\" character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ), optional :: char character ( len = len ( str )) :: outstr character ( len = 1 ) :: ch integer :: i integer :: position_in_output logical :: last_was_space character ( len = 1 ) :: char_p logical :: nospace if ( present ( char )) then char_p = char if ( len ( char ) == 0 ) then nospace = . true . else nospace = . false . endif else char_p = ' ' nospace = . false . endif outstr = ' ' last_was_space = . false . position_in_output = 0 IFSPACE : do i = 1 , len_trim ( str ) ch = str ( i : i ) select case ( ichar ( ch )) case ( 0 : 32 , 127 ) ! space or tab character or control character if ( position_in_output == 0 ) then ! still at beginning so ignore leading whitespace cycle IFSPACE elseif (. not . last_was_space ) then ! if have not already put out a space output one if (. not . nospace ) then position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = char_p endif endif last_was_space = . true . case (: - 1 , 33 : 126 , 128 :) ! not a space, quote, or control character so copy it position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = ch last_was_space = . false . end select end do IFSPACE end function compact","tags":"","url":"proc/compact.html"},{"title":"lower – M_time","text":"public pure elemental function lower(str, begin, end) result(string) NAME lower(3f) - [M_strings:CASE] changes a string to lowercase over specified range\n(LICENSE:PD) SYNOPSIS elemental pure function lower(str,begin,end) result (string)\n\n character(*), intent(in) :: str\n integer,optional         :: begin, end\n character(len(str))      :: string  ! output string DESCRIPTION lower(string) returns a copy of the input string with all characters\n   converted to miniscule over the specified range, assuming ASCII\n   character sets are being used. If no range is specified the entire\n   string is converted to miniscule. OPTIONS str string to convert to miniscule begin optional starting position in \"str\" to begin converting to miniscule end optional ending position in \"str\" to stop converting to miniscule RESULTS lower  copy of the input string with all characters converted to miniscule\n       over optionally specified range. TRIVIA The terms \"uppercase\" and \"lowercase\" date back to the early days of\nthe mechanical printing press. Individual metal alloy casts of each\nneeded letter, or punctuation symbol, were meticulously added to a\npress block, by hand, before rolling out copies of a page. These\nmetal casts were stored and organized in wooden cases. The more\noften needed miniscule letters were placed closer to hand, in the\nlower cases of the work bench. The less often needed, capitalized,\nmajuscule letters, ended up in the harder to reach upper cases. EXAMPLES Sample program : program demo_lower use M_time , only : lower implicit none character ( len =:), allocatable :: s s = ' ABCDEFG abcdefg ' write ( * , * ) ' mixed - case input string is ... . ' , s write ( * , * ) ' lower - case output string is ... ' , lower ( s ) end program demo_lower Expected output mixed - case input string is ... . ABCDEFG abcdefg lower - case output string is ... abcdefg abcdefg AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Source Code elemental pure function lower ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_22=\"@(#)M_strings::lower(3f): Changes a string to lowercase over specified range\" character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower","tags":"","url":"proc/lower.html"},{"title":"s2v – M_time","text":"public  function s2v(chars, ierr, onerr) NAME s2v(3f) - [M_strings:NUMERIC] function returns doubleprecision numeric value from a string\n  (LICENSE:PD) SYNOPSIS function s2v ( string[,ierr][,onerr] ) character ( len = * ) :: string doubleprecision :: s2v integer , intent ( out ), optional :: ierr class ( * ), intent ( in ), optional :: onerr DESCRIPTION This function converts a string to a DOUBLEPRECISION numeric value. The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended to take\n   CHARACTER variables. The KIND= keyword is not supported on the extensions. OPTIONS string holds string assumed to represent a numeric value ierr If an error occurs the program is stopped if the optional parameter IERR is not present . If IERR returns a non - zero value an error occurred . onerr The value to return on error . A value of zero ( NaN ) is returned on error by default . RETURNS s2v EXAMPLES Sample Program : program demo_s2v use M_strings , only : s2v , int , real , dble implicit none character ( len = 8 ) :: s = ' 10.345 ' integer :: i character ( len = 14 ), allocatable :: strings (:) doubleprecision :: dv integer :: errnum ! different strings representing INTEGER , REAL , and DOUBLEPRECISION strings =[ & & ' 10.345 ' , & & ' + 10 ' , & & ' - 3 ' , & & ' - 4.94 e - 2 ' , & & ' 0.1 ' , & & ' 12345.678910 d0 ' , & & ' ' , & ! Note : will return zero without an error message & ' 1 2 1 2 1 . 0 ' , & ! Note : spaces will be ignored & ' WHAT ? ' ] ! Note : error messages will appear , zero returned ! a numeric value is returned , so it can be used in numeric expression write ( * , * ) ' 1 / 2 value of string is ' , s2v ( s ) / 2.0 d0 write ( * , * ) write ( * , * ) ' STRING VALUE ERROR_NUMBER ' do i = 1 , size ( strings ) ! Note : not a good idea to use s2v ( 3 f ) in a WRITE ( 3 f ) statement , ! as it does I / O when errors occur , so called on a separate line dv = s2v ( strings ( i ), errnum ) write ( * , * ) strings ( i ) //'=',dv,errnum enddo write ( * , * ) \"Extended intrinsics\" write ( * , * ) ' given inputs : ' , s , strings (: 8 ) write ( * , * ) ' INT ( 3 f ): ' , int ( s ), int ( strings (: 8 )) write ( * , * ) ' REAL ( 3 f ): ' , real ( s ), real ( strings (: 8 )) write ( * , * ) ' DBLE ( 3 f ): ' , dble ( s ), dble ( strings (: 8 )) write ( * , * ) \"That's all folks!\" end program demo_s2v Expected output > 1 / 2 value of string is 5.1725000000000003 > > STRING VALUE ERROR_NUMBER > 10.345 = 10.345000000000001 0 > + 10 = 10.000000000000000 0 > - 3 = - 3.0000000000000000 0 > - 4.94 e - 2 = - 4.9399999999999999 E - 002 0 > 0.1 = 0.10000000000000001 0 > 12345.678910 d0 = 12345.678910000001 0 > = 0.0000000000000000 0 > 1 2 1 2 1 . 0 = 12121.000000000000 0 > * a2d * - cannot produce number from string [ WHAT ?] > * a2d * - [ Bad value during floating point read ] > WHAT ? = 0.0000000000000000 5010 > Extended intrinsics > given inputs : 10.345 10.345 + 10 - 3 - 4.94 e - 2 0.1 12345.678910 d0 1 2 1 2 1 . 0 > INT ( 3 f ): 10 10 10 - 3 0 0 12345 0 12121 > REAL ( 3 f ): 10.3450003 10.3450003 10.0000000 - 3.00000000 - 4.94000018 E - 02 > 0.100000001 12345.6787 0.00000000 12121.0000 > DBLE ( 3 f ): 10.345000000000001 10.345000000000001 10.000000000000000 > - 3.0000000000000000 - 4.9399999999999999 E - 002 0.10000000000000001 > 12345.678910000001 0.0000000000000000 12121.000000000000 > That ' s all folks ! AUTHOR John S. Urban LICENSE Public Domain PROCEDURE: DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs VERSION:     2.0, 20160704 AUTHOR:      John S. Urban Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, optional :: ierr class(*), intent(in), optional :: onerr Return Value doubleprecision Source Code doubleprecision function s2v ( chars , ierr , onerr ) !  1989 John S. Urban !character(len=*),parameter::ident_43=\"@(#)M_strings::s2v(3f): returns doubleprecision number from string\" character ( len =* ), intent ( in ) :: chars integer , optional :: ierr doubleprecision :: valu integer :: ierr_local class ( * ), intent ( in ), optional :: onerr ierr_local = 0 if ( present ( onerr )) then call a2d ( chars , valu , ierr_local , onerr ) else call a2d ( chars , valu , ierr_local ) endif if ( present ( ierr )) then ! if error is not returned stop program on error ierr = ierr_local s2v = valu elseif ( ierr_local /= 0 ) then write ( stderr , * ) '<ERROR>*s2v* - stopped while reading ' // trim ( chars ) stop 1 else s2v = valu endif end function s2v","tags":"","url":"proc/s2v.html"},{"title":"transliterate – M_time","text":"public pure function transliterate(instr, old_set, new_set) result(outstr) NAME transliterate(3f) - [M_strings:EDITING] replace characters from old set with new set\n(LICENSE:PD) SYNOPSIS pure function transliterate(instr,old_set,new_set) result(outstr)\n\n character(len=*),intent(in)  :: instr\n character(len=*),intent(in)  :: old_set\n character(len=*),intent(in)  :: new_set\n character(len=len(instr))    :: outstr DESCRIPTION Translate, squeeze, and/or delete characters from the input string. OPTIONS instr    input string to change\nold_set  list of letters to change in INSTR if found\n\n         Each character in the input string that matches a character in\n         the old set is replaced.\nnew_set  list of letters to replace letters in OLD_SET with.\n\n         If the new_set is the empty set the matched characters are deleted.\n\n         If the new_set is shorter than the old set the last character in the\n         new set is used to replace the remaining characters in the new set. RETURNS outstr   instr with substitutions applied EXAMPLES Sample Program : program demo_transliterate use M_strings , only : transliterate implicit none character ( len = 80 ) :: STRING STRING = ' aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ ' write ( * , ' ( a ) ' ) STRING ! convert a string to uppercase : write ( * , * ) TRANSLITERATE ( STRING , ' abcdefghijklmnopqrstuvwxyz ',' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' ) ! change all miniscule letters to a colon ( \":\" ): write ( * , * ) TRANSLITERATE ( STRING , ' abcdefghijklmnopqrstuvwxyz ',' : ' ) ! delete all miniscule letters write ( * , * ) TRANSLITERATE ( STRING , ' abcdefghijklmnopqrstuvwxyz ',' ' ) end program demo_transliterate Expected output > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ > : A : B : C : D : E : F : G : H : I : J : K : L : M : N : O : P : Q : R : S : T : U : V : W : X : Y : Z > ABCDEFGHIJKLMNOPQRSTUVWXYZ AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value character(len=LEN) Source Code PURE FUNCTION transliterate ( instr , old_set , new_set ) RESULT ( outstr ) !character(len=*),parameter::ident_16=\"@(#)M_strings::transliterate(3f): replace characters from old set with new set\" !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input string to change CHARACTER ( LEN =* ), intent ( in ) :: old_set CHARACTER ( LEN =* ), intent ( in ) :: new_set !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN = LEN ( instr )) :: outstr ! output string to generate !----------------------------------------------------------------------------------------------------------------------------------- INTEGER :: i10 ! loop counter for stepping thru string INTEGER :: ii , jj !----------------------------------------------------------------------------------------------------------------------------------- jj = LEN ( new_set ) IF ( jj /= 0 ) THEN outstr = instr ! initially assume output string equals input string stepthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii /= 0 ) THEN if ( ii <= jj ) then ! use corresponding character in new_set outstr ( i10 : i10 ) = new_set ( ii : ii ) else outstr ( i10 : i10 ) = new_set ( jj : jj ) ! new_set not as long as old_set; use last character in new_set endif ENDIF ENDDO stepthru else ! new_set is null string so delete characters in old_set outstr = ' ' hopthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii == 0 ) THEN ! only keep characters not in old_set jj = jj + 1 outstr ( jj : jj ) = instr ( i10 : i10 ) ENDIF ENDDO hopthru endif END FUNCTION transliterate","tags":"","url":"proc/transliterate.html"},{"title":"upper – M_time","text":"public pure elemental function upper(str, begin, end) result(string) NAME upper(3f) - [M_strings:CASE] changes a string to uppercase\n (LICENSE:PD) SYNOPSIS elemental pure function upper(str,begin,end) result (string)\n\n character(*), intent(in)    :: str\n integer,optional,intent(in) :: begin,end\n character(len(str))         :: string  ! output string DESCRIPTION upper(string) returns a copy of the input string with all characters\n   converted in the optionally specified range to uppercase, assuming\n   ASCII character sets are being used. If no range is specified the\n   entire string is converted to uppercase. OPTIONS str string to convert to uppercase begin optional starting position in \"str\" to begin converting to uppercase end optional ending position in \"str\" to stop converting to uppercase RESULTS upper  copy of the input string with all characters converted to uppercase\n        over optionally specified range. TRIVIA The terms “uppercase” and “lowercase” date back to the early days of\n   the mechanical printing press. Individual metal alloy casts of each\n   needed letter, or punctuation symbol, were meticulously added to a\n   press block, by hand, before rolling out copies of a page. These\n   metal casts were stored and organized in wooden cases. The more\n   often needed miniscule letters were placed closer to hand, in the\n   lower cases of the work bench. The less often needed, capitalized,\n   majuscule letters, ended up in the harder to reach upper cases. EXAMPLES Sample program : program demo_upper use M_time , only : upper implicit none character ( len =:), allocatable :: s s = ' ABCDEFG abcdefg ' write ( * , * ) ' mixed - case input string is ... . ' , s write ( * , * ) ' upper - case output string is ... ' , upper ( s ) write ( * , * ) ' make first character uppercase ... ' , upper ( ' this is a sentence . ' , 1 , 1 ) write ( * , ' ( 1 x , a , * ( a :, \"+\" )) ' ) ' upper ( 3 f ) is elemental == > ' , upper ([ \"abc\" , \"def\" , \"ghi\" ]) end program demo_upper Expected output mixed - case input string is ... . ABCDEFG abcdefg upper - case output string is ... ABCDEFG ABCDEFG make first character uppercase ... This is a sentence . upper ( 3 f ) is elemental == > ABC + DEF + GHI AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Source Code elemental pure function upper ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_21=\"@(#)M_strings::upper(3f): Changes a string to uppercase\" character ( * ), intent ( In ) :: str ! inpout string to convert to all uppercase integer , intent ( in ), optional :: begin , end character ( len ( str )) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: ibegin , iend string = str ! initialize output string to input string ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'a' : 'z' ) ! located miniscule letter string ( i : i ) = achar ( iachar ( str ( i : i )) - 32 ) ! change miniscule letter to uppercase end select end do end function upper","tags":"","url":"proc/upper.html"},{"title":"split – M_time","text":"public  subroutine split(input_line, array, delimiters, order, nulls) NAME split(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters\n(LICENSE:PD) SYNOPSIS subroutine split(input_line,array,delimiters,order,nulls)\n\n character(len=*),intent(in)              :: input_line\n character(len=:),allocatable,intent(out) :: array(:)\n character(len=*),optional,intent(in)     :: delimiters\n character(len=*),optional,intent(in)     :: order\n character(len=*),optional,intent(in)     :: nulls DESCRIPTION SPLIT(3f) parses a string using specified delimiter characters and\n   store tokens into an allocatable array OPTIONS INPUT_LINE Input string to tokenize ARRAY Output array of tokens DELIMITERS List of delimiter characters . The default delimiters are the \"whitespace\" characters ( space , tab , new line , vertical tab , formfeed , carriage return , and null ). You may specify an alternate set of delimiter characters . Multi - character delimiters are not supported ( Each character in the DELIMITERS list is considered to be a delimiter ). Quoting of delimiter characters is not supported . ORDER SEQUENTIAL | REVERSE | RIGHT Order of output array . By default ARRAY contains the tokens having parsed the INPUT_LINE from left to right . If ORDER = 'RIGHT' or ORDER = 'REVERSE' the parsing goes from right to left . NULLS IGNORE | RETURN | IGNOREEND Treatment of null fields . By default adjacent delimiters in the input string do not create an empty string in the output array . if NULLS = 'return' adjacent delimiters create an empty element in the output ARRAY . If NULLS = 'ignoreend' then only trailing delimiters at the right of the string are ignored . EXAMPLES Sample program: program demo_split\n   use M_strings, only: split\n   character(len=*),parameter     :: &\n   & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '\n   character(len=:),allocatable :: array(:) ! output array of tokens\n      write(*,*)'INPUT LINE:['//LINE//']'\n      write(*,'(80(\"=\"))')\n      write(*,*)'typical call:'\n      CALL split(line,array)\n      write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array))\n      write(*,*)'SIZE:',SIZE(array)\n      write(*,'(80(\"-\"))')\n      write(*,*)'custom list of delimiters (colon and vertical line):'\n      CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore')\n      write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array))\n      write(*,*)'SIZE:',SIZE(array)\n      write(*,'(80(\"-\"))')\n      write(*,*)&\n      &'custom list of delimiters, reverse array order and count null fields:'\n      CALL split(line,array,delimiters=':|',order='reverse',nulls='return')\n      write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array))\n      write(*,*)'SIZE:',SIZE(array)\n      write(*,'(80(\"-\"))')\n      write(*,*)'INPUT LINE:['//LINE//']'\n      write(*,*)&\n      &'default delimiters and reverse array order and return null fields:'\n      CALL split(line,array,delimiters='',order='reverse',nulls='return')\n      write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array))\n      write(*,*)'SIZE:',SIZE(array)\n  end program demo_split Output > INPUT LINE :[ aBcdef ghijklmnop qrstuvwxyz 1 : | : 2 333 | 333 a B cc ] > =========================================================================== > typical call : > 1 ==> aBcdef > 2 ==> ghijklmnop > 3 ==> qrstuvwxyz > 4 ==> 1 : | : 2 > 5 ==> 333 | 333 > 6 ==> a > 7 ==> B > 8 ==> cc > SIZE : 8 > -------------------------------------------------------------------------- > custom list of delimiters ( colon and vertical line ) : > 1 ==> aBcdef ghijklmnop qrstuvwxyz 1 > 2 ==> 2 333 > 3 ==> 333 a B cc > SIZE : 3 > -------------------------------------------------------------------------- > custom list of delimiters , reverse array order and return null fields : > 1 ==> 333 a B cc > 2 ==> 2 333 > 3 ==> > 4 ==> > 5 ==> aBcdef ghijklmnop qrstuvwxyz 1 > SIZE : 5 > -------------------------------------------------------------------------- > INPUT LINE :[ aBcdef ghijklmnop qrstuvwxyz 1 : | : 2 333 | 333 a B cc ] > default delimiters and reverse array order and count null fields : > 1 ==> > 2 ==> > 3 ==> > 4 ==> cc > 5 ==> B > 6 ==> a > 7 ==> 333 | 333 > 8 ==> > 9 ==> > 10 ==> > 11 ==> > 12 ==> 1 : | : 2 > 13 ==> > 14 ==> qrstuvwxyz > 15 ==> ghijklmnop > 16 ==> > 17 ==> > 18 ==> aBcdef > 19 ==> > 20 ==> > SIZE : 20 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls Source Code subroutine split ( input_line , array , delimiters , order , nulls ) !----------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_7=\"& !&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array\" !  John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- intrinsic index , min , present , len !----------------------------------------------------------------------------------------------------------------------------------- !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens !----------------------------------------------------------------------------------------------------------------------------------- integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token !----------------------------------------------------------------------------------------------------------------------------------- ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters /= '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // achar ( 9 ) // achar ( 10 ) // achar ( 11 ) // achar ( 12 ) // achar ( 13 ) // achar ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // achar ( 9 ) // achar ( 10 ) // achar ( 11 ) // achar ( 12 ) // achar ( 13 ) // achar ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter !----------------------------------------------------------------------------------------------------------------------------------- n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 !----------------------------------------------------------------------------------------------------------------------------------- ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found !----------------------------------------------------------------------------------------------------------------------------------- select case ( ilen ) !----------------------------------------------------------------------------------------------------------------------------------- case (: 0 ) ! command was totally blank !----------------------------------------------------------------------------------------------------------------------------------- case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )) == 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound > 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol > ilen ) then ! no text left exit INFINITE endif enddo INFINITE !----------------------------------------------------------------------------------------------------------------------------------- end select !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select !----------------------------------------------------------------------------------------------------------------------------------- do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ) < ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo !----------------------------------------------------------------------------------------------------------------------------------- end subroutine split","tags":"","url":"proc/split.html"},{"title":"string_to_values – M_time","text":"public  subroutine string_to_values(line, iread, values, inums, delims, ierr) NAME string_to_values(3f) - [M_strings:NUMERIC] read a string representing numbers into a numeric array\n  (LICENSE:PD) SYNOPSIS subroutine string_to_values(line,iread,values,inums,delims,ierr)\n\n    character(len=*) :: line\n    integer          :: iread\n    real             :: values(*)\n    integer          :: inums\n    character(len=*) :: delims\n    integer          :: ierr DESCRIPTION This routine can take a string representing a series of numbers and\n   convert it to a numeric array and return how many numbers were found. OPTIONS LINE     Input string containing numbers\n   IREAD    maximum number of values to try to read from input string RESULTS VALUES real array to be filled with numbers INUMS number of values successfully read ( before error occurs if one does ) DELIMS delimiter character ( s ) , usually a space . must not be a null string . If more than one character , a space must not be the last character or it will be ignored . IERR error flag ( 0 = no error , else column number string starts at that error occurred on ) . EXAMPLES Sample Program: program demo_string_to_values use M_strings , only : string_to_values character ( len = 80 ) :: s = ' 10 20e3;3.45 -400.3e-2;1234; 5678 ' integer , parameter :: isz = 10 real :: array ( isz ) call string_to_values ( s , 10 , array , inums , ' ;' , ierr ) call reportit () call string_to_values ( '10;2.3;3.1416' , isz , array , inums , ' ;' , ierr ) call reportit () contains subroutine reportit () write (*,*) 'string_to_values:' write (*,*) 'input string.............' , trim ( s ) write (*,*) 'number of values found...' , inums write (*,*) 'values...................' ,( array ( ii ), ii = 1 , inums ) end subroutine reportit end program demo_string_to_values Expected output string_to_values : input string ............. 10 20e3 ; 3 . 45 -400 . 3e-2 ; 1234 ; 5678 number of values found ... 6 values ................... 10 . 0000000 20000 . 0000 3 . 45000005 -4 . 00299978 1234 . 00000 5678 . 00000 string_to_values : input string ............. 10 20e3 ; 3 . 45 -400 . 3e-2 ; 1234 ; 5678 number of values found ... 3 values ................... 10 . 0000000 2 . 29999995 3 . 14159989 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: iread real, intent(inout) :: values (iread) integer, intent(out) :: inums character(len=*), intent(in) :: delims integer, intent(out) :: ierr Source Code subroutine string_to_values ( line , iread , values , inums , delims , ierr ) !---------------------------------------------------------------------------------------------------------------------------------- !   1989,1997-12-31,2014 John S. Urban !   given a line of structure , string , string , string process each !   string as a numeric value and store into an array. !   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS. !   There is no direct checking for more values than can fit in VALUES. !   Quits if encounters any errors in read. !---------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_54=\"@(#)M_strings::string_to_values(3f): reads an array of numbers from a numeric string\" character ( len =* ), intent ( in ) :: line ! input string integer , intent ( in ) :: iread ! maximum number of values to try to read into values real , intent ( inout ) :: values ( iread ) ! real array to be filled with values integer , intent ( out ) :: inums ! number of values successfully read from string character ( len =* ), intent ( in ) :: delims ! allowed delimiters integer , intent ( out ) :: ierr ! 0 if no error, else column number undecipherable string starts at !---------------------------------------------------------------------------------------------------------------------------------- character ( len = 256 ) :: delims_local ! mutable copy of allowed delimiters integer :: istart , iend , ilen , icol integer :: i10 , i20 , i40 real :: rval integer :: ier integer :: delimiters_length !---------------------------------------------------------------------------------------------------------------------------------- delims_local = delims ! need a mutable copy of the delimiter list if ( delims_local == '' ) then ! if delimiter list is null or all spaces make it a space delims_local = ' ' ! delimiter is a single space delimiters_length = 1 ! length of delimiter list else delimiters_length = len_trim ( delims ) ! length of variable WITH TRAILING WHITESPACE TRIMMED endif !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error code returned inums = 0 ! initialize count of values successfully returned istart = 0 !---------------------------------------------------------------------------------------------------------------------------------- ilen = 0 ! ilen will be the position of the right-most non-delimiter in the input line do i20 = len ( line ), 1 , - 1 ! loop from end of string to beginning to find right-most non-delimiter if ( index ( delims_local (: delimiters_length ), line ( i20 : i20 )) == 0 ) then ! found a non-delimiter ilen = i20 exit endif enddo if ( ilen == 0 ) then ! command was totally composed of delimiters write ( stderr , gen ) '<ERROR>*string_to_values* - blank line passed as a list of numbers' return endif !---------------------------------------------------------------------------------------------------------------------------------- !     there is at least one non-delimiter sub-string !     ilen is the column position of the last non-delimiter character !     now, starting at beginning of string find next non-delimiter icol = 1 ! pointer to beginning of unprocessed part of LINE LOOP : dO i10 = 1 , iread , 1 ! each pass should find a value if ( icol > ilen ) EXIT LOOP ! everything is done INFINITE : do if ( index ( delims_local (: delimiters_length ), line ( icol : icol )) == 0 ) then ! found non-delimiter istart = icol iend = 0 ! FIND END OF SUBSTRING do i40 = istart , ilen ! look at each character starting at left if ( index ( delims_local (: delimiters_length ), line ( i40 : i40 )) /= 0 ) then ! determine if character is a delimiter iend = i40 ! found a delimiter. record where it was found EXIT ! found end of substring so leave loop endif enddo if ( iend == 0 ) iend = ilen + 1 ! no delimiters found, so this substring goes to end of line iend = iend - 1 ! do not want to pass delimiter to be converted rval = 0.0 call string_to_value ( line ( istart : iend ), rval , ier ) ! call procedure to convert string to a numeric value if ( ier == 0 ) then ! a substring was successfully converted to a numeric value values ( i10 ) = rval ! store numeric value in return array inums = inums + 1 ! increment number of values converted to a numeric value else ! an error occurred converting string to value ierr = istart ! return starting position of substring that could not be converted return endif icol = iend + 2 ! set to next character to look at CYCLE LOOP ! start looking for next value else ! this is a delimiter so keep looking for start of next string icol = icol + 1 ! increment pointer into LINE CYCLE INFINITE endif enddo INFINITE enddo LOOP !     error >>>>> more than iread numbers were in the line. end subroutine string_to_values","tags":"","url":"proc/string_to_values.html"},{"title":"substitute – M_time","text":"public  subroutine substitute(targetline, old, new, ierr, start, end) NAME substitute(3f) - [M_strings:EDITING] subroutine globally substitutes one substring for another in string\n(LICENSE:PD) SYNOPSIS subroutine substitute(targetline,old,new,ierr,start,end)\n\n character(len=*)              :: targetline\n character(len=*),intent(in)   :: old\n character(len=*),intent(in)   :: new\n integer,intent(out),optional  :: ierr\n integer,intent(in),optional   :: start\n integer,intent(in),optional   :: end DESCRIPTION Globally substitute one substring for another in string. OPTIONS TARGETLINE input line to be changed . Must be long enough to hold altered output . OLD substring to find and replace NEW replacement for OLD substring IERR error code . If IER = - 1 bad directive , >= 0 then count of changes made . START sets the left margin to be scanned for OLD in TARGETLINE . END sets the right margin to be scanned for OLD in TARGETLINE . EXAMPLES Sample Program : program demo_substitute use M_time , only : substitute implicit none ! must be long enough to hold changed line character ( len = 80 ) :: targetline targetline = ' this is the input string ' write ( * , * ) ' ORIGINAL : ' //trim(targetline) ! changes the input to ' THis is THe input string ' call substitute ( targetline , ' th ',' TH ' ) write ( * , * ) ' th => TH : ' //trim(targetline) ! a null old substring means \"at beginning of line\" ! changes the input to ' BEFORE : this is the input string ' call substitute ( targetline , ' ',' BEFORE : ' ) write ( * , * ) ' \"\" => BEFORE : ' //trim(targetline) ! a null new string deletes occurrences of the old substring ! changes the input to ' ths s the nput strng ' call substitute ( targetline , 'i' , '' ) write ( * , * ) ' i => \"\" : ' //trim(targetline) end program demo_substitute Expected output ORIGINAL : this is the input string th => TH : THis is THe input string \"\" => BEFORE : BEFORE : THis is THe input string i => \"\" : BEFORE : THs s THe nput strng AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*) :: targetline character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(out), optional :: ierr integer, intent(in), optional :: start integer, intent(in), optional :: end Source Code subroutine substitute ( targetline , old , new , ierr , start , end ) !character(len=*),parameter::ident_11=\"@(#)M_strings::substitute(3f): Globally substitute one substring for another in string\" !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ) :: targetline ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made integer , intent ( in ), optional :: start ! start sets the left margin integer , intent ( in ), optional :: end ! end sets the right margin !----------------------------------------------------------------------------------------------------------------------------------- character ( len = len ( targetline )) :: dum1 ! scratch string buffers integer :: ml , mr , ier1 integer :: maxlengthout ! MAXIMUM LENGTH ALLOWED FOR NEW STRING integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: ir integer :: ind integer :: il integer :: id integer :: ic integer :: ichar !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( start )) then ! optional starting column ml = start else ml = 1 endif if ( present ( end )) then ! optional ending column mr = end else mr = len ( targetline ) endif !----------------------------------------------------------------------------------------------------------------------------------- ier1 = 0 ! initialize error flag/change count maxlengthout = len ( targetline ) ! max length of output string original_input_length = len_trim ( targetline ) ! get non-blank length of input line dum1 (:) = ' ' ! initialize string to build output in id = mr - ml ! check for window option !x! change to optional parameter(s) !----------------------------------------------------------------------------------------------------------------------------------- len_old = len ( old ) ! length of old substring to be replaced len_new = len ( new ) ! length of new substring to replace old substring if ( id <= 0 ) then ! no window so change entire input string il = 1 ! il is left margin of window to change ir = maxlengthout ! ir is right margin of window to change dum1 (:) = ' ' ! begin with a blank line else ! if window is set il = ml ! use left margin ir = min0 ( mr , maxlengthout ) ! use right margin or rightmost dum1 = targetline (: il - 1 ) ! begin with what's below margin endif ! end of window settings !----------------------------------------------------------------------------------------------------------------------------------- if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichar = len_new + original_input_length if ( ichar > maxlengthout ) then write ( stderr , gen ) '<ERROR>*substitute* - new line will be too long' ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( len_new > 0 ) then dum1 ( il :) = new (: len_new ) // targetline ( il : original_input_length ) else dum1 ( il :) = targetline ( il : original_input_length ) endif targetline ( 1 : maxlengthout ) = dum1 (: maxlengthout ) ier1 = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ier1 return endif !----------------------------------------------------------------------------------------------------------------------------------- ichar = il ! place to put characters into output string ic = il ! place looking at in input string loop : do ind = index ( targetline ( ic :), old (: len_old )) + ic - 1 ! try to find start of old string in remaining part of input in change window if ( ind == ic - 1. or . ind > ir ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif ier1 = ier1 + 1 ! found an old string to change, so increment count of changes if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output if ( ichar - 1 + ladd > maxlengthout ) then ier1 =- 1 exit loop endif dum1 ( ichar :) = targetline ( ic : ind - 1 ) ichar = ichar + ladd endif if ( ichar - 1 + len_new > maxlengthout ) then ier1 =- 2 exit loop endif if ( len_new /= 0 ) then dum1 ( ichar :) = new (: len_new ) ichar = ichar + len_new endif ic = ind + len_old enddo loop !----------------------------------------------------------------------------------------------------------------------------------- select case ( ier1 ) case (: - 1 ) write ( stderr , gen ) '<ERROR>*substitute* - new line will be too long' case ( 0 ) ! there were no changes made to the window case default ladd = original_input_length - ic if ( ichar + ladd > maxlengthout ) then write ( stderr , gen ) '<ERROR>*substitute* - new line will be too long' ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( ic < len ( targetline )) then dum1 ( ichar :) = targetline ( ic : max ( ic , original_input_length )) endif targetline = dum1 (: maxlengthout ) end select if ( present ( ierr )) ierr = ier1 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine substitute","tags":"","url":"proc/substitute.html"},{"title":"string_to_value – M_time","text":"public interface string_to_value Module Procedures private  subroutine a2d(chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns doubleprecision value from string doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr private  subroutine a2r(chars, valu, ierr) NAME string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric value from string\n  (LICENSE:PD) SYNOPSIS subroutine string_to_value(chars,valu,ierr)\n\n character(len=*),intent(in)              :: chars   ! input string\n integer|real|doubleprecision,intent(out) :: valu\n integer,intent(out)                      :: ierr DESCRIPTION returns a numeric value from a numeric character string. works with any g-format input, including integer, real, and\n   exponential. If the input string begins with “B”, “Z”, or “O”\n   and otherwise represents a positive whole number it is assumed to\n   be a binary, hexadecimal, or octal value. If the string contains\n   commas they are removed. If the string is of the form NN:MMM… or\n   NN#MMM then NN is assumed to be the base of the whole number. if an error occurs in the READ, IOSTAT is returned in IERR and\n   value is set to zero. if no error occurs, IERR=0. OPTIONS CHARS  input string to read numeric value from RETURNS VALU   numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION.\n   IERR   error flag (0 == no error) EXAMPLES Sample Program:\n\n program demo_string_to_value\n use M_strings, only: string_to_value\n character(len=80) :: string\n    string=' -40.5e-2 '\n    call string_to_value(string,value,ierr)\n    write(*,*) 'value of string ['//trim(string)//'] is ',value\n end program demo_string_to_value AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns real value from string real, intent(out) :: valu integer, intent(out) :: ierr private  subroutine a2i(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns integer value from string integer, intent(out) :: valu integer, intent(out) :: ierr","tags":"","url":"interface/string_to_value.html"},{"title":"v2s – M_time","text":"public interface v2s Module Procedures private  function d2s(dvalue, fmt) result(outstr) NAME v2s(3f) - [M_strings:NUMERIC] return numeric string from a numeric value\n  (LICENSE:PD) SYNOPSIS function v2s(value) result ( outstr ) integer | real | doubleprecision | logical , intent ( in ) :: value character ( len =:), allocatable :: outstr character ( len = * ), optional , intent ( in ) :: fmt DESCRIPTION v2s(3f) returns a representation of a numeric value as a\n   string when given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the strings using internal WRITE()\n   statements. Trailing zeros are removed from non-zero values, and the\n   string is left-justified. OPTIONS VALUE   input value to be converted to a string\nFMT     format can be explicitly given, but is limited to\n        generating a string of eighty or less characters. RETURNS OUTSTR  returned string representing input value, EXAMPLES Sample Program : program demo_v2s use M_strings , only : v2s write ( * , * ) 'The value of 3.0/4.0 is [' // v2s ( 3.0 / 4.0 ) // ']' write ( * , * ) 'The value of 1234    is [' // v2s ( 1234 ) // ']' write ( * , * ) 'The value of 0d0     is [' // v2s ( 0 d0 ) // ']' write ( * , * ) 'The value of .false. is [' // v2s (. false .) // ']' write ( * , * ) 'The value of .true. is  [' // v2s (. true .) // ']' end program demo_v2s Expected output The value of 3.0 / 4.0 is [ 0.75 ] The value of 1234 is [ 1234 ] The value of 0 d0 is [ 0 ] The value of . false . is [ F ] The value of . true . is [ T ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function r2s(rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function i2s(ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function l2s(lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable","tags":"","url":"interface/v2s.html"},{"title":"date_time – M_time","text":"public interface date_time Module Procedures private  function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (:) Return Value type( date_time )","tags":"","url":"interface/date_time.html"},{"title":"M_time__duplicate – M_time","text":"Uses iso_fortran_env Interfaces public        interface string_to_value private  subroutine a2d(chars, valu, ierr, onerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns doubleprecision value from string doubleprecision, intent(out) :: valu integer, intent(out) :: ierr class(*), intent(in), optional :: onerr private  subroutine a2r(chars, valu, ierr) NAME string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric value from string\n  (LICENSE:PD) SYNOPSIS subroutine string_to_value(chars,valu,ierr)\n\n character(len=*),intent(in)              :: chars   ! input string\n integer|real|doubleprecision,intent(out) :: valu\n integer,intent(out)                      :: ierr DESCRIPTION returns a numeric value from a numeric character string. works with any g-format input, including integer, real, and\n   exponential. If the input string begins with “B”, “Z”, or “O”\n   and otherwise represents a positive whole number it is assumed to\n   be a binary, hexadecimal, or octal value. If the string contains\n   commas they are removed. If the string is of the form NN:MMM… or\n   NN#MMM then NN is assumed to be the base of the whole number. if an error occurs in the READ, IOSTAT is returned in IERR and\n   value is set to zero. if no error occurs, IERR=0. OPTIONS CHARS  input string to read numeric value from RETURNS VALU   numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION.\n   IERR   error flag (0 == no error) EXAMPLES Sample Program:\n\n program demo_string_to_value\n use M_strings, only: string_to_value\n character(len=80) :: string\n    string=' -40.5e-2 '\n    call string_to_value(string,value,ierr)\n    write(*,*) 'value of string ['//trim(string)//'] is ',value\n end program demo_string_to_value AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns real value from string real, intent(out) :: valu integer, intent(out) :: ierr private  subroutine a2i(chars, valu, ierr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars subroutine returns integer value from string integer, intent(out) :: valu integer, intent(out) :: ierr public        interface v2s private  function d2s(dvalue, fmt) result(outstr) NAME v2s(3f) - [M_strings:NUMERIC] return numeric string from a numeric value\n  (LICENSE:PD) SYNOPSIS function v2s(value) result ( outstr ) integer | real | doubleprecision | logical , intent ( in ) :: value character ( len =:), allocatable :: outstr character ( len = * ), optional , intent ( in ) :: fmt DESCRIPTION v2s(3f) returns a representation of a numeric value as a\n   string when given a numeric value of type REAL, DOUBLEPRECISION,\n   INTEGER or LOGICAL. It creates the strings using internal WRITE()\n   statements. Trailing zeros are removed from non-zero values, and the\n   string is left-justified. OPTIONS VALUE   input value to be converted to a string\nFMT     format can be explicitly given, but is limited to\n        generating a string of eighty or less characters. RETURNS OUTSTR  returned string representing input value, EXAMPLES Sample Program : program demo_v2s use M_strings , only : v2s write ( * , * ) 'The value of 3.0/4.0 is [' // v2s ( 3.0 / 4.0 ) // ']' write ( * , * ) 'The value of 1234    is [' // v2s ( 1234 ) // ']' write ( * , * ) 'The value of 0d0     is [' // v2s ( 0 d0 ) // ']' write ( * , * ) 'The value of .false. is [' // v2s (. false .) // ']' write ( * , * ) 'The value of .true. is  [' // v2s (. true .) // ']' end program demo_v2s Expected output The value of 3.0 / 4.0 is [ 0.75 ] The value of 1234 is [ 1234 ] The value of 0 d0 is [ 0 ] The value of . false . is [ F ] The value of . true . is [ T ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: dvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function r2s(rvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name real, intent(in) :: rvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function i2s(ivalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ivalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private  function l2s(lvalue, fmt) result(outstr) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lvalue character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable Functions public pure function adjustc (string, length) pure function adjustc(string[,length]) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string PROCEDURE   adjustc(3f)\n DESCRIPTION center text using implicit or explicit length Read more… integer, intent(in), optional :: length Return Value character(len=:), allocatable public  function compact (str, char) result(outstr) COMPACT(3f) converts multiple spaces, tabs and control characters\n   (called “whitespace”) to a single character or nothing. Leading\n   whitespace is removed. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(in), optional :: char Return Value character(len=len) public pure elemental function lower (str, begin, end) result(string) lower(string) returns a copy of the input string with all characters\n   converted to miniscule over the specified range, assuming ASCII\n   character sets are being used. If no range is specified the entire\n   string is converted to miniscule. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) public  function s2v (chars, ierr, onerr) This function converts a string to a DOUBLEPRECISION numeric value. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, optional :: ierr class(*), intent(in), optional :: onerr Return Value doubleprecision public pure function transliterate (instr, old_set, new_set) result(outstr) Translate, squeeze, and/or delete characters from the input string. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value character(len=LEN) public pure elemental function upper (str, begin, end) result(string) upper(3f) - [M_strings:CASE] changes a string to uppercase\n (LICENSE:PD) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in), optional :: begin integer, intent(in), optional :: end Return Value character(len=len(str)) Subroutines public  subroutine split (input_line, array, delimiters, order, nulls) SPLIT(3f) parses a string using specified delimiter characters and\n   store tokens into an allocatable array Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_line character(len=:), intent(out), allocatable :: array (:) character(len=*), intent(in), optional :: delimiters character(len=*), intent(in), optional :: order character(len=*), intent(in), optional :: nulls public  subroutine string_to_values (line, iread, values, inums, delims, ierr) This routine can take a string representing a series of numbers and\n   convert it to a numeric array and return how many numbers were found. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line integer, intent(in) :: iread real, intent(inout) :: values (iread) integer, intent(out) :: inums character(len=*), intent(in) :: delims integer, intent(out) :: ierr public  subroutine substitute (targetline, old, new, ierr, start, end) Globally substitute one substring for another in string. Read more… Arguments Type Intent Optional Attributes Name character(len=*) :: targetline character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(out), optional :: ierr integer, intent(in), optional :: start integer, intent(in), optional :: end","tags":"","url":"module/m_time__duplicate.html"},{"title":"M_time__oop – M_time","text":"NAME M_time__oop(3fm) - [M_time::INTRO::OOPS] OOP interface for M_time(3fm)\n(LICENSE:MIT) SYNOPSIS use M_time__oop, only : date_time\n   ! the type includes the following operators:\n   !    operator(+)\n   !    operator(-)\n   !    operator(>)\n   !    operator(<)\n   !    operator(<=)\n   !    operator(>=)\n   !    operator(==)\n   !    operator(/=) TYPE ( date_time ) :: mydate mydate % year mydate % month mydate % day mydate % tz mydate % hour mydate % minute mydate % second mydate % millisecond call mydate %init () mydate % format ( '' ) mydate % ordinal () mydate % weekday () mydate % epoch () mydate % julian () mydate % mjd () dat = mydate % datout () mydate % delta ( year = NN , month = NN , day = NN , tz = NN , hour = NN , minute = NN , second = NN , millisecond = NN , week = NN , duration = ' DD - HH : MM : SS . XX ' ) DESCRIPTION An object-oriented interface to the M_time module. The following\nexample program demonstrates and documents the interface EXAMPLES sample program program demo_M_time__oop ! ! This is an example using the object - oriented class / type model ! This is essentially the same functionality as the procedures ! in the procedural module M_time ( 3f m ), but allows for Object ! Oriented syntax : ! use M_time__oop , only : date_time ! The type includes the operators ... ! operator ( + ) ! operator ( - ) ! operator ( > ) ! operator ( < ) ! operator ( <= ) ! operator ( >= ) ! operator ( == ) ! operator ( /= ) implicit none integer , parameter :: dp = kind ( 0.0 d0 ) integer :: dat ( 8 ) TYPE ( date_time ) :: event TYPE ( date_time ) :: otherdate TYPE ( date_time ) :: answer character ( len =* ), parameter :: iso_fmt = ' % Y -% M -% DT % h :% m :% s . % x % z ' ! DIFFERENT INITIALIZATION STYLES ! ( Still debating on how best to do this ) write ( * , * ) write ( * , ' ( a ) ')' Various initialization styles ' ! DEFINE type ( date_time ) WITH CONSTRUCTOR otherdate = date_time () print * , ' DEFAULT CONSTRUCTOR % format () ' , & & otherdate % format () print * , ' DEFAULT CONSTRUCTOR % format ( \"\" ) ' , & & otherdate % format ( \"\" ) print * , ' DEFAULT CONSTRUCTOR % format ( user - specified ) ' , & & otherdate % format ( iso_fmt ) print * , ' DEFAULT CONSTRUCTOR % format ( \"USA\" ) ' , & & otherdate % format ( \"USA\" ) otherdate = date_time ( 1492 , 10 , 12 , 0 , 0 , 0 , 0 , 0 ) print * , ' DEFAULT CONSTRUCTOR setting values ' , & & otherdate % format () otherdate = date_time ( 2016 , 6 , 11 ) print * , ' DEFAULT CONSTRUCTOR with partial values ' , & & otherdate % format () otherdate = date_time ( year = 2016 , month = 6 , day = 11 , tz = -240 , & & hour = 21 , minute = 09 , second = 11 , millisecond = 500 ) print * , ' DEFAULT CONSTRUCTOR with values by name ' , & & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 , 0 , 0 , 0 , 0 , 0 ]) print * , ' CONSTRUCTOR with a dat array ' , & & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 ]) print * , ' CONSTRUCTOR with a partial dat array ' , & & otherdate % format () ! the init () method supports several methods ! initialize to current time using INIT call otherdate %init () ! initialize to current time using INIT call otherdate %init ( type = \"now\" ) ! initialize to beginning of Unix Epoch Time call otherdate %init ( type = \"epoch\" ) ! Note ! currently , DATE_TIME DATE array is set to Unix Epoch ! start USING LOCAL TIMEZONE ! whereas default constructor is using default of Unix Epoch ! start using Z time ( GMT or UTC time ) ! initialize with a DAT array using INIT , ! compatible with DATE_AND_TIME VALUES ( 8 ) call otherdate %init ( dat = [1970,1,1,0,0,0,0,0] ) ! using INIT with ordered values call otherdate %init ( 2016 , 6 , 11 , -300 , 23 , 1 , 0 , 0 ) ! using INIT with names call otherdate %init ( year = 2016,month=6,day=11,&\n    & tz=-300,hour=23,minute=1,second=0,millisecond=0 ) ! ! take current date and exercise the OOP interface ! initialize to current time using INIT call event %init () write ( * , * ) write ( * , * ) ' Print members of type ( DATE_TIME ) ' ! show derived type write ( * , 404 ) ' EVENT = ' , event 404 format ( 1 x , a , i0 , * ( \",\" , i0 : )) ! MEMBERS ( basic time values are all integers ) ! print members of type write ( * , 101 ) ' % year Year ................... ' , event % year write ( * , 101 ) ' % month Month .................. ' , event % month write ( * , 101 ) ' % day Day .................... ' , event % day write ( * , 101 ) ' % tz Timezone ............... ' , event % tz write ( * , 101 ) ' % hour Hour ................... ' , event % hour write ( * , 101 ) ' % minute Minute ................. ' , event % minute write ( * , 101 ) ' % second Second ................. ' , event % second write ( * , 101 ) ' % millisecond Millisecond ............ ' , event % millisecond ! PRINT METHODS OF TYPE write ( * , * ) ' Print methods of type ( DATE_TIME ) ' write ( * , 101 ) ' % ordinal Ordinal day of year .... ' , event % ordinal () write ( * , 101 ) ' % weekday Weekday ................ ' , event % weekday () 101 format ( 1 x , a , i0 ) ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY write ( * , 202 ) ' % epoch Unix epoch time ........ ' , event % epoch () write ( * , 202 ) ' % julian Julian date ............ ' , event % julian () write ( * , 202 ) ' % mjd Modiied Julian date .... ' , event % mjd () 202 format ( 1 x , a , g0 ) ! FORMATTED STRINGS ( many strings possible . ! Takes the same format string as fmtdate ( 3f )) write ( * , * ) write ( * , ' ( a ) ')' Formatted Strings ( % format ( \"STRING\" ) & & -- see fmtdate ( 3f ) for format descriptions ' ! abbreviated month name % l Dec write ( * , 303 ) ' Short month ............ ' , & & event % format ( \"%l\" ) ! ! full month name % L December write ( * , 303 ) ' Month .................. ' , & & event % format ( \"%L\" ) ! ! first three characters of weekday % w Sat write ( * , 303 ) ' Short week ............. ' , & & event % format ( \"%w\" ) ! ! weekday name % W Saturday write ( * , 303 ) ' Week .................. ' , & & event % format ( \"%W\" ) ! ! with no percent ( % ) characters write ( * , 303 ) ' Calendar Time ......... ' , & & event % format ( \"Y-M-D h:m:s.x z\" ) ! ! keywords with no percent ( % ) characters write ( * , 303 ) ' Calendar Time ......... ' , & & event % format ( ' \"year-month-day & & hour : minute : second . millisecond timezone \"') ! write ( * , * ) event % format ( ' Longer format .......... & & \"%W, %L %d, %Y %H:%m:%s %N\" ' ) ! a nice friendly format ! 303 format ( 1 x , a , '\"' , a , '\"' ) ! convert date_time to integer array ! ( maybe to use with module M_TIME base procedures ) dat = event % datout () write ( * , * ) write ( * , 404 ) ' DAT = ' , dat ! OVERLOADED OPERATORS ( add and subtract ) ! a date_time object can have seconds added answer = event + 1 * 86400.0 _dp ! ! a nice friendly format write ( * , * ) answer % format ( ' TOMORROW = \"%W, %L %d, %Y %H:%m:%s %N\" ' ) ! ! a date_time object can have seconds subtracted answer = event -1 * 86400.0 _dp ! a nice friendly format write ( * , * ) answer % format ( ' YESTERDAY = \"%W, %L %d, %Y %H:%m:%s %N\" ' ) ! ! if both operands are DATE_TIME objects a subtraction ! finds the time in seconds between the two dates write ( * , * ) ' DIFFERENCE ( subtracting one date_time from another ) = ' , & & answer - event ! OVERLOADED OPERATORS ( logical comparisons ) ! NOTE COMPARISONS ARE PERFORMED BY ! CONVERTING TIMES TO INTEGER SECONDS write ( * , * ) ' > ' , event == event , event < event , event > event & & , event <= event , event >= event , event /= event ! write ( * , * ) ' > ' , event == answer , event < answer , event > answer & & , event <= answer , event >= answer , event /= answer ! write ( * , * ) ' > ' , answer == event , answer < event , answer > event & & , answer <= event , answer >= event , answer /= event ! % DELTA easily lets you change dates by common increments write ( * , * ) write ( * , 404 ) ' % DELTA tests starting with date ' , event % delta () ! write ( * , * ) event % format ( \"                             & &% W , % L % d , % Y % H :% m :% s % N \") write ( * , * ) ' Remember years and months are not constant units ' answer = event % delta ( year = 1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = -1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( month = 24 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( month = -24 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( week = 1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( week = -1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( day = 1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( day = -1 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = 4 ) write ( * , * ) answer % format ( & ! & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = -4 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( minute = 180 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( minute = -180 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( second = 1800 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( second = -1800 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( millisecond = 10000 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( millisecond = -10000 ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = 3 , month = 2 , day = 100 , hour = 200 , & & week = -1 , minute = 300 , second = 1000 , millisecond = -10000 ) write ( * , * ) answer % format ( & ! & \"FOR %%DELTA(year=3,month=2,day=100,hour=200,& & week = -1 , minute = 300 , second = 1000 , millisecond = 100000 ) & & % W , % L % d , % Y % H :% m :% s % N \") answer = event % delta ( duration = \"1-20:30:40.50\" ) write ( * , * ) answer % format ( & & \"FOR %%DELTA(DURATION='1-20:30:40.50')& & % W , % L % d , % Y % H :% m :% s % N \") end program demo_M_time__oop Sample output: Various initialization styes\n   DEFAULT CONSTRUCTOR %format()               1970-01-01T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR %format(“”)             1970-01-01T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR %format(user-specified) 1970-01-01T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR %format(“USA”)   Thursday, January 1st, 1970 12:00:00 AM\n   DEFAULT CONSTRUCTOR setting values          1492-10-12T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR with partial values     2016-06-11T00:00:00.000+00:00\n   DEFAULT CONSTRUCTOR with values by name     2016-06-11T21:09:11.500-04:00\n   CONSTRUCTOR with a dat array                1776-07-04T00:00:00.000+00:00\n   CONSTRUCTOR with a partial dat array        1776-07-04T20:00:00.000-04:00 Print members of type(DATE_TIME)\n   EVENT=2020,10,24,-240,21,49,54,105\n   %year        Year................... 2020\n   %month       Month.................. 10\n   %day         Day.................... 24\n   %tz          Timezone............... -240\n   %hour        Hour................... 21\n   %minute      Minute................. 49\n   %second      Second................. 54\n   %millisecond Millisecond............ 105\n   Print methods of type(DATE_TIME)\n   %ordinal     Ordinal day of year.... 298\n   %weekday     Weekday................ 6\n   %epoch      Unix epoch time........ 1603590594.1049695\n   %julian     Julian date............ 2459147.5763206594\n   %mjd        Modified Julian date… 59147.9763206594 Formatted Strings (%format(“STRING”)\n   – see fmtdate(3f) for format descriptions\n   Short month............ “Oct”\n   Month.................. “October”\n   Short week............. “Sat”\n   Week .................. “Saturday”\n   Calendar Time ......... “2020-10-24 21:49:54.105 -04:00”\n   Calendar Time ......... “”2020-10-24 21:49:54.105 -0400””\n   Longer format.......... “Saturday, October 24th, 2020 9:49:54 PM” DAT=2020,10,24,-240,21,49,54,105\n   TOMORROW=”Sunday, October 25th, 2020 9:49:54 PM”\n   YESTERDAY=”Friday, October 23rd, 2020 9:49:54 PM”\n   DIFFERENCE (subtracting one date_time from another)=  -86400.000000000000 T F F T T F\n F F T F T T\n F T F T F T %DELTA tests starting with date 2020,10,24,-240,21,49,54,105\n                                Saturday, October 24th, 2020 9:49:54 PM\n   Remember years and months are not constant units\n   FOR %DELTA(YEAR=+1)            Sunday, October 24th, 2021 9:49:54 PM\n   FOR %DELTA(YEAR=-1)            Thursday, October 24th, 2019 9:49:54 PM\n   FOR %DELTA(MONTH=+24)          Wednesday, October 26th, 2022 9:49:54 PM\n   FOR %DELTA(MONTH=-24)          Wednesday, October 24th, 2018 9:49:54 PM\n   FOR %DELTA(WEEK=+1)            Saturday, October 31st, 2020 9:49:54 PM\n   FOR %DELTA(WEEK=-1)            Saturday, October 17th, 2020 9:49:54 PM\n   FOR %DELTA(DAY=+1)             Sunday, October 25th, 2020 9:49:54 PM\n   FOR %DELTA(DAY=-1)             Friday, October 23rd, 2020 9:49:54 PM\n   FOR %DELTA(HOUR=+4)            Sunday, October 25th, 2020 1:49:54 AM\n   FOR %DELTA(HOUR=-4)            Saturday, October 24th, 2020 5:49:54 PM\n   FOR %DELTA(MINUTE=+180)        Sunday, October 25th, 2020 12:49:54 AM\n   FOR %DELTA(MINUTE=-180)        Saturday, October 24th, 2020 6:49:54 PM\n   FOR %DELTA(SECOND=+1800)       Saturday, October 24th, 2020 10:19:54 PM\n   FOR %DELTA(SECOND=-1800)       Saturday, October 24th, 2020 9:19:54 PM\n   FOR %DELTA(MILLISECOND=+10000) Saturday, October 24th, 2020 9:50:04 PM\n   FOR %DELTA(MILLISECOND=-10000) Saturday, October 24th, 2020 9:49:44 PM\n   FOR %DELTA(year=3,month=2,day=100,hour=200,week=-1,minute=300,\n   second=1000,millisecond=100000) Thursday, April 4th, 2024 11:06:24 AM\n   FOR %DELTA(DURATION=‘1-20:30:40.50’) Monday, October 26th, 2020 6:20:34 PM AUTHOR John S. Urban, 2015 LICENSE MIT submodule (M_time) M_time__oop\nend submodule M_time__oop Uses M_time M_time__duplicate Variables Type Visibility Attributes Name Initial integer, public, parameter :: dp = kind(0.0d0) Interfaces public        interface date_time private  function construct_from_dat(dat) Arguments Type Intent Optional Attributes Name integer, intent(in) :: dat (:) Return Value type( date_time ) Derived Types type, public :: date_time Components Type Visibility Attributes Name Initial integer, public :: day = 1 integer, public :: hour = 0 integer, public :: millisecond = 0 integer, public :: minute = 0 integer, public :: month = 1 integer, public :: second = 0 integer, public :: tz = 0 integer, public :: year = 1970 Constructor private\n\n                    \n                    function construct_from_dat (dat) Type-Bound Procedures procedure, public :: datout => dt2d_ procedure, public :: delta procedure, public :: epoch => epoch_ procedure, public :: format procedure, public :: init => init_dt procedure, public :: julian => julian_ procedure, public :: mjd => mjd_ generic, public :: operator(+) => plus_seconds generic, public :: operator(-) => minus_seconds generic, public :: operator(-) => minus_date_time generic, public :: operator(/=) => ne generic, public :: operator(<) => lt generic, public :: operator(<=) => le generic, public :: operator(==) => eq generic, public :: operator(>) => gt generic, public :: operator(>=) => ge procedure, public :: ordinal procedure, public :: weekday","tags":"","url":"module/m_time__oop.html"},{"title":"demo_dow – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) character(len=9) :: day integer :: ierr integer :: weekday Source Code program demo_dow use M_time , only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) call dow ( dat , weekday , day , ierr ) write ( * , '(a,i0)' ) 'weekday=' , weekday write ( * , '(a,a)' ) 'day=' , trim ( day ) write ( * , '(a,i0)' ) 'ierr=' , ierr end program demo_dow","tags":"","url":"program/demo_dow.html"},{"title":"demo_date_to_bas – M_time","text":"Uses M_time Variables Type Attributes Name Initial type(BAStime) :: bas integer :: dat (8) character(len=*), parameter :: g = '(*(g0,1x))' integer :: ierr real(kind=realtime) :: juliandate Source Code program demo_date_to_bas use M_time , only : date_to_bas , realtime , BAStime use M_time , only : date_to_julian implicit none integer :: dat ( 8 ) type ( BAStime ) :: bas real ( kind = realtime ) :: juliandate integer :: ierr character ( len =* ), parameter :: g = '(*(g0,1x))' ! write ( * , g ) 'date_to_bas:' ! generate DAT array call date_and_time ( values = dat ) ! ! show DAT array write ( * , '(\"Today is:\",*(i0:,\":\"))' ) dat ! ! convert DAT to Julian call date_to_julian ( dat , juliandate , ierr ) ! show as Modified Julian Date write ( * , g ) 'Expecting Modified Julian Date:' , & & juliandate - 240000 0.5_realtime ! ! convert DAT to BAS call date_to_bas ( dat , bas , ierr ) write ( * , g ) 'Baseday and Seconds is ' , bas write ( * , g ) 'converted to Modified Julian Date:' , & & bas % base_day + bas % secs / 8640 0.0d0 end program demo_date_to_bas","tags":"","url":"program/demo_date_to_bas.html"},{"title":"demo_date_to_julian – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer :: ierr real(kind=realtime) :: juliandate Source Code program demo_date_to_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: juliandate integer :: ierr ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , * ) 'Julian Date is ' , juliandate write ( * , * ) 'ierr is ' , ierr end program demo_date_to_julian","tags":"","url":"program/demo_date_to_julian.html"},{"title":"demo_d2o – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2o use M_time , only : d2o implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Day of year is:' , d2o ( dat ) ! year,month,day,timezone,hour,minute,seconds,milliseconds dat = [ 2020 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2021 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2022 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2023 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2024 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) end program demo_d2o","tags":"","url":"program/demo_d2o.html"},{"title":"demo_M_time__oop – M_time","text":"Uses M_time__oop Variables Type Attributes Name Initial type( date_time ) :: answer integer :: dat (8) integer, parameter :: dp = kind(0.0d0) type( date_time ) :: event character(len=*), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' type( date_time ) :: otherdate Source Code program demo_M_time__oop ! ! This is an example using the object-oriented class/type model ! This is essentially the same functionality as the procedures ! in the procedural module M_time(3fm), but allows for Object ! Oriented syntax: ! use M_time__oop , only : date_time ! The type includes the operators ... !  operator(+) !  operator(-) !  operator(>) !  operator(<) !  operator(<=) !  operator(>=) !  operator(==) !  operator(/=) implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer :: dat ( 8 ) TYPE ( date_time ) :: event TYPE ( date_time ) :: otherdate TYPE ( date_time ) :: answer character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' ! DIFFERENT INITIALIZATION STYLES ! (Still debating on how best to do this) write ( * , * ) write ( * , '(a)' ) 'Various initialization styles' ! DEFINE type(date_time) WITH CONSTRUCTOR otherdate = date_time () print * , 'DEFAULT CONSTRUCTOR %format()               ' ,& & otherdate % format () print * , 'DEFAULT CONSTRUCTOR %format(\"\")             ' ,& & otherdate % format ( \"\" ) print * , 'DEFAULT CONSTRUCTOR %format(user-specified) ' ,& & otherdate % format ( iso_fmt ) print * , 'DEFAULT CONSTRUCTOR %format(\"USA\")          ' ,& & otherdate % format ( \"USA\" ) otherdate = date_time ( 1492 , 10 , 12 , 0 , 0 , 0 , 0 , 0 ) print * , 'DEFAULT CONSTRUCTOR setting values          ' ,& & otherdate % format () otherdate = date_time ( 2016 , 6 , 11 ) print * , 'DEFAULT CONSTRUCTOR with partial values     ' ,& & otherdate % format () otherdate = date_time ( year = 2016 , month = 6 , day = 11 , tz =- 240 ,& & hour = 21 , minute = 09 , second = 11 , millisecond = 500 ) print * , 'DEFAULT CONSTRUCTOR with values by name     ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 , 0 , 0 , 0 , 0 , 0 ]) print * , 'CONSTRUCTOR with a dat array                ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 ]) print * , 'CONSTRUCTOR with a partial dat array        ' ,& & otherdate % format () ! the init() method supports several methods ! initialize to current time using INIT call otherdate % init () ! initialize to current time using INIT call otherdate % init ( type = \"now\" ) ! initialize to beginning of Unix Epoch Time call otherdate % init ( type = \"epoch\" ) ! Note ! currently, DATE_TIME DATE array is set to Unix Epoch ! start USING LOCAL TIMEZONE ! whereas default constructor is using default of Unix Epoch ! start using Z time (GMT or UTC time) ! initialize with a DAT array using INIT, ! compatible with DATE_AND_TIME VALUES(8) call otherdate % init ( dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) ! using INIT with ordered values call otherdate % init ( 2016 , 6 , 11 , - 300 , 23 , 1 , 0 , 0 ) ! using INIT with names call otherdate % init ( year = 2016 , month = 6 , day = 11 ,& & tz =- 300 , hour = 23 , minute = 1 , second = 0 , millisecond = 0 ) ! ! take current date and exercise the OOP interface ! initialize to current time using INIT call event % init () write ( * , * ) write ( * , * ) 'Print members of type(DATE_TIME)' ! show derived type write ( * , 404 ) 'EVENT=' , event 404 format ( 1 x , a , i0 , * ( \",\" , i0 :)) ! MEMBERS ( basic time values are all integers) ! print members of type write ( * , 101 ) '%year        Year................... ' , event % year write ( * , 101 ) '%month       Month.................. ' , event % month write ( * , 101 ) '%day         Day.................... ' , event % day write ( * , 101 ) '%tz          Timezone............... ' , event % tz write ( * , 101 ) '%hour        Hour................... ' , event % hour write ( * , 101 ) '%minute      Minute................. ' , event % minute write ( * , 101 ) '%second      Second................. ' , event % second write ( * , 101 ) '%millisecond Millisecond............ ' , event % millisecond ! PRINT METHODS OF TYPE write ( * , * ) 'Print methods of type(DATE_TIME)' write ( * , 101 ) '%ordinal     Ordinal day of year.... ' , event % ordinal () write ( * , 101 ) '%weekday     Weekday................ ' , event % weekday () 101 format ( 1 x , a , i0 ) ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY write ( * , 202 ) '%epoch      Unix epoch time........ ' , event % epoch () write ( * , 202 ) '%julian     Julian date............ ' , event % julian () write ( * , 202 ) '%mjd        Modiied Julian date.... ' , event % mjd () 202 format ( 1 x , a , g0 ) ! FORMATTED STRINGS (many strings possible. ! Takes the same format string as fmtdate(3f)) write ( * , * ) write ( * , '(a)' ) ' Formatted Strings (%format(\"STRING\") & & -- see fmtdate(3f) for format descriptions' ! abbreviated month name             %l  Dec write ( * , 303 ) 'Short month............ ' ,& & event % format ( \"%l\" ) ! ! full month name                    %L  December write ( * , 303 ) 'Month.................. ' ,& & event % format ( \"%L\" ) ! ! first three characters of weekday  %w  Sat write ( * , 303 ) 'Short week............. ' ,& & event % format ( \"%w\" ) ! ! weekday name                       %W  Saturday write ( * , 303 ) 'Week .................. ' ,& & event % format ( \"%W\" ) ! ! with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( \"Y-M-D h:m:s.x z\" ) ! ! keywords with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( '\"year-month-day & & hour:minute:second.millisecond timezone\"' ) ! write ( * , * ) event % format ( 'Longer format.......... & &\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! a nice friendly format ! 303 format ( 1 x , a , '\"' , a , '\"' ) ! convert date_time to integer array ! (maybe to use with module M_TIME base procedures) dat = event % datout () write ( * , * ) write ( * , 404 ) 'DAT=' , dat ! OVERLOADED OPERATORS (add and subtract) ! a date_time object can have seconds added answer = event + 1 * 8640 0.0_dp ! ! a nice friendly format write ( * , * ) answer % format ( 'TOMORROW=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! a date_time object can have seconds subtracted answer = event - 1 * 8640 0.0_dp ! a nice friendly format write ( * , * ) answer % format ( 'YESTERDAY=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! if both operands are DATE_TIME objects a subtraction ! finds the time in seconds between the two dates write ( * , * ) 'DIFFERENCE (subtracting one date_time from another)=' ,& & answer - event ! OVERLOADED OPERATORS (logical comparisons) ! NOTE COMPARISONS ARE PERFORMED BY ! CONVERTING TIMES TO INTEGER SECONDS write ( * , * ) '> ' , event == event , event < event , event > event & & , event <= event , event >= event , event /= event ! write ( * , * ) '> ' , event == answer , event < answer , event > answer & & , event <= answer , event >= answer , event /= answer ! write ( * , * ) '> ' , answer == event , answer < event , answer > event & & , answer <= event , answer >= event , answer /= event ! %DELTA easily lets you change dates by common increments write ( * , * ) write ( * , 404 ) '%DELTA tests starting with date ' , event % delta () ! write ( * , * ) event % format ( \"                             & &%W, %L %d, %Y %H:%m:%s %N\" ) write ( * , * ) 'Remember years and months are not constant units' answer = event % delta ( year = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( month = 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( month =- 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( week = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( week =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( day = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( day =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = 4 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour =- 4 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( minute = 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( minute =- 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( second = 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( second =- 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( millisecond = 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( millisecond =- 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = 3 , month = 2 , day = 100 , hour = 200 ,& & week =- 1 , minute = 300 , second = 1000 , millisecond =- 10000 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(year=3,month=2,day=100,hour=200,& &week=-1,minute=300,second=1000,millisecond=100000)& & %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( duration = \"1-20:30:40.50\" ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DURATION='1-20:30:40.50')& & %W, %L %d, %Y %H:%m:%s %N\" ) end program demo_M_time__oop","tags":"","url":"program/demo_m_time__oop.html"},{"title":"demo_ordinal_to_date – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer :: dd integer :: ddd character(len=:), allocatable :: fakefile (:) integer :: i integer :: iostat integer :: mm integer :: yy integer :: yyyy Source Code program demo_ordinal_to_date use M_time , only : ordinal_to_date implicit none integer :: yyyy , ddd , mm , dd , yy integer :: dat ( 8 ) integer :: i , iostat character ( len = :), allocatable :: fakefile (:) fakefile = [ character ( len = 80 ) :: ' 2024 273 ' , '2024 001' ] do i = 1 , size ( fakefile ) ! Enter year YYYY and ordinal day of year DD read ( fakefile ( i ), * , iostat = iostat ) yyyy , ddd if ( iostat /= 0 ) exit ! recover month and day from year and day number. call ordinal_to_date ( yyyy , ddd , dat ) yy = dat ( 1 ) mm = dat ( 2 ) dd = dat ( 3 ) write ( * , '(*(g0))' ) 'For Year ' , yyyy , ' and Ordinal day ' , ddd write ( * , '(*(g0))' ) ' Month is ' , mm , ' and Day of Month is ' , dd , & & ' and Year is ' , yy enddo end program demo_ordinal_to_date","tags":"","url":"program/demo_ordinal_to_date.html"},{"title":"julian_time – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr real(kind=dp) :: time Source Code program julian_time use M_time , only : date_to_julian implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer :: dat ( 8 ) integer :: ierr real ( kind = dp ) :: time call date_and_time ( values = dat ) call date_to_julian ( dat , time , ierr ) write ( * , '(f0.7)' ) time end program julian_time","tags":"","url":"program/julian_time.html"},{"title":"demo_sec2days – M_time","text":"Uses M_time M_strings M_kracken95 Variables Type Attributes Name Initial character(len=*), parameter :: ident = \"@(#)sec2days(1f): convert seconds to string of form dd-hh:mm:ss\" character(len=IPvalue) :: line character(len=:), allocatable :: radix character(len=:), allocatable :: strlocal Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) usage Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program demo_sec2days use M_kracken95 , only : kracken , lget , sget , IPvalue use M_time , only : sec2days use M_strings , only : substitute implicit none character ( len =* ), parameter :: ident = \"@(#)sec2days(1f): convert seconds to string of form dd-hh:mm:ss\" character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: radix character ( len = IPvalue ) :: line call kracken ( 'sec2days' , ' -oo -crop .F -radix . -help .F. -version .F.' ) ! parse command line call help_usage ( lget ( 'sec2days_help' )) ! display help information and stop if true call help_version ( lget ( 'sec2days_version' )) ! display version information and stop if true radix = trim ( sget ( 'sec2days_radix' )) line = sget ( 'sec2days_oo' ) if ( radix /= '.' ) then call substitute ( line , '.' , ' ' ) call substitute ( line , radix , '.' ) endif strlocal = sec2days ( line , lget ( 'sec2days_crop' )) ! get command line option and convert to dd-hh:mm:ss string write ( * , '(a)' ) strlocal contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   sec2days(1f) - [TIME] Convert durations of time to string of form dd-hh:mm:ss' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   sec2days nnnn[.xxx] [ -crop]| --version| --help                              ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a numeric string representing seconds or labeled units of time         ' ,& '   convert it to a string of the form                                           ' ,& '                                                                                ' ,& '      dd-hh:mm:ss                                                               ' ,& '                                                                                ' ,& '   where dd is days, hh hours, mm minutes and ss seconds.                       ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   nnnn[.xxx]  Defaults to number of seconds to convert to string of            ' ,& '               form dd-hh:mm:ss.  nnnn may be interspersed with unit            ' ,& '               codes d,h,m,s. Spaces, commas and case are ignored. Allowed      ' ,& '               aliases for the unit codes are                                   ' ,& '                                                                                ' ,& '                 d  days and day                                                ' ,& '                 h  hours,hour,hrs, and hr                                      ' ,& '                 m  minutes,minute and min                                      ' ,& '                 s  seconds,second and sec                                      ' ,& '                                                                                ' ,& '   -crop       trim leading zero values from output                             ' ,& '   -radix      character used as decimal separator                              ' ,& '   --help      display this help and exit                                       ' ,& '   --version   output version information and exit                              ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& ' usage                                                                          ' ,& '                                                                                ' ,& '   sec2days 129860                                                              ' ,& '   1-12:04:20                                                                   ' ,& '   sec2days 1d2h3m4s                                                            ' ,& '   1-02:03:04                                                                   ' ,& '   sec2days 1.0 days 2 hours 3 minutes 4 seconds                                ' ,& '   1-02:03:04                                                                   ' ,& '   sec2days 1.5d                                                                ' ,& '   1-12:00:00                                                                   ' ,& '                                                                                ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    sec2days(1f) - [TIME] Convert durations of time to string of form dd-hh:mm:ss !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    sec2days nnnn[.xxx] [ -crop]| --version| --help !! !!##DESCRIPTION !!    Given a numeric string representing seconds or labeled units of time !!    convert it to a string of the form !! !!       dd-hh:mm:ss !! !!    where dd is days, hh hours, mm minutes and ss seconds. !! !!##OPTIONS !!    nnnn[.xxx]  Defaults to number of seconds to convert to string of !!                form dd-hh:mm:ss.  nnnn may be interspersed with unit !!                codes d,h,m,s. Spaces, commas and case are ignored. Allowed !!                aliases for the unit codes are !! !!                  d  days and day !!                  h  hours,hour,hrs, and hr !!                  m  minutes,minute and min !!                  s  seconds,second and sec !! !!    -crop       trim leading zero values from output !!    -radix      character used as decimal separator !!    --help      display this help and exit !!    --version   output version information and exit !! !!##EXAMPLES !! !!  usage !! !!    sec2days 129860 !!    1-12:04:20 !!    sec2days 1d2h3m4s !!    1-02:03:04 !!    sec2days 1.0 days 2 hours 3 minutes 4 seconds !!    1-02:03:04 !!    sec2days 1.5d !!    1-12:00:00 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        sec2days(1f)>' ,& '@(#)DESCRIPTION:    convert seconds to string of form dd-hh:mm:ss>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_sec2days","tags":"","url":"program/demo_sec2days.html"},{"title":"demo_days2sec – M_time","text":"Uses M_time M_strings M_kracken95 Variables Type Attributes Name Initial character(len=*), parameter :: ident = \"@(#)days2sec(1): given string of form dd-hh:mm:ss convert to seconds\" character(len=:), allocatable :: printline Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Forms: Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program demo_days2sec use M_kracken95 , only : kracken , sget , lget , rget use M_time , only : days2sec use M_strings , only : v2s implicit none character ( len =* ), parameter :: ident = \"@(#)days2sec(1): given string of form dd-hh:mm:ss convert to seconds\" character ( len = :), allocatable :: printline call kracken ( 'days2sec' , ' -oo -help .F. -version .F. -denominator 1' ) ! parse command line call help_usage ( lget ( 'days2sec_help' )) ! display help information and stop if true call help_version ( lget ( 'days2sec_version' )) ! display version information and stop if true ! get value from command line with SGET, convert to seconds with DAYS2SEC, and make into a nicer value string with V2S printline = v2s ( days2sec ( sget ( 'days2sec_oo' )) / rget ( 'days2sec_denominator' )) ! not in write statement so error message will print write ( * , '(a)' ) printline contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds                ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& ' Forms:                                                                         ' ,& '                                                                                ' ,& '    days2sec dd-hh:mm:ss                                                        ' ,& '    days2sec NNdNNhNNmNNs                                                       ' ,& '    days2sec --version| --help                                                  ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss where dd is days, hh hours,         ' ,& '   mm minutes and ss seconds convert it to seconds. Many utilities (ps(1),      ' ,& '   for example) show times in this format to make it more intelligible;         ' ,& '   but it generally easier to perform math on values represented in             ' ,& '   seconds.                                                                     ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   dd-hh:mm:ss  Given a string representing a duration of time in the           ' ,& '                following forms:                                                ' ,& '                                                                                ' ,& '                  dd-hh:mm:ss                                                   ' ,& '                     hh:mm:ss                                                   ' ,& '                        mm:ss                                                   ' ,& '                           ss                                                   ' ,& '                                                                                ' ,& '                convert it to seconds.                                          ' ,& '                                                                                ' ,& '                The numeric values may represent floating point numbers.        ' ,& '                                                                                ' ,& '                Spaces are ignored.                                             ' ,& '                                                                                ' ,& '    NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes;    ' ,& '                  where s,m,h, or d represents seconds, minutes, hours          ' ,& '                  or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are' ,& '                                                                                ' ,& '                   w -  weeks,week,wk,wks                                       ' ,& '                   d -  days,day                                                ' ,& '                   m -  minutes,minute,min                                      ' ,& '                   h -  hours,hour,hrs,hr                                       ' ,& '                   s -  seconds,second,sec,secs                                 ' ,& '                                                                                ' ,& '                  The numeric values may represent floating point numbers.      ' ,& '                                                                                ' ,& '                  Spaces, commas  and case are ignored.                         ' ,& '                                                                                ' ,& '   --denominator  divide the result by this value. Default is one(1).           ' ,& '   --help         display this help and exit                                    ' ,& '   --version      output version information and exit                           ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '  Usage                                                                         ' ,& '                                                                                ' ,& '    days2sec 1-12:04:20                                                         ' ,& '    129860                                                                      ' ,& '    days2sec 1.5 days                                                           ' ,& '    129600                                                                      ' ,& '    days2sec 1.5 days 4hrs 30minutes                                            ' ,& '    145800                                                                      ' ,& '    days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED                    ' ,& '    30                                                                          ' ,& '    days2sec 1 1 1  # SPACES ARE IGNORED                                        ' ,& '    111                                                                         ' ,& 'SEE ALSO                                                                        ' ,& '    sec2days(1)                                                                 ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!  Forms: !! !!     days2sec dd-hh:mm:ss !!     days2sec NNdNNhNNmNNs !!     days2sec --version| --help !! !!##DESCRIPTION !!    Given a duration in the form dd-hh:mm:ss where dd is days, hh hours, !!    mm minutes and ss seconds convert it to seconds. Many utilities (ps(1), !!    for example) show times in this format to make it more intelligible; !!    but it generally easier to perform math on values represented in !!    seconds. !! !!##OPTIONS !!    dd-hh:mm:ss  Given a string representing a duration of time in the !!                 following forms: !! !!                   dd-hh:mm:ss !!                      hh:mm:ss !!                         mm:ss !!                            ss !! !!                 convert it to seconds. !! !!                 The numeric values may represent floating point numbers. !! !!                 Spaces are ignored. !! !!     NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes; !!                   where s,m,h, or d represents seconds, minutes, hours !!                   or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are !! !!                    w -  weeks,week,wk,wks !!                    d -  days,day !!                    m -  minutes,minute,min !!                    h -  hours,hour,hrs,hr !!                    s -  seconds,second,sec,secs !! !!                   The numeric values may represent floating point numbers. !! !!                   Spaces, commas  and case are ignored. !! !!    --denominator  divide the result by this value. Default is one(1). !!    --help         display this help and exit !!    --version      output version information and exit !! !!##EXAMPLES !! !!   Usage !! !!     days2sec 1-12:04:20 !!     129860 !!     days2sec 1.5 days !!     129600 !!     days2sec 1.5 days 4hrs 30minutes !!     145800 !!     days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED !!     30 !!     days2sec 1 1 1  # SPACES ARE IGNORED !!     111 !!##SEE ALSO !!     sec2days(1) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        days2sec(1f)>' ,& '@(#)DESCRIPTION:    convert dd-hh:mm:ss string to seconds>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_days2sec","tags":"","url":"program/demo_days2sec.html"},{"title":"demo_j2d – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) real(kind=realtime) :: today Source Code program demo_j2d use M_time , only : j2d , d2j , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2j ( dat ) ! convert today to Julian Date write ( * , * ) 'Today=' , fmtdate ( j2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) 'Yesterday=' , fmtdate ( j2d ( today - 1.0_dp )) write ( * , * ) 'Tomorrow=' , fmtdate ( j2d ( today + 1.0_dp )) end program demo_j2d","tags":"","url":"program/demo_j2d.html"},{"title":"demo_moon_fullness – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_moon_fullness use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' )& & 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_moon_fullness","tags":"","url":"program/demo_moon_fullness.html"},{"title":"today – M_time","text":"Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version subroutine main () Arguments None Source Code program today implicit none call main () contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '       today(1f) - [TIME] output current time for uses such as file suffixes.   ' ,& '       (LICENSE:PD)                                                             ' ,& 'SYNOPSIS                                                                        ' ,& '       today format|--help|--version|--test                                     ' ,& 'DESCRIPTION                                                                     ' ,& '       Outputs the current date using the specified format. Typically used      ' ,& '       to generate a string to be used in building filenames containing         ' ,& '       date information.                                                        ' ,& 'OPTIONS                                                                         ' ,& '       format     any allowable format for the fmtdate(3) routine.              ' ,& '                  defaults to \"Y-M-D\".                                          ' ,& '       --help     display this help and exit                                    ' ,& '       --version  output version information and exit                           ' ,& '       --test     display allowed options for building a format                 ' ,& 'EXAMPLES                                                                        ' ,& '       Sample commands:                                                         ' ,& '                                                                                ' ,& '        $today                                                                  ' ,& '        2024-05-27                                                              ' ,& '                                                                                ' ,& '        $mv -v myfile myfile.`today`                                            ' ,& '        renamed ''myfile'' -> ''myfile.2024-05-27''                             ' ,& '                                                                                ' ,& '        $find . -ls > MANIFEST.`today epoch`; ls MANIFEST.*                     ' ,& '        MANIFEST.1716840303                                                     ' ,& '                                                                                ' ,& '        $mkdir `today YMDhms`                                                   ' ,& '        20240527160333                                                          ' ,& '                                                                                ' ,& '        $today yearmonthdayhourminutesecond                                     ' ,& '        20240527160442                                                          ' ,& '                                                                                ' ,& '        $today --test                          # show formatting options        ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        today(1f) - [TIME] output current time for uses such as file suffixes. !!        (LICENSE:PD) !!##SYNOPSIS !! !!        today format|--help|--version|--test !!##DESCRIPTION !!        Outputs the current date using the specified format. Typically used !!        to generate a string to be used in building filenames containing !!        date information. !!##OPTIONS !!        format     any allowable format for the fmtdate(3) routine. !!                   defaults to \"Y-M-D\". !!        --help     display this help and exit !!        --version  output version information and exit !!        --test     display allowed options for building a format !!##EXAMPLES !! !!        Sample commands: !! !!         $today !!         2024-05-27 !! !!         $mv -v myfile myfile.`today` !!         renamed 'myfile' -> 'myfile.2024-05-27' !! !!         $find . -ls > MANIFEST.`today epoch`; ls MANIFEST.* !!         MANIFEST.1716840303 !! !!         $mkdir `today YMDhms` !!         20240527160333 !! !!         $today yearmonthdayhourminutesecond !!         20240527160442 !! !!         $today --test                          # show formatting options !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        today(1f)>' ,& '@(#)DESCRIPTION:    output current time for uses such as file suffixes.>' ,& '@(#)VERSION:        1.0, 2009, 1.0.1 2024>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version subroutine main () use M_time , only : now , fmtdate_usage , locale use M_kracken95 , only : kracken , lget , sget ! add command-line parser module ! ident_1=\"@(#) today(1f) output current time for uses such as file suffixes.\" character ( len = :), allocatable :: options call locale ( 'LANGUAGE' ) call kracken ( 'today' , '-help .F. -version .F. -test .F.' ) ! define command arguments,default values and crack command line call help_usage ( lget ( 'today_help' )) ! if -help option is present, display help text and exit call help_version ( lget ( 'today_version' )) ! if -version option is present, display version text and exit if ( lget ( 'today_test' )) then ! special option to list date format documentation call fmtdate_usage () ! see all formatting options else options = sget ( 'today_oo' ) ! get -oo STRING if ( options == '' ) options = 'Y-M-D' ! if options are blank set a default write ( * , '(a)' ) now ( options ) ! display current date using format from command line endif end subroutine main end program today","tags":"","url":"program/today.html"},{"title":"demo_b2d – M_time","text":"Uses M_time Variables Type Attributes Name Initial type(BAStime) :: aday integer :: dat (8) integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' type(BAStime) :: newday type(BAStime) :: today type(BAStime) :: tomorrow type(BAStime) :: yesterday Subroutines subroutine pr (left, right) Arguments Type Intent Optional Attributes Name type(BAStime), intent(in) :: left type(BAStime), intent(in) :: right Source Code program demo_b2d use M_time , only : b2d , d2b , fmtdate , realtime , BAStime !BAStime includes operator(+), operator(-) implicit none integer , parameter :: dp = kind ( 0.0d0 ) type ( BAStime ) :: today type ( BAStime ) :: aday type ( BAStime ) :: newday , yesterday , tomorrow integer :: dat ( 8 ) character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'b2d:' call date_and_time ( values = dat ) ! get the date using intrinsic today = d2b ( dat ) ! convert DAT to BAS aday = BAStime ( 1 , 0.0_dp ) ! a value of one day write ( * , g ) 'Today=' , fmtdate ( b2d ( today )) write ( * , g ) 'BAStime +- BAStime' write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today + BAStime ( - 1 , 0.0_dp ))) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + BAStime ( + 1 , 0.0_dp ))) write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today + BAStime ( 0 , - 8640 0.0_dp ))) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + BAStime ( 0 , + 8640 0.0_dp ))) write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today - aday )) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + aday )) yesterday = today - aday write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( yesterday )) tomorrow = today + aday write ( * , g ) 'Tomorrow=' , fmtdate ( b2d ( tomorrow )) write ( * , g ) 'BAStime +- value_in_seconds' write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today - 86400 )) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + 86400 )) write ( * , g ) 'BAStime comparisons' newday = today + ( aday / 2 ) write ( * , g ) 'today=' , today % format () write ( * , g ) 'newday=' , newday % format () call pr ( today , newday ) call pr ( newday , today ) call pr ( today , today ) write ( * , g ) 'BAStime compound expressions' write ( * , g ) ( today + 86400 / 2 ). eq . newday , fmtdate ( b2d ( newday )) contains subroutine pr ( left , right ) type ( BAStime ), intent ( in ) :: left , right write ( * , g ) 'eq' , left . eq . right , & 'gt' , left . gt . right , & 'lt' , left . lt . right , & 'ge' , left . ge . right , & 'le' , left . le . right , & 'ne' , left . ne . right end subroutine pr end program demo_b2d","tags":"","url":"program/demo_b2d.html"},{"title":"demo_days2sec – M_time","text":"Uses M_time Source Code program demo_days2sec use M_time , only : days2sec implicit none write ( * , * ) days2sec ( '1-12:04:20' ) write ( * , * ) 'one second ' , days2sec ( '1' ) write ( * , * ) 'one minute ' , days2sec ( '1:00' ) write ( * , * ) 'one hour ' , days2sec ( '1:00:00' ) write ( * , * ) 'one day ' , days2sec ( '1-00:00:00' ) write ( * , * ) nint ( days2sec ( ' 1-12:04:20              ' )) == 129860 write ( * , * ) nint ( days2sec ( ' 1.5 days                ' )) == 129600 write ( * , * ) nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) == 145800 write ( * , * ) nint ( days2sec ( ' 1.5d                    ' )) == 129600 write ( * , * ) nint ( days2sec ( ' 1d2h3m4s                ' )) == 93784 ! duplicates write ( * , * ) nint ( days2sec ( ' 1d1d1d                  ' )) == 259200 ! negative values write ( * , * ) nint ( days2sec ( ' 4d-12h                  ' )) == 302400 end program demo_days2sec","tags":"","url":"program/demo_days2sec~2.html"},{"title":"demo_mo2d – M_time","text":"Uses M_time Source Code program demo_mo2d use M_time , only : mo2d implicit none write ( * , '(\"MARCH:\",*(i0:,\":\"))' ) mo2d ( 'March' ) end program demo_mo2d","tags":"","url":"program/demo_mo2d.html"},{"title":"demo_locale – M_time","text":"Uses M_time Subroutines subroutine mine () Arguments None Source Code program demo_locale use M_time , only : locale , now implicit none call locale ( 'POSIX' ) write ( * , * ) now () call locale ( 'french' ) write ( * , * ) now () call mine () write ( * , * ) now () contains subroutine mine () character ( len =* ), parameter :: months ( 12 ) = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH    ' , 'APRIL  ' , 'MAY     ' , 'JUNE    ' , & & 'JULY   ' , 'AUGUST  ' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] character ( len =* ), parameter :: weekdays ( 7 ) = [ character ( len = 9 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , 'SATURDAY' , 'SUNDAY' ] character ( len = 3 ), parameter :: short_months ( 12 ) = months (:)( 1 : 3 ) character ( len = 3 ), parameter :: short_weekdays ( 7 ) = weekdays (:)( 1 : 3 ) integer :: ierr call locale ( 'user' , months , short_months , weekdays , short_weekdays , ierr ) end subroutine mine end program demo_locale","tags":"","url":"program/demo_locale.html"},{"title":"demo_system_sleep – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: i Source Code program demo_system_sleep use M_time , only : system_sleep , now implicit none integer :: i ! write ( * , '(a)' ) \"Time before integer call is: \" , now () call system_sleep ( 4 ) write ( * , '(a)' ) \"Time after integer call is: \" , now () ! write ( * , '(a)' ) \"Time before real call is: \" , now () call system_sleep ( 4.0 ) write ( * , '(a)' ) \"Time after real call is: \" , now () ! write ( * , '(a)' ) \"Time before loop is: \" , now () do i = 1 , 1000 call system_sleep ( 4.0 / 100 0.0 ) enddo write ( * , '(a)' ) \"Time after loop is: \" , now () ! end program demo_system_sleep","tags":"","url":"program/demo_system_sleep.html"},{"title":"demo_system_sleep – M_time","text":"Uses M_time M_kracken Variables Type Attributes Name Initial character(len=:), allocatable :: cmd character(len=1) :: cpaws integer :: cstat integer :: dat (8) real(kind=realtime) :: delay_value integer :: i character(len=*), parameter :: ident = \"@(#)paws(1):pause until specified time or for specified duration\" integer :: ios integer :: itimes character(len=:), allocatable :: msg logical :: once character(len=256) :: sstat character(len=:), allocatable :: time_format logical :: until real(kind=realtime) :: until_value Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Typical usage: Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program demo_system_sleep use M_kracken , only : kracken , sget , lget , dget , igets , iget use M_time , only : days2sec , realtime , u2d , d2u , j2d , system_sleep , guessdate , now , fmtdate implicit none character ( len =* ), parameter :: ident = \"@(#)paws(1):pause until specified time or for specified duration\" real ( kind = realtime ) :: until_value real ( kind = realtime ) :: delay_value integer :: dat ( 8 ) integer :: i integer :: itimes integer :: ios logical :: until logical :: once character ( len = :), allocatable :: time_format character ( len = :), allocatable :: msg character ( len = :), allocatable :: cmd character ( len = 1 ) :: cpaws integer :: cstat character ( len = 256 ) :: sstat ! parse command line call kracken ( 'paws' , ' -oo -debug .f. -cmd -msg -uet -jd -dat -date -until -repeat 0 -fmt -help .F. -version .F.' ) call help_usage ( lget ( 'paws_help' )) ! display help information and stop if true call help_version ( lget ( 'paws_version' )) ! display version information and stop if true until = . false . until_value = 0.0 !=================================================================================================================================== ! delay until specified date has passed using various date descriptions if ( sget ( 'paws_uet' ). ne . ' ' ) then until_value = max ( 0.0d0 , dget ( 'paws_uet' ) - d2u () ) if ( lget ( 'paws_debug' )) then write ( * , * ) 'UET ...........' , dget ( 'paws_uet' ) write ( * , * ) 'd2u ...........' , d2u () write ( * , * ) 'until_value ...' , until_value call system_sleep ( nint ( until_value )) until = . true . endif endif if ( sget ( 'paws_jd' ). ne . ' ' ) then until_value = max ( 0.0d0 , d2u ( j2d ( dget ( 'paws_jd' ))) - d2u () ) call system_sleep ( nint ( until_value )) until = . true . endif if ( sget ( 'paws_dat' ). ne . ' ' ) then dat = igets ( 'paws_dat' ) until_value = max ( 0.0d0 , d2u ( dat ) - d2u ()) call system_sleep ( nint ( until_value )) until = . true . endif if ( sget ( 'paws_date' ). ne . ' ' ) then call guessdate ( sget ( 'paws_date' ), dat ) write ( * , * ) 'pausing till ' // fmtdate ( dat ) until_value = max ( 0.0d0 , d2u ( dat ) - d2u ()) call system_sleep ( nint ( until_value )) until = . true . endif if ( sget ( 'paws_until' ). ne . ' ' ) then call guessdate ( sget ( 'paws_until' ), dat ) write ( * , * ) 'pausing till ' // fmtdate ( dat ) until_value = max ( 0.0d0 , d2u ( dat ) - d2u ()) call system_sleep ( nint ( until_value )) until = . true . endif !=================================================================================================================================== ! determine value of cyclical pause duration if ( sget ( 'paws_oo' ). ne . ' ' ) then delay_value = max ( 0.0d0 , days2sec ( sget ( 'paws_oo' )) ) else delay_value = 0.0 endif !=================================================================================================================================== itimes = iget ( 'paws_repeat' ) if ( itimes . le . 0 ) then once = . true . itimes = 1 else once = . false . endif time_format = sget ( 'paws_fmt' ) msg = trim ( sget ( 'paws_msg' )) cmd = trim ( sget ( 'paws_cmd' )) !=================================================================================================================================== if ( lget ( 'paws_debug' )) then write ( * , * ) 'cmd ...........; ' , trim ( cmd ) write ( * , * ) 'msg ...........; ' , trim ( msg ) write ( * , * ) 'time_format ...; ' , trim ( time_format ) write ( * , * ) 'delay_value ...;' , delay_value write ( * , * ) 'until .........;' , until write ( * , * ) 'until_value ...;' , until_value write ( * , * ) 'once ..........;' , once write ( * , * ) 'itimes ........;' , itimes endif !=================================================================================================================================== do i = itimes , 1 , - 1 if ( msg . ne . ' ' ) then write ( * , '(a)' ) msg endif if (. not . once ) then write ( * , '(i0.3,1x,a)' ) i , now ( time_format ) endif if ( cmd . ne . ' ' ) then call execute_command_line ( cmd , cmdstat = cstat , cmdmsg = sstat ) endif if (. not . until . and . delay_value . le . 0 ) then ! no pause time specified. Prompt and read from stdin write ( * , '(\"continue...\")' , advance = \"no\" ) read ( * , '(a)' , iostat = ios ) cpaws else call system_sleep ( delay_value ) endif enddo if (. not . once ) then write ( * , '(i0.3,1x,a)' ) i , now ( time_format ) endif contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   paws(1f) - [TIME] pause until specified time or for specified duration       ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   paws [dd-hh:mm:ss[.xxx]|xxx.yyy[s|m|h|d]][ -msg message][ -cmd command][ -repeat TIMES[ -fmt ]]|...' ,& '   [ -uet|-jd|-dat|[ -date|-until]]                                             ' ,& '   paws --version|--help                                                        ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss.xxx where dd is days, hh hours,     ' ,& '   mm minutes and ss.xxx seconds convert it to seconds. Then, pause for that    ' ,& '   many seconds. Alternatively, pause until specified date has passed.          ' ,& '   If no duration is specified wait until a carriage return is entered.         ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   dd-hh:mm:ss   Given a string representing a duration of time in the          ' ,& '                 following forms:                                               ' ,& '                                                                                ' ,& '                   dd-hh:mm:ss[.xx]                                             ' ,& '                      hh:mm:ss[.xx]                                             ' ,& '                         mm:ss[.xx]                                             ' ,& '                            ss[.xx]                                             ' ,& '                      or                                                        ' ,& '                   xx[.yy]SUFFIX                                                ' ,& '                                                                                ' ,& '                 convert it to seconds and pause for that amount of time.       ' ,& '                 Suffix may be s for seconds, m for minutes, h for hours,       ' ,& '                 or d for days.                                                 ' ,& '   -date|-until  wait until the specified date has passed (before starting      ' ,& '                 optional pause). See guessdate(3f) for syntax allowed for      ' ,& '                 the date.                                                      ' ,& '   -uet          wait until the specified Unix Epoch Time has passed            ' ,& '   -jd           wait until the specified Julian Date has passed                ' ,& '   -dat          wait until the specified date vector has passed                ' ,& '                 (year month day timezone hour minutes seconds milliseconds)    ' ,& '   -repeat NNN   The duration is repeated NNN times with the date displayed     ' ,& '                 at the end of each pause.                                      ' ,& '   --msg         message to display before pausing                              ' ,& '   --cmd         command to execute after a pause                               ' ,& '   --fmt         date format (see fmtdate(3f) for details)                      ' ,& '   --help        display this help and exit                                     ' ,& '   --version     output version information and exit                            ' ,& '                                                                                ' ,& '   For more information on the format of the dates, see the now(1) command.     ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& ' Typical usage:                                                                 ' ,& '                                                                                ' ,& '  paws 2:00:00              # pause for two hours                               ' ,& '  paws 3600                 # pause one hour                                    ' ,& '  paws 0.10                 # pause one tenth of a second                       ' ,& '  paws 1 -repeat 60         # pause sixty seconds, displaying date each second  ' ,& '  paws -until 23:59:59      # pause until midnight                              ' ,& '  paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes  ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    paws(1f) - [TIME] pause until specified time or for specified duration !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    paws [dd-hh:mm:ss[.xxx]|xxx.yyy[s|m|h|d]][ -msg message][ -cmd command][ -repeat TIMES[ -fmt ]]|... !!    [ -uet|-jd|-dat|[ -date|-until]] !!    paws --version|--help !! !!##DESCRIPTION !!    Given a duration in the form dd-hh:mm:ss.xxx where dd is days, hh hours, !!    mm minutes and ss.xxx seconds convert it to seconds. Then, pause for that !!    many seconds. Alternatively, pause until specified date has passed. !!    If no duration is specified wait until a carriage return is entered. !! !!##OPTIONS !!    dd-hh:mm:ss   Given a string representing a duration of time in the !!                  following forms: !! !!                    dd-hh:mm:ss[.xx] !!                       hh:mm:ss[.xx] !!                          mm:ss[.xx] !!                             ss[.xx] !!                       or !!                    xx[.yy]SUFFIX !! !!                  convert it to seconds and pause for that amount of time. !!                  Suffix may be s for seconds, m for minutes, h for hours, !!                  or d for days. !!    -date|-until  wait until the specified date has passed (before starting !!                  optional pause). See guessdate(3f) for syntax allowed for !!                  the date. !!    -uet          wait until the specified Unix Epoch Time has passed !!    -jd           wait until the specified Julian Date has passed !!    -dat          wait until the specified date vector has passed !!                  (year month day timezone hour minutes seconds milliseconds) !!    -repeat NNN   The duration is repeated NNN times with the date displayed !!                  at the end of each pause. !!    --msg         message to display before pausing !!    --cmd         command to execute after a pause !!    --fmt         date format (see fmtdate(3f) for details) !!    --help        display this help and exit !!    --version     output version information and exit !! !!    For more information on the format of the dates, see the now(1) command. !! !!##EXAMPLES !! !!  Typical usage: !! !!   paws 2:00:00              # pause for two hours !!   paws 3600                 # pause one hour !!   paws 0.10                 # pause one tenth of a second !!   paws 1 -repeat 60         # pause sixty seconds, displaying date each second !!   paws -until 23:59:59      # pause until midnight !!   paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        paws(1f)>' ,& '@(#)DESCRIPTION:    pause until specified time or for specified duration>' ,& '@(#)VERSION:        1.0, 20160731>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_system_sleep","tags":"","url":"program/demo_system_sleep~2.html"},{"title":"demo_modified_julian_to_date – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr real(kind=realtime) :: modified_juliandate real(kind=realtime) :: tomorrow real(kind=realtime) :: yesterday Source Code program demo_modified_julian_to_date use M_time , only : modified_julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: modified_juliandate , tomorrow , yesterday integer :: dat ( 8 ) integer :: ierr ! set sample Modified Julian Date modified_juliandate = 6070 0.503682349771_dp ! create DAT array for this date call modified_julian_to_date ( modified_juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! ! go back one day yesterday = modified_juliandate - 1.0 call modified_julian_to_date ( yesterday , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! ! go forward one day tomorrow = modified_juliandate + 1 call modified_julian_to_date ( tomorrow , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) ! end program demo_modified_julian_to_date","tags":"","url":"program/demo_modified_julian_to_date.html"},{"title":"demo_box_month – M_time","text":"Uses M_time Variables Type Attributes Name Initial character(len=21) :: calendar (8) integer :: dat (8) Source Code program demo_box_month use M_time , only : box_month implicit none integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) call date_and_time ( values = dat ) call box_month ( dat , calendar ) write ( * , '(a)' ) calendar end program demo_box_month","tags":"","url":"program/demo_box_month.html"},{"title":"display_date – M_time","text":"Uses M_time m_strings M_kracken95 Variables Type Attributes Name Initial integer :: dat (8) = 0 real(kind=realtime) :: duration = 0 character(len=*), parameter :: ident = \"@(#)now(1f): writes timestamp using specified syntax\" integer :: ierr integer :: inums character(len=:), allocatable :: output real :: rdat (8) = 0 Subroutines subroutine help_version (l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version subroutine usage () Arguments None Source Code program display_date use M_kracken95 , only : kracken , lget , retrev , sget , dget ! command line parameter cracking module use M_time , only : now , fmtdate_usage , fmtdate , days2sec , d2u , u2d , realtime , guessdate , j2d , locale use m_strings , only : string_to_values , isdigit , isspace , switch implicit none character ( len =* ), parameter :: ident = \"@(#)now(1f): writes timestamp using specified syntax\" integer :: dat ( 8 ) = 0 real :: rdat ( 8 ) = 0 real ( kind = realtime ) :: duration = 0 character ( len = :), allocatable :: output !character(len=1),allocatable   :: chars(:) integer :: ierr , inums call locale ( 'LANGUAGE' ) !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - call kracken ( 'now' , ' -help .F. -version .F. -dat -date -jd -uet -test .false. -delta' ) ! crack command line call help_version ( lget ( 'now_version' )) ! display version number if --version is present !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_help' )) then ! display help text and exit if --help is present call usage () stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_test' )) then ! try each format type call fmtdate_usage ( 3 ) stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( sget ( 'now_uet' ) /= ' ' ) then dat = u2d ( dget ( 'now_uet' )) ! convert command option to UET number, convert to dat elseif ( sget ( 'now_jd' ) /= ' ' ) then dat = j2d ( dget ( 'now_jd' )) ! convert command option to JD number, convert to dat elseif ( sget ( 'now_dat' ) /= ' ' ) then dat = u2d () ! initialize DAT with current date and time to get time zone dat = [ dat ( 1 ), 1 , 1 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! default is Jan 1st in current year and timezone 00:00:00 call string_to_values ( sget ( 'now_dat' ), size ( dat ), rdat , inums , ' ,:/' , ierr ) ! convert string to array and overlay default values dat ( 1 : inums ) = nint ( rdat ( 1 : inums )) ! if -date is all integer digits and whitespace and +- and only one - (for UTC value) then use it directly to load a DAT !chars=switch(trim(sget('now_dat'))) !if( all(isdigit(chars).or.isspace(chars).or.chars == '-'.or.chars == '+' ) .and. count(chars == '-') <= 1 )then !else !   write(*,*)'*now* error: invalid characters in -dat input '//trim(sget('now_dat')) !endif elseif ( sget ( 'now_date' ) /= ' ' ) then ! convert command option to date string and try to guess date call guessdate ( sget ( 'now_date' ), dat ) else ! create DAT for current time dat = u2d () ! current time endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - duration = days2sec ( sget ( 'now_delta' )) ! convert string to duration in seconds dat = u2d ( d2u ( dat ) + duration ) ! convert DAT to UET, add duration, place back in DAT !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - output = fmtdate ( dat , sget ( 'now_oo' )) ! create output string by applying format !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - write ( * , '(a)' ) trim ( output ) ! write output !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - contains !----------------------------------------------------------------------------------------------------------------------------------- subroutine usage () ! character ( len =* ), parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character ( len = 80 ), allocatable :: text (:) integer :: i ! NOTE: Without the type specification this constructor would have to specify all of the constants with the same character length. text = [ character ( len = len ( text ( 1 ))) :: & & 'NAME                                                                            ' ,& & '   now(1f)  - [TIME] print the date and time                                    ' ,& & '   (LICENSE:PD)                                                                 ' ,& & '                                                                                ' ,& & 'SYNOPSIS                                                                        ' ,& & '  now [Format [ -date date_str|-ued Unix_time|-jd Julian_Date|-dat date_vector] ' ,& & '      [ -delta dd-hh:mm:ss]]|--help |--version|-test]                           ' ,& & '                                                                                ' ,& & 'DESCRIPTION                                                                     ' ,& & '   Report the current time or a Fortran date vector in a variety of formats.    ' ,& & '   Julian dates, Unix Epoch time, weekdays, monthnames, ordinal days,           ' ,& & '   AM/PM and iso-8601 week-numbering are supported by building a format         ' ,& & '   string containing the desired macros.                                        ' ,& & 'OPTIONS                                                                         ' ,& & '   Format  :                                                                    ' ,& & '     This string, containing macro names or keywords, creates the format used   ' ,& & '     to print the specified date.                                               ' ,& & '                                                                                ' ,& & '     The FORMAT string is expanded using the following macros:                  ' ,& & '                                                                                ' ,& & 'CALL FMTDATE_USAGE                                                              ' ,& & '                                                                                ' ,& & '   -dat date_vector  :                                                          ' ,& & '      A date vector is eight integers representing a date in the same manner as ' ,& & '      the Fortran DATE_AND_TIME(3f) function:                                   ' ,& & '          yyyy mm dd zone hh mm ss mss                                          ' ,& & '      only numeric time zones are supported.                                    ' ,& & '                                                                                ' ,& & '      When present, the specified date is used instead of the current time.     ' ,& & '                                                                                ' ,& & '   -uet Unix_Epoch_Time  :                                                      ' ,& & '      When present a value is used as the Unix Epoch Time. This date is         ' ,& & '      is then adjusted using any -delta value and then printed using            ' ,& & '      the specified format.                                                     ' ,& & '                                                                                ' ,& & '   -jd Julian_Date  :                                                           ' ,& & '      When present a value is used as the Julian Date.                          ' ,& & '                                                                                ' ,& & '   -delta dd-hh:mm:ss  :                                                        ' ,& & '      Add the specified duration to the date.                                   ' ,& & '                                                                                ' ,& & '   -date date_str  :                                                            ' ,& & '      The guessdate(3f) routine is used to try to convert a date description    ' ,& & '      to a date vector. For the guess to work, dates must either be in the      ' ,& & '      form YYYY-MM-DD or the order of numeric values must be \"\"dd yy yyy\".      ' ,& & '      Only four-digit years are supported. Month names are preferred over       ' ,& & '      numeric values. See the guessdate(3f) documentation for further details.  ' ,& & '                                                                                ' ,& & '   -test :                                                                      ' ,& & '      To list allowed macros use the -test switch.                              ' ,& & '                                                                                ' ,& & '   When present, the specified date is used instead of the current time.        ' ,& & 'EXAMPLES                                                                        ' ,& & ' Sample commands:                                                               ' ,& & '                                                                                ' ,& & '  now                                                                           ' ,& & '    Friday, June 17th, 2016 03:22:53 PM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta  1-0:0:0  # Tomorrow                                               ' ,& & '    Sunday, June 19th, 2016 11:32:26 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta -1-0:0:0  # Yesterday                                              ' ,& & '    Friday, June 17th, 2016 11:32:43 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now long -delta  7-0:0:0  # Next week                                         ' ,& & '    Saturday, June 25th, 2016 11:32:57 AM UTC-04:00                             ' ,& & '                                                                                ' ,& & '  now The date is %Y/%M/%D %h:%m:%s  # user-specified formats using macros      ' ,& & '    The date is 2009/08/10 00:33:48                                             ' ,& & '                                                                                ' ,& & '  now Y/M/D h:m:s # user-specified format with no % character                   ' ,& & '    2009/08/10 00:33:48                                                         ' ,& & '                                                                                ' ,& & '  now year-month-day # user-specified format with no % with long keywords       ' ,& & '  2016-07-29                                                                    ' ,& & '                                                                                ' ,& & '  now -dat 2016 07 23 -240 1 01 00 00  # alternate date                         ' ,& & '  Saturday, July 23rd, 2016 1:01:00 AM UTC-4:00                                 ' ,& & '                                                                                ' ,& & '  now -uet  1469250060                 # alternate Unix Epoch date              ' ,& & '  now -date January 4th, 1999 10:20:30 # try to determine date from description.' ,& & '                                                                                ' ,& & '  now YEAR=%Y MONTH=%M DAY=%D          # YEAR=2009 MONTH=08 DAY=10              ' ,& & '                                                                                ' ,& & '  now HOUR=%h MINUTES=%m SECONDS=%s MILLISECONDS=%x                             ' ,& & '      HOUR=01 MINUTES=18 SECONDS=44 MILLISECONDS=946                            ' ,& & '                                                                                ' ,& & '  # double-quotes are tricky (double them) to put in literally in this program: ' ,& & '  now ''\"\"year-month-day\"\",\"\"hour-minute-second\"\"'' #  \"2017-04-23\",\"14-41-09\"  ' ,& & '                                                                                ' ,& & '  # quotes are easier to control using the single-letter macros(use %q and %Q): ' ,& & '  now QY-M-DQ,Qh:m:sQ                                                           ' ,& & '     \"2017-04-23\",\"14-41-09\"                                                    ' ,& & '                                                                                ' ,& & '  now -test       # Show formatting options, handy way to look up macro names   ' ,& & '                                                                                ' ,& & 'LIMITS                                                                          ' ,& & '  See the M_time module description. Basically, A Gregorian Calendar is         ' ,& & '  assumed, and Leap Seconds are not specifically accounted for.                 ' ,& & 'SEE ALSO                                                                        ' ,& & '   month(1), sec2days(1), days2sec(1), easter(1), paws(1), today(1), ttee(1)    ' ,& & 'AUTHOR                                                                          ' ,& & '   John S. Urban                                                                ' ,& & 'LICENSE                                                                         ' ,& & '   Public Domain                                                                ' ,& & '                                                                                ' ] do i = 1 , size ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 6 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo stop end subroutine usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        now(1f)>' ,& '@(#)DESCRIPTION:    Report a date in a variety of formats>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program display_date","tags":"","url":"program/display_date.html"},{"title":"demo_u2d – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) real(kind=realtime) :: today Source Code program demo_u2d use M_time , only : u2d , d2u , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) ! get the date using intrinsic call date_and_time ( values = dat ) ! convert today to Julian Date today = d2u ( dat ) write ( * , * ) 'Today=' , fmtdate ( u2d ( today )) ! subtract day write ( * , * ) 'Yesterday=' , fmtdate ( u2d ( today - 8640 0.0_dp )) ! add day write ( * , * ) 'Tomorrow=' , fmtdate ( u2d ( today + 8640 0.0_dp )) end program demo_u2d","tags":"","url":"program/demo_u2d.html"},{"title":"test_a_A_format – M_time","text":"Uses M_time iso_fortran_env Variables Type Attributes Name Initial real(kind=wp) :: a real(kind=wp) :: b integer :: datnow (8) integer :: datstart (8) character(len=:), allocatable :: string integer, parameter :: wp = kind(0.0d0) Source Code program test_a_A_format use M_time , only : fmtdate , u2d , days2sec use , intrinsic :: iso_fortran_env , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT implicit none integer , parameter :: wp = kind ( 0.0d0 ) integer :: datnow ( 8 ) integer :: datstart ( 8 ) real ( kind = wp ) :: a , b character ( len = :), allocatable :: string ! %a -- Time since now as d-hh:mm:ss   %a  100-22:59:01 ! %A -- Time since now as seconds      %A  23423008.543 call date_and_time ( values = datnow ) datstart = u2d ( 0 ) ! compare Linux Epoch time to age of now from beginning of Epoch, ! which should be the same value string = fmtdate ( datnow , \"%e\" ) // ' ' // fmtdate ( datstart , \"%A\" ) read ( string , * ) a , b if ( nint ( b - a ). ne . 0 ) then write ( * , * ) 'FAILED: %A test:' , b , a , b - a stop 1 endif ! get same thing in D-hh:mm:ss format and then convert that ! to seconds using days2sec(3f) and should get same result string = fmtdate ( datstart , \"%a\" ) if ( nint ( days2sec ( string ) - b ) . ne . 0 ) then write ( * , * ) 'FAILED: a% test:' , days2sec ( string ), b , days2sec ( string ) - b stop 2 endif stop 'PASSED: tested %a and %A' end program test_a_A_format","tags":"","url":"program/test_a_a_format.html"},{"title":"demo_unix_to_date – M_time","text":"Uses M_time Variables Type Attributes Name Initial real(kind=realtime), parameter :: DAY = 86400.0_dp integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr real(kind=realtime) :: unixtime Source Code program demo_unix_to_date use M_time , only : unix_to_date , u2d , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: unixtime ! seconds in a day real ( kind = realtime ), parameter :: DAY = 8640 0.0_dp integer :: dat ( 8 ) integer :: ierr ! sample Unix Epoch time unixtime = 146893903 8.4639933_dp ! create DAT array for today call unix_to_date ( unixtime , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call unix_to_date ( unixtime - DAY , dat , ierr ) ! subtract day and print write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call unix_to_date ( unixtime + DAY , dat , ierr ) ! add day print write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_unix_to_date","tags":"","url":"program/demo_unix_to_date.html"},{"title":"demo_d2w – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) character(len=10) :: iso_name integer :: iso_week integer :: iso_weekday integer :: iso_year Source Code program demo_d2w use M_time , only : d2w implicit none integer :: dat ( 8 ) ! input date array integer :: iso_year , iso_week , iso_weekday character ( len = 10 ) :: iso_name call date_and_time ( values = dat ) call d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) write ( * , '(\"ISO-8601 Week:   \",a)' ) iso_name write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday end program demo_d2w","tags":"","url":"program/demo_d2w.html"},{"title":"ttee – M_time","text":"Uses m_kracken m_time m_strings iso_fortran_env Variables Type Attributes Name Initial character(len=10) :: access character(len=*), parameter :: delimiters = ' '//char(9)//char(13)//char(10) character(len=IPvalue) :: file character(len=IPvalue) :: format integer :: i10 integer :: ier integer :: ii integer :: ilen integer :: ios integer :: len1 integer :: len2 integer :: len3 integer :: outfile character(len=IPvalue) :: prefix logical :: stamp_output logical :: stamp_stdout character(len=IPvalue) :: string character(len=IPvalue) :: timestamp character(len=:), allocatable :: token Subroutines subroutine help_version (l_version) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version subroutine stderr (msg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg subroutine usage () Arguments None Source Code program ttee ! @(#) ttee(1) writes stdin to stdout and another file with an optional timestamp prefix use iso_fortran_env , only : iostat_end use m_kracken , only : kracken , lget , sget , retrev , IPvalue ! command line parameter cracking module use m_time , only : now , fmtdate_usage use m_strings , only : v2s , chomp implicit none character ( len = IPvalue ) :: string ! hold line read from input character ( len = IPvalue ) :: timestamp ! hold value of --timestamp option character ( len = IPvalue ) :: prefix ! prefix string character ( len = 10 ) :: access ! whether to append or overwrite output file character ( len = IPvalue ) :: file ! output filenames integer :: outfile ! unit number for output file integer :: ios ! value of iostat on i/o errors integer :: ilen , ier logical :: stamp_stdout , stamp_output integer :: len1 , len2 , len3 ! scratch variables for accumulating output filenames integer :: i10 ! counter for looping through file names character ( len = IPvalue ) :: format ! alternate format for the time stamp using the now(3f) function integer :: ii ! length of trimmed format character ( len =* ), parameter :: delimiters = ' ' // char ( 9 ) // char ( 13 ) // char ( 10 ) ! token delimiters (space, tab, return, line feed) character ( len = :), allocatable :: token !  crack command line call kracken ( 'ttee' , '            & & -o -output                     & & -a .F. -append .F.             & & -t \"#N#\" -timestamp \"#N#\"      & & -help .F.                      & & -fmt %Y/%M/%D %h:%m:%s.%x>     & & -version .F.                   & & ' ) call help_version ( lget ( 'ttee_version' )) !  display version number if --version is present !  display help text and exit if --help is present if ( lget ( 'ttee_help' )) then call usage () stop endif !  get time format call retrev ( 'ttee_fmt' , format , ii , ier ) ! assuming timestamp has same length as current timestamp , which might not be if change now(3f) !  decide whether to append to output file or overwrite it if -a or --append is present access = 'sequential' if ( lget ( 'ttee_a' )) then access = 'append' endif if ( lget ( 'ttee_append' )) then access = 'append' endif !  open optional output file ... simply append FILENAME, -o FILENAME, -output FILENAME file = ' ' call retrev ( 'ttee_oo' , file , len1 , ier ) ! get any filename before any keywords len2 = min ( IPvalue , len1 + 2 ) call retrev ( 'ttee_o' , file ( len2 :), len1 , ier ) ! append any filenames after -o keyword len2 = min ( IPvalue , len2 + 2 + len1 + 2 ) call retrev ( 'ttee_output' , file ( len2 :), len1 , ier ) ! append any filenames after -output keyword len3 = len_trim ( file ) ! length of appended filenames if ( len3 . ne . 0 ) then outfile = 9 ! initialize value used to get unit numbers for output files ! get list of filename separators do while ( chomp ( file , token , delimiters ). ge . 0 ) ! open each filename outfile = outfile + 1 open ( unit = outfile , file = token , access = access , iostat = ios ) if ( ios . ne . 0 ) then call stderr ( 'error opening output,iostat=' // v2s ( ios )) exit endif enddo else outfile =- 1 ! flag there is no output file specified endif !  set prefix length to 0 or PLEN depending on whether --timestamp value flags file to have timestamp prefix stamp_stdout = . true . ! prefix stdout stamp_output = . true . ! prefix outfiles prefix = '' ! initialize prefix string call retrev ( 'ttee_t' , timestamp , ilen , ier ) if ( timestamp . eq . '#N#' ) then call retrev ( 'ttee_timestamp' , timestamp , ilen , ier ) endif select case ( timestamp (: ilen )) case ( 'all' , '' , '#N#' ) stamp_stdout = . true . stamp_output = . true . case ( 'stdout' ) stamp_stdout = . true . stamp_output = . false . case ( 'output' ) stamp_stdout = . false . stamp_output = . true . case ( 'none' ) stamp_stdout = . false . stamp_output = . false . case default call stderr ( 'unknown timestamp value [stdout|all|output|none]' ) stop end select !  loop reading stdin till end-of-file or error and write to stdout and output file with optional timestamp prefix infinite : do prefix = now ( format (: ii )) ios = 0 read ( * , '(a)' , iostat = ios ) string if ( ios . ne . 0 ) then if ( ios . ne . iostat_end ) then call stderr ( 'error reading from stdin, iostat=' // v2s ( ios )) endif exit infinite endif ios = 0 ilen = len_trim ( string ) if ( stamp_stdout ) then write ( * , '(a,a)' , iostat = ios ) trim ( prefix ), string (: ilen ) else write ( * , '(a)' , iostat = ios ) string (: ilen ) endif if ( ios . ne . 0 ) then call stderr ( 'error writing to stdout,iostat=' // v2s ( ios )) exit infinite endif ios = 0 if ( outfile . ge . 0 ) then if ( stamp_output ) then do i10 = 10 , outfile write ( i10 , '(a,a)' , iostat = ios ) trim ( prefix ), string (: ilen ) enddo else do i10 = 10 , outfile write ( i10 , '(a)' , iostat = ios ) string (: ilen ) enddo endif endif if ( ios . ne . 0 ) then call stderr ( 'error writing to output,iostat=' // v2s ( ios )) exit infinite endif enddo infinite stop contains subroutine stderr ( msg ) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT implicit none ! @(#) M_verify stderr(3f) writes a message to standard error character ( len =* ), intent ( in ) :: msg integer :: iostat write ( error_unit , '(a)' , iostat = iostat ) trim ( msg ) flush ( unit = output_unit , iostat = iostat ) flush ( unit = error_unit , iostat = iostat ) end subroutine stderr subroutine usage () ! \"@(#) usage(3f90) writes program help to stdout and exits !character(len=132),parameter :: text(:)= [& character ( len = 132 ), allocatable :: text (:) integer :: i text = [& & 'NAME                                                                            ' , & & '   ttee(1f) - [TIME] write input to stdout and a file with timing info.         ' , & & '   (LICENSE:PD)                                                                 ' , & & '                                                                                ' , & & 'SYNOPSIS                                                                        ' , & & '   ttee [[ -o|--output] filename(s)] [ -a|--append] [ --timestamp FLAG]] ...    ' , & & '        [ -fmt FORMAT] [ --help | --version]                                    ' , & & '                                                                                ' , & & 'DESCRIPTION                                                                     ' , & & '   Read from standard input and write to standard output and files              ' , & & '   with an optional timestamp in front of each line.                            ' , & & '                                                                                ' , & & '   -o|--output FILENAME(S)                                                      ' , & & '         specify name of output file(s). If the filenames are first the         ' , & & '         keyword -o|--output is optional.                                       ' , & & '                                                                                ' , & & '   -a|--append                                                                  ' , & & '         append to the given output file(s), do not overwrite                   ' , & & '                                                                                ' , & & '   -t|--timestamp FLAG                                                          ' , & & '         which files to add the timestamp to. Default is \"all\"                  ' , & & '         Allowed values are stdout, output, all, none.                          ' , & & '                                                                                ' , & & '   -fmt FORMAT                                                                  ' , & & '         Change format for timestamp prefix using a call to now(3f).            ' , & & '                                                                                ' , & & 'CALL FMTDATE_USAGE                                                              ' , & & '   --help     display this help and exit                                        ' , & & '   --version  output version information and exit                               ' , & & 'LIMITS                                                                          ' , & & '    Program limits:                                                             ' , & & '                                                                                ' , & & '    o  Input line width maximum is 1024 characters.                             ' , & & '    o  Maximum length of output filenames is 4098, individual filename is 1024. ' , & & '    o  Minimum number of output files is probably at least 90; but is           ' , & & '       system dependent.                                                        ' , & & '                                                                                ' , & & 'EXAMPLES                                                                        ' , & & '   Basic command usage:                                                         ' , & & '                                                                                ' , & & '    # write stdout of \"program\" to ttee.out with a timestamp and stdout         ' , & & '    program|ttee --output ttee.out --timestamp output|grep -i iteration         ' , & & '                                                                                ' , & & '    # write stdout of \"program\" to log.txt and stdout with a Julian Day         ' , & & '    program|ttee log.txt -fmt \"%J :\"                                            ' , & & '    2457565.488 :Iteration 1 : Error: 1.20                                      ' , & & '    2457565.558 :Iteration 2 : Error: 0.08                                      ' , & & '    2467569.684 :Iteration 3 : Error: 1.2e-3                                    ' , & & 'AUTHOR                                                                          ' , & & '  John S. Urban                                                                 ' , & & 'LICENSE                                                                         ' , & & '  Public Domain                                                                 ' , & & '                                                                                ' ] do i = 1 , SIZE ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 10 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo end subroutine usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        ttee(1f)>' ,& '@(#)DESCRIPTION:    split stdout to a file with optional timestamp labeling>' ,& '@(#)VERSION:        1.0, 2015-09-13>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program ttee","tags":"","url":"program/ttee.html"},{"title":"runtest – M_time","text":"Uses M_time iso_c_binding M_framework__verify iso_fortran_env no not use M_system version or will create a circular dependency\ncall unit_test_start(‘ephemeris      ‘,SAME//’ephemeris position of planets for adjusting an equatorial telescope’//SAMEEND)\ncall test_ephemeris() Variables Type Attributes Name Initial logical, parameter :: F = .false. character(len=*), parameter :: SAME = '' character(len=*), parameter :: SAMEEND = '' logical, parameter :: T = .true. integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr Functions pure function str2arr (string) result(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=c_char, len=1), (len(string)+1) Subroutines subroutine put_environment_variable (NAME, VALUE, STATUS) Arguments Type Intent Optional Attributes Name character(len=*) :: NAME character(len=*) :: VALUE integer, intent(out), optional :: STATUS subroutine showme (string) Arguments Type Intent Optional Attributes Name character(len=*) :: string subroutine test_b2d () Arguments None subroutine test_bas_to_date () Arguments None subroutine test_box_month () Arguments None subroutine test_d2b () Arguments None subroutine test_d2j () Arguments None subroutine test_d2m () Arguments None subroutine test_d2o () Arguments None subroutine test_d2u () Arguments None subroutine test_d2w () Arguments None subroutine test_date_to_bas () Arguments None subroutine test_date_to_julian () Arguments None subroutine test_date_to_modified_julian () Arguments None subroutine test_date_to_unix () Arguments None subroutine test_days2sec () Arguments None subroutine test_dow () Arguments None subroutine test_easter () Arguments None subroutine test_fmtdate () Arguments None subroutine test_fmtdate_usage () Arguments None subroutine test_guessdate () Arguments None subroutine test_j2d () Arguments None subroutine test_julian_to_date () Arguments None subroutine test_locale () Arguments None subroutine test_m2d () Arguments None subroutine test_mo2d () Arguments None subroutine test_mo2v () Arguments None subroutine test_modified_julian_to_date () Arguments None subroutine test_moon_fullness () Arguments None subroutine test_now () Arguments None subroutine test_now_ex () Arguments None subroutine test_o2d () Arguments None subroutine test_ordinal_seconds () Arguments None subroutine test_ordinal_to_date () use M_time, only : o2d, ordinal_to_date, d2o Arguments None subroutine test_phase_of_moon () Arguments None subroutine test_sec2days () Arguments None subroutine test_u2d () Arguments None subroutine test_unix_to_date () Arguments None subroutine test_v2mo () Arguments None subroutine test_w2d () Arguments None subroutine to_upper_extended_ascii () Arguments None Source Code program runtest use , intrinsic :: iso_c_binding , only : c_int , c_char , c_null_char use , intrinsic :: iso_fortran_env , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT use M_framework__verify , only : unit_test , unit_test_end , unit_test_mode use M_framework__verify , only : unit_test_start , unit_test_msg , unit_test_level use M_framework__verify , only : unit_test_stop use M_time , only : & dow , guessdate , & mo2v , now , ordinal_seconds , & realtime , BAStime , & fmtdate , box_month , & days2sec , sec2days , & phase_of_moon , moon_fullness , easter , & ordinal_to_date , o2d , & unix_to_date , date_to_unix , u2d , d2u , & julian_to_date , date_to_julian , j2d , d2j , & modified_julian_to_date , date_to_modified_julian , m2d , d2m , & bas_to_date , date_to_bas , b2d , d2b , & w2d , d2w , & d2o , & mo2d , & v2mo use M_time , only : locale implicit none integer :: dat ( 8 ) integer :: ierr character ( len =* ), parameter :: SAME = '' ! '-library libGPF -section 3 -description \"' character ( len =* ), parameter :: SAMEEND = '' ! '\"' logical , parameter :: T = . true ., F = . false . integer , parameter :: dp = kind ( 0.0d0 ) call unit_test_mode ( & keep_going = T , & flags = [ 0 ], & luns = [ stdout ], & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 !! no not use M_system version or will create a circular dependency call put_environment_variable ( 'TZ' , 'America/New_York' , ierr ) ! some of the test values assume EST call put_environment_variable ( 'TZ' , 'UTC+04:00' , ierr ) ! some of the test values assume EST call unit_test_msg ( 'M_time' , 'This section contains unit tests for procedures in the M_time(3f) module.' ) call unit_test_start ( 'box_month      ' , SAME // 'print specified month into character array' // SAMEEND ) call test_box_month () call unit_test_start ( 'd2o            ' , SAME // 'Converts date-time array to Ordinal day' // SAMEEND ) call test_d2o () call unit_test_start ( 'ordinal_seconds' , SAME // 'seconds since begiing of year' // SAMEEND ) call test_ordinal_seconds () call unit_test_start ( 'd2u            ' , SAME // 'Convert date array to Unix Time' // SAMEEND ) call test_d2u () call unit_test_start ( 'd2w            ' , SAME // 'Calculate iso-8601 Week-numbering year date yyyy-Www-d' // SAMEEND ) call test_d2w () call unit_test_start ( 'date_to_unix   ' , SAME // 'Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970, UTC)' // SAMEEND ) call test_date_to_unix () call unit_test_start ( 'days2sec       ' , SAME // 'converts string D-HH:MM:SS to seconds from small to large' // SAMEEND ) call test_days2sec () call unit_test_start ( 'dow            ' , SAME // 'Return the day of the week' // SAMEEND ) call test_dow () call unit_test_start ( 'easter         ' , SAME // 'Determine month and day Easter falls on for given year' // SAMEEND ) call test_easter () !!call unit_test_start('ephemeris      ',SAME//'ephemeris position of planets for adjusting an equatorial telescope'//SAMEEND) !!call test_ephemeris() call unit_test_start ( 'locale        ' , SAME // 'select language for month and weekday names' // SAMEEND ) call test_locale () call unit_test_start ( 'fmtdate        ' , SAME // 'given date array return date as string using format' // SAMEEND ) call test_fmtdate () call unit_test_start ( 'fmtdate_usage  ' , SAME // 'display macros recognized by fmtdate(3f)' // SAMEEND ) call test_fmtdate_usage () call unit_test_start ( 'guessdate      ' , SAME // 'Reads in a date, in various formats' // SAMEEND ) call test_guessdate () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'julian_to_date ' , SAME // 'Converts Julian Date to (year, month, day, hour, minute, second)' // SAMEEND ) call test_julian_to_date () call unit_test_start ( 'j2d            ' , SAME // 'Convert Julian Date to date array' // SAMEEND ) call test_j2d () call unit_test_start ( 'date_to_julian ' , SAME // 'Converts Proleptic Gregorian date array to Julian Date' // SAMEEND ) call test_date_to_julian () call unit_test_start ( 'd2j            ' , SAME // 'Convert date array to Julian Date' // SAMEEND ) call test_d2j () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'modified_julian_to_date' , SAME // 'Convert Modified Julian Date to (year,month,day,hour,minute,second)' // SAMEEND ) call test_modified_julian_to_date () call unit_test_start ( 'm2d            ' , SAME // 'Convert Modified Julian Date to date array' // SAMEEND ) call test_m2d () call unit_test_start ( 'date_to_modified_julian ' , SAME // 'Converts Proleptic Gregorian date array to Modified Julian Date' // SAMEEND ) call test_date_to_julian () call unit_test_start ( 'd2m            ' , SAME // 'Convert date array to Modified Julian Date' // SAMEEND ) call test_d2m () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'bas_to_date    ' , SAME // 'Converts Baseday and Seconds to (year, month, day, hour, minute, second)' // SAMEEND ) call test_bas_to_date () call unit_test_start ( 'b2d            ' , SAME // 'Convert Baseday and Seconds to date array' // SAMEEND ) call test_b2d () call unit_test_start ( 'date_to_bas    ' , SAME // 'Converts Proleptic Gregorian date array to Baseday and Seconds' // SAMEEND ) call test_date_to_bas () call unit_test_start ( 'd2b            ' , SAME // 'Convert date array to Baseday and Seconds' // SAMEEND ) call test_d2b () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'mo2d           ' , SAME // 'return date array for beginning of given month name in specified year' // SAMEEND ) call test_mo2d () call unit_test_start ( 'mo2v           ' , SAME // 'given month as name return month number (1-12) of that month' // SAMEEND ) call test_mo2v () call unit_test_start ( 'moon_fullness  ' , SAME // 'return name for phase of moon for given date' // SAMEEND ) call test_moon_fullness () call unit_test_start ( 'now            ' , SAME // 'return string representing current time given format' // SAMEEND ) call test_now () call unit_test_start ( 'now_ex         ' , SAME // 'use of now(3f) outside of a module' // SAMEEND ) call test_now_ex () call unit_test_start ( 'o2d            ' , SAME // 'given ordinal day of year return date array, Jan 1st=1' // SAMEEND ) call test_o2d () call unit_test_start ( 'ordinal_to_date' , SAME // 'given ordinal day of year return date array, Jan 1st=1' // SAMEEND ) call test_ordinal_to_date () call unit_test_start ( 'phase_of_moon  ' , SAME // 'percentage of moon phase from new to full' // SAMEEND ) call test_phase_of_moon () call unit_test_start ( 'sec2days       ' , SAME // 'converts seconds to string D-HH:MM:SS' // SAMEEND ) call test_sec2days () call unit_test_start ( 'u2d            ' , SAME // 'Convert Unix Time to date array' // SAMEEND ) call test_u2d () call unit_test_start ( 'unix_to_date   ' , SAME // 'Converts Unix Time to date array' // SAMEEND ) call test_unix_to_date () call unit_test_start ( 'v2mo           ' , SAME // 'returns the month name of a Common month' // SAMEEND ) call test_v2mo () call unit_test_start ( 'w2d            ' , SAME // 'Given iso-8601 Week-numbering year date yyyy-Www-d calculate date' // SAMEEND ) call test_w2d () call unit_test_stop ( 'M_time tests completed' ) contains !=================================================================================================================================== subroutine to_upper_extended_ascii () character ( len = :), allocatable :: month_names (:), weekday_names (:), month_names_abbr (:), weekday_names_abbr (:) month_names = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH' , 'APRIL' , 'MAY' , 'JUNE' , 'JULY' , 'AUGUST' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] weekday_names = [ character ( len = 10 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , 'SATURDAY' , 'SUNDAY' ] month_names_abbr = month_names (:)( 1 : 3 ) weekday_names_abbr = weekday_names (:)( 1 : 3 ) call locale ( 'user' , month_names , weekday_names , month_names_abbr , weekday_names_abbr ) end subroutine to_upper_extended_ascii !=================================================================================================================================== #ifndef _WIN32 subroutine put_environment_variable ( name , value , status ) !  This is an private copy of the set_environment_variable routine(3f) routine from !  M_system.FF that is duplicated in order to prevent a circular dependency. ! ident_33=\"@(#)M_system::put_environment_variable(3f): call setenv(3c) to set environment variable\" character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS integer :: loc_err character ( kind = c_char , len = 1 ), allocatable :: temp_chars1 (:) character ( kind = c_char , len = 1 ), allocatable :: temp_chars2 (:) interface integer ( kind = c_int ) function c_setenv ( c_name , c_VALUE ) bind ( C , NAME = \"setenv\" ) import c_int , c_char character ( kind = c_char ) :: c_name ( * ) character ( kind = c_char ) :: c_VALUE ( * ) end function end interface temp_chars1 = str2arr ( trim ( NAME )) temp_chars2 = str2arr ( VALUE ) loc_err = c_setenv ( temp_chars1 , temp_chars2 ) if ( present ( STATUS )) STATUS = loc_err end subroutine put_environment_variable #else subroutine put_environment_variable ( name , value , status ) character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS write ( * , * ) '<WARNING>put_environment_variable is not working on this platform' if ( present ( STATUS )) STATUS = - 1 end subroutine put_environment_variable #endif !=================================================================================================================================== pure function str2arr ( string ) result ( array ) ! ident_34=\"@(#)M_system::str2arr(3fp): function copies string to null terminated char array\" character ( len =* ), intent ( in ) :: string character ( len = 1 , kind = c_char ) :: array ( len ( string ) + 1 ) integer :: i do i = 1 , len_trim ( string ) array ( i ) = string ( i : i ) enddo array ( size ( array )) = c_null_char end function str2arr !=================================================================================================================================== !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_julian () real ( kind = realtime ) :: julian integer :: ierr integer :: dat ( 8 ) dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , abs ( julian - 244058 7.5d0 ) < 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_test_end ( 'date_to_julian' ) end subroutine test_date_to_julian !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_julian_to_date () real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected juliandate = 245758 9.129d0 ! set sample Julian Date call julian_to_date ( juliandate , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate - 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate + 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'julian_to_date' ) end subroutine test_julian_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2j real ( kind = realtime ) :: julian integer :: dat ( 8 ) dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , abs ( julian - 244058 7.5d0 ) < 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_test_end ( 'd2j' ) end subroutine test_d2j !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_j2d real ( kind = realtime ) :: juliandate character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) juliandate = 245758 9.129d0 ! set sample Julian Date expected = '2016-07-19 11:05:45' dat = j2d ( juliandate ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = j2d ( juliandate - 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate - 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = j2d ( juliandate + 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate + 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'j2d' ) end subroutine test_j2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_unix real ( kind = realtime ) :: unixtime integer :: ierr integer :: in ( 8 ) integer :: expected in = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] expected = 1490766407 call date_to_unix ( in , unixtime , ierr ) call unit_test ( 'date_to_unix' , abs ( unixtime - expected ) < 0.001 , 'EXPECTED' , expected , 'RESULT' , unixtime ) call unit_test_end ( 'date_to_unix' ) end subroutine test_date_to_unix !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unix_to_date integer :: ierr integer :: dat ( 8 ) integer :: result ( 8 ) integer :: unixtime dat = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] unixtime = 1490766407 call unix_to_date ( unixtime , result , ierr ) call unit_test ( 'unix_to_date' , all ( dat == result ), 'IN' , unixtime ) !JSU call unit_test ( 'unix_to_date' , ierr == 0 , 'IERR' , ierr ) call unit_test_end ( 'unix_to_date' ) end subroutine test_unix_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2o () integer :: iday , iyear , omonth , oday , rday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) rday = d2o ( dat ) call unit_test ( 'd2o' , iday == rday , msg = tests ( i )) enddo call unit_test_end ( 'd2o' ) end subroutine test_d2o !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_seconds () integer :: rday rday = ordinal_seconds () / ( 60 * 60 * 24 ) call unit_test ( 'ordinal_seconds' , rday == d2o (), rday , d2o ()) call unit_test_end ( 'ordinal_seconds' ) end subroutine test_ordinal_seconds !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_to_date () !!use M_time, only : o2d, ordinal_to_date, d2o integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday call ordinal_to_date ( iyear , iday , dat ) call unit_test ( 'ordinal_to_date' , dat ( 2 ) == omonth . and . dat ( 3 ) == oday , 'year' , iyear , 'ordinal' , iday ) enddo call unit_test_end ( 'ordinal_to_date' ) end subroutine test_ordinal_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_o2d () integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) call unit_test ( 'o2d' , dat ( 1 ) == iyear . and . dat ( 2 ) == omonth . and . dat ( 3 ) == oday , msg = tests ( i )) enddo call unit_test_end ( 'o2d' ) end subroutine test_o2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_v2mo call unit_test ( 'v2mo' , v2mo ( 1 ) == 'January' , 'January' , v2mo ( 1 ) ) call unit_test ( 'v2mo' , v2mo ( 2 ) == 'February' , 'February' , v2mo ( 2 ) ) call unit_test ( 'v2mo' , v2mo ( 3 ) == 'March' , 'March' , v2mo ( 3 ) ) call unit_test ( 'v2mo' , v2mo ( 4 ) == 'April' , 'April' , v2mo ( 4 ) ) call unit_test ( 'v2mo' , v2mo ( 5 ) == 'May' , 'May' , v2mo ( 5 ) ) call unit_test ( 'v2mo' , v2mo ( 6 ) == 'June' , 'June' , v2mo ( 6 ) ) call unit_test ( 'v2mo' , v2mo ( 7 ) == 'July' , 'July' , v2mo ( 7 ) ) call unit_test ( 'v2mo' , v2mo ( 8 ) == 'August' , 'August' , v2mo ( 8 ) ) call unit_test ( 'v2mo' , v2mo ( 9 ) == 'September' , 'September' , v2mo ( 9 ) ) call unit_test ( 'v2mo' , v2mo ( 10 ) == 'October' , 'October' , v2mo ( 10 ) ) call unit_test ( 'v2mo' , v2mo ( 11 ) == 'November' , 'November' , v2mo ( 11 ) ) call unit_test ( 'v2mo' , v2mo ( 12 ) == 'December' , 'December' , v2mo ( 12 ) ) call unit_test_end ( 'v2mo' ) end subroutine test_v2mo !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2d integer :: dat ( 8 ) call date_and_time ( values = dat ) call unit_test ( 'mo2d' , all ( mo2d ( 'january' , 2019 ) == [ 2019 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'January    2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'february' , 2019 ) == [ 2019 , 02 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'February   2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'march' , 2019 ) == [ 2019 , 03 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'March      2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'april' , 2019 ) == [ 2019 , 04 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'April      2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'may' , 2019 ) == [ 2019 , 05 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'May        2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'june' , 2019 ) == [ 2019 , 06 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'June       2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'july' , 2019 ) == [ 2019 , 07 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'July       2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'august' , 2019 ) == [ 2019 , 08 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'August     2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'september' , 2019 ) == [ 2019 , 09 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'September  2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'october' , 2019 ) == [ 2019 , 10 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'October    2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'november' , 2019 ) == [ 2019 , 11 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'November   2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'december' , 2019 ) == [ 2019 , 12 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'December   2019' ) call unit_test_end ( 'mo2d' ) end subroutine test_mo2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2v () call unit_test ( 'mo2v' , mo2v ( 'jan' ) == 1 , msg = 'Check January' ) call unit_test ( 'mo2v' , mo2v ( 'Feb' ) == 2 , msg = 'Check February' ) call unit_test ( 'mo2v' , mo2v ( 'March' ) == 3 , msg = 'Check March' ) call unit_test ( 'mo2v' , mo2v ( 'APR' ) == 4 , msg = 'Check April' ) call unit_test ( 'mo2v' , mo2v ( 'may' ) == 5 , msg = 'Check May' ) call unit_test ( 'mo2v' , mo2v ( 'jun' ) == 6 , msg = 'Check Jun' ) call unit_test ( 'mo2v' , mo2v ( 'july' ) == 7 , msg = 'Check July' ) call unit_test ( 'mo2v' , mo2v ( 'Aug' ) == 8 , msg = 'Check August' ) call unit_test ( 'mo2v' , mo2v ( 'Sept' ) == 9 , msg = 'Check September' ) call unit_test ( 'mo2v' , mo2v ( 'Oct' ) == 10 , msg = 'Check October' ) call unit_test ( 'mo2v' , mo2v ( 'Nov' ) == 11 , msg = 'Check November' ) call unit_test ( 'mo2v' , mo2v ( 'December' ) == 12 , msg = 'Check December' ) call unit_test ( 'mo2v' , mo2v ( 'ja' ) == 1 , msg = 'Check \"ja\"' ) call unit_test ( 'mo2v' , mo2v ( 'j' ) == - 1 , msg = 'Check \"j\"' ) call unit_test ( 'mo2v' , mo2v ( '' ) == - 1 , msg = 'Check \"\"' ) call unit_test ( 'mo2v' , mo2v ( 'jax' ) == - 1 , msg = 'Check \"jax\"' ) call unit_test_end ( 'mo2v' ) ! assume if got here passed checks end subroutine test_mo2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now call unit_test_end ( 'now' ) end subroutine test_now !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_locale () integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr real ( kind = realtime ) :: julian character ( len = :), allocatable :: expected character ( len = :), allocatable :: returned call to_upper_extended_ascii () dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|MAR|MARCH|SAT|SATURDAY|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|MARCH|MAR|MAR|SAT|SAT|SATURDAY|' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|' ) call unit_test ( 'locale' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) ! go forward one day call date_to_julian ( dat , julian , ierr ) julian = julian + 1 dat = j2d ( julian ) expected = '|MAR|MARCH|SUN|SUNDAY|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|MARCH|MAR|MAR|SUN|SUN|SUNDAY|' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|' ) call unit_test ( 'locale' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) call unit_test ( 'locale' , v2mo ( 1 ) == 'JANUARY' , 'JANUARY' , 'expected  JANUARY    got' , v2mo ( 1 ) ) call unit_test ( 'locale' , v2mo ( 2 ) == 'FEBRUARY' , 'FEBRUARY' , 'expected  FEBRUARY   got' , v2mo ( 2 ) ) call unit_test ( 'locale' , v2mo ( 3 ) == 'MARCH' , 'MARCH' , 'expected  MARCH      got' , v2mo ( 3 ) ) call unit_test ( 'locale' , v2mo ( 4 ) == 'APRIL' , 'APRIL' , 'expected  APRIL      got' , v2mo ( 4 ) ) call unit_test ( 'locale' , v2mo ( 5 ) == 'MAY' , 'MAY' , 'expected  MAY        got' , v2mo ( 5 ) ) call unit_test ( 'locale' , v2mo ( 6 ) == 'JUNE' , 'JUNE' , 'expected  JUNE       got' , v2mo ( 6 ) ) call unit_test ( 'locale' , v2mo ( 7 ) == 'JULY' , 'JULY' , 'expected  JULY       got' , v2mo ( 7 ) ) call unit_test ( 'locale' , v2mo ( 8 ) == 'AUGUST' , 'AUGUST' , 'expected  AUGUST     got' , v2mo ( 8 ) ) call unit_test ( 'locale' , v2mo ( 9 ) == 'SEPTEMBER' , 'SEPTEMBER' , 'expected  SEPTEMBER  got' , v2mo ( 9 ) ) call unit_test ( 'locale' , v2mo ( 10 ) == 'OCTOBER' , 'OCTOBER' , 'expected  OCTOBER    got' , v2mo ( 10 ) ) call unit_test ( 'locale' , v2mo ( 11 ) == 'NOVEMBER' , 'NOVEMBER' , 'expected  NOVEMBER   got' , v2mo ( 11 ) ) call unit_test ( 'locale' , v2mo ( 12 ) == 'DECEMBER' , 'DECEMBER' , 'expected  DECEMBER   got' , v2mo ( 12 ) ) call date_and_time ( values = dat ) dat = [ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ] call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'SATURDAY' . and . weekday == 6 , 'expected SATURDAY,6 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'SUNDAY' . and . weekday == 7 , 'expected SUNDAY,7 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'MONDAY' . and . weekday == 1 , 'expected MONDAY,1 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'TUESDAY' . and . weekday == 2 , 'expected TUESDAY,2 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'WEDNESDAY' . and . weekday == 3 , 'expected WEDNESDAY,3 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'THURSDAY' . and . weekday == 4 , 'expected THURSDAY,4 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'FRIDAY' . and . weekday == 5 , 'expected FRIDAY,5 got ' , day , weekday ) if ( unit_test_level > 0 ) then call locale ( 'show' ) endif call locale ( 'reset' ) if ( unit_test_level > 0 ) then call locale ( 'show' ) endif dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|Mar|March|Sat|Saturday|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'after reset macros: expected' , expected , 'returned' , returned ) expected = '|March|Mar|Mar|Sat|Sat|Saturday|Sat|Saturday|Mar|March' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|shortweekday|longweekday|shortmonth|longmonth' ) call unit_test ( 'locale' , returned . eq . expected , 'after reset keywords: expected' , expected , 'returned' , returned ) call unit_test_end ( 'locale' ) end subroutine test_locale !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i character ( len = :), allocatable :: expected character ( len = :), allocatable :: returned ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment if ( unit_test_level > 0 ) then call unit_test_msg ( 'fmtdate' , 'GIVEN:' // trim ( date1 ) // ' ' // trim ( comment )) endif call guessdate ( date1 , dat ) ! convert date string to DAT call unit_test ( 'fmtdate' , fmtdate ( dat , 'year-month-day' ) == trim ( date2 ), 'GOT' , fmtdate ( dat , 'year-month-day' ), 'expected' , date2 ) ! convert DAT to ISO week date, all generated dates should match ISO week date call unit_test ( 'fmtdate' , fmtdate ( dat , \"%I\" ) == iso_week_date , msg = iso_week_date ) enddo dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|Mar|March|Sat|Saturday|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|March|Mar|Mar|Sat|Sat|Saturday|Sat|Saturday' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|shortweekday|longweekday' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) expected = '|2nd|second|02|' returned = fmtdate ( dat , '|shortday|longday|day|' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) call unit_test_end ( 'fmtdate' ) end subroutine test_fmtdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate_usage call unit_test_end ( 'fmtdate_usage' ) end subroutine test_fmtdate_usage !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_guessdate character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment call guessdate ( date1 , dat ) ! convert date string to DAT call unit_test ( 'guessdate' ,& & fmtdate ( dat , \"%I\" ) == iso_week_date , 'input' , date1 , 'produced' , fmtdate ( dat , \"%I\" ), 'expected' , iso_week_date ) call unit_test ( 'guessdate' ,& & fmtdate ( dat , \"year-month-day\" ) == date2 , 'input' , date1 , 'produced' , fmtdate ( dat , \"year-month-day\" ), 'expected' , date2 ) enddo call unit_test_end ( 'guessdate' ) end subroutine test_guessdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dow integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) dat = [ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ] call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Saturday' . and . weekday == 6 , ' expected Saturday,6 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Sunday' . and . weekday == 7 , ' expected Sunday,7 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Monday' . and . weekday == 1 , ' expected Monday,1 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Tuesday' . and . weekday == 2 , ' expected Tuesday,2 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Wednesday' . and . weekday == 3 , ' expected Wednesday,3 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Thursday' . and . weekday == 4 , ' expected Thursday,4 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Friday' . and . weekday == 5 , ' expected Friday,5 and got ' , day , weekday ) call unit_test_end ( 'dow' ) end subroutine test_dow !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_w2d character ( len = 372 ), allocatable :: line (:) integer :: y , m , d integer :: iso_year integer :: iso_week integer :: iso_weekday integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' 2005 01 01  2004 53 6   ' , & & ' 2005 01 02  2004 53 7   ' , & & ' 2005 12 31  2005 52 6   ' , & & ' 2007 01 01  2007 01 1   ' , & & ' 2007 12 30  2007 52 7   ' , & & ' 2007 12 31  2008 01 1   ' , & & ' 2008 01 01  2008 01 2   ' , & & ' 2008 12 28  2008 52 7   ' , & & ' 2008 12 29  2009 01 1   ' , & & ' 2008 12 30  2009 01 2   ' , & & ' 2008 12 31  2009 01 3   ' , & & ' 2009 01 01  2009 01 4   ' , & & ' 2009 12 31  2009 53 4   ' , & & ' 2010 01 01  2009 53 5   ' , & & ' 2010 01 02  2009 53 6   ' , & & ' 2010 01 03  2009 53 7   ' , & & '                          ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) y , m , d , iso_year , iso_week , iso_weekday call w2d ( iso_year , iso_week , iso_weekday , dat ) ! convert ISO week date to DAT call unit_test ( 'w2d' , dat ( 1 ) == y . and . dat ( 2 ) == m . and . dat ( 3 ) == d , msg = line ( i )) ! all should match enddo call unit_test_end ( 'w2d' ) end subroutine test_w2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_box_month integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) character ( len = 21 ) :: mnth ( 8 ) dat = [ 2016 , 07 , 01 , - 240 , 12 , 0 , 0 , 0 ] mnth = [ & '      July 2016      ' , & 'Mo Tu We Th Fr Sa Su ' , & '             1  2  3 ' , & ' 4  5  6  7  8  9 10 ' , & '11 12 13 14 15 16 17 ' , & '18 19 20 21 22 23 24 ' , & '25 26 27 28 29 30 31 ' , & '                     ' ] call box_month ( dat , calendar ) if ( unit_test_level > 0 ) then write ( * , '(a)' ) calendar write ( * , '(a)' ) mnth endif call unit_test ( 'box_month' , all ( calendar == mnth ), 'July 2016' ) call unit_test_end ( 'box_month' ) end subroutine test_box_month !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2u () integer , parameter :: aday ( * ) = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] !  Note that time zones are usually -HHMM or -HH:MM and not MM, which is what the DAT array uses !  Comparing to Unix date(1) command: !    date --date \"Wed Mar 29 01:46:47 EDT 2017\" +%s      ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 2017\" +%s          ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 -400 2017\" +%s     ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-400 2017\" +%s  ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-4:00 2017\" +%s ! 1490766407 ! nint() changed to int(anint() to avoid gfortran OpenBSD bug on i386 call unit_test ( 'd2u' , int ( anint ( d2u ( aday ))) == 1490766407 , d2u ( aday ) ) call unit_test_end ( 'd2u' ) end subroutine test_d2u !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_u2d integer :: ex ( 8 ) integer :: re ( 8 ) integer :: utime utime = 1490766407 ex = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] re = u2d ( 1490766407 ) call unit_test ( 'u2d' , all ( re == ex ),& & 'EXPECTED' , 1490766407 , & & 'GOT' , d2u ( ex ) ) call unit_test_end ( 'u2d' ) end subroutine test_u2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sec2days () call unit_test ( 'sec2days' , sec2days ( 129860 ) == '1-12:04:20' , '129860 is 1-12:04:20' ) call unit_test ( 'sec2days' , sec2days ( 8000 0.0d0 ) == '0-22:13:20' , '80000.0d0 is 0-22:13:20' ) call unit_test ( 'sec2days' , sec2days ( 80000 , crop = . true .) == '22:13:20' , '80000 is 22:13:20' ) call unit_test ( 'sec2days' , sec2days ( '1day 2hr 3 min 4s' ) == '1-02:03:04' , '1day 2hr 3 min 4s is 1-02:03:04' ) call unit_test_end ( 'sec2days' ) end subroutine test_sec2days !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_days2sec () ! add 0 to nint function because of gfortran-11 bug passing some arguments with functions to class(*) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1' )) == 1 , 'expected' , 1 , 'got' , 0 + nint ( days2sec ( '1' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1:00' )) == 60 , 'expected' , 60 , 'got' , 0 + nint ( days2sec ( '1:00' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1:00:00' )) == 3600 , 'expected' , 3600 , 'got' , 0 + nint ( days2sec ( '1:00:00' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1-00:00:00' )) == 86400 , 'expected' , 86400 , 'got' , 0 + nint ( days2sec ( '1-00:00:00' ))) call unit_test ( 'days2sec' ,& & nint ( days2sec ( '1d2h 3.0 minutes 4sec' )) == 93784 , 'expected' , 1 , 'got' , 0 + nint ( days2sec ( '1d2h 3.0 minutes 4sec' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1-12:04:20              ' )) == 129860 , & & 'expected' , 129860 , 'got' , 0 + nint ( days2sec ( '1.12:03:20' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5 days                ' )) == 129600 , & & 'expected' , 129600 , 'got' , 0 + nint ( days2sec ( '1.5 days' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) == 145800 , & & 'expected' , 145800 , 'got' , 0 + nint ( days2sec ( '1.5 days 4hrs 30minutes' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5d                    ' )) == 129600 , & & 'expected' , 129600 , 'got' , 0 + nint ( days2sec ( '1.5d' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1d2h3m4s                ' )) == 93784 , & & 'expected' , 93784 , 'got' , 0 + nint ( days2sec ( '1d2h3m4s' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1d1d1d                  ' )) == 259200 , & & 'expected' , 259200 , 'got' , 0 + nint ( days2sec ( '1d1d1d' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 4d-12h                  ' )) == 302400 , & & 'expected' , 302400 , 'got' , 0 + nint ( days2sec ( '4d-12h' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 3  d  1 2   h           ' )) == 302400 , & & 'expected' , 302400 , 'got' , 0 + nint ( days2sec ( '3 d 1 s  h' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 3h10''20\"' )) == 11420 , & & 'expected' , 11420 , 'got' , 0 + nint ( days2sec ( '3 h 10''20\"' ))) call unit_test_end ( 'days2sec' ) end subroutine test_days2sec !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_phase_of_moon integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_test ( 'phase_of_moon' , phase_of_moon ( dat ) == 'Waning crescent' ) call unit_test_end ( 'phase_of_moon' ) end subroutine test_phase_of_moon !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_moon_fullness integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_test ( 'moon_fullness' , moon_fullness ( dat ) == - 30 ) call unit_test_end ( 'moon_fullness' ) end subroutine test_moon_fullness !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_easter () character ( len = 20 ), parameter :: tests ( * ) = [ & '1980,4,6  ' , & '1981,4,19 ' , & '1982,4,11 ' , & '1983,4,3  ' , & '1984,4,22 ' , & '1985,4,7  ' , & '1986,3,30 ' , & '1987,4,19 ' , & '1988,4,3  ' , & '1989,3,26 ' , & '1990,4,15 ' , & '1991,3,31 ' , & '1992,4,19 ' , & '1993,4,11 ' , & '1994,4,3  ' , & '1995,4,16 ' , & '1996,4,7  ' , & '1997,3,30 ' , & '1998,4,12 ' , & '1999,4,4  ' , & '2000,4,23 ' , & '2001,4,15 ' , & '2002,3,31 ' , & '2003,4,20 ' , & '2004,4,11 ' , & '2005,3,27 ' , & '2006,4,16 ' , & '2007,4,8  ' , & '2008,3,23 ' , & '2009,4,12 ' , & '2010,4,4  ' , & '2011,4,24 ' , & '2012,4,8  ' , & '2013,3,31 ' , & '2014,4,20 ' , & '2015,4,5  ' , & '2016,3,27 ' , & '2017,4,16 ' , & '2018,4,1  ' , & '2019,4,21 ' , & '2020,4,12 ' , & '2021,4,4  ' , & '2022,4,17 ' , & '2023,4,9  ' , & '2024,3,31 ' ] character ( len = 20 ) :: readme integer :: tmonth , tday integer :: inyear , outmonth , outday integer :: ii integer :: dat ( 8 ) character ( len = 5 ) :: mon ( 3 : 4 ) = ( / 'march' , 'april' / ) do ii = 1 , size ( tests ) readme = tests ( ii ) ! cannot do internal read on a parameter read ( readme , * ) inyear , tmonth , tday call easter ( inyear , dat ) outmonth = dat ( 2 ) outday = dat ( 3 ) call unit_test ( 'easter' , tmonth == outmonth . and . tday == outday , tests ( ii ), 'month=' , mon ( outmonth )) enddo call unit_test_end ( 'easter' ) ! assume if got here passed checks end subroutine test_easter !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now_ex call unit_test_end ( 'now_ex' ) end subroutine test_now_ex !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2w () call date_and_time ( values = dat ) dat = [ 2005 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 1 Jan 2005 2005-01-01 2004-W53-6 call showme ( \"2004-W53-6\" ) dat = [ 2005 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 2 Jan 2005 2005-01-02 2004-W53-7 call showme ( \"2004-W53-7\" ) dat = [ 2005 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 31 Dec 2005 2005-12-31 2005-W52-6 call showme ( \"2005-W52-6\" ) dat = [ 2007 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 1 Jan 2007 2007-01-01 2007-W01-1 Both years 2007 start with the same day. call showme ( \"2007-W01-1\" ) dat = [ 2007 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 30 Dec 2007 2007-12-30 2007-W52-7 call showme ( \"2007-W52-7\" ) dat = [ 2007 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 31 Dec 2007 2007-12-31 2008-W01-1 call showme ( \"2008-W01-1\" ) dat = [ 2008 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 1 Jan 2008 2008-01-01 2008-W01-2 !     Gregorian year 2008 is a leap year. ... !     ISO year 2008 is 2 days shorter: 1 day longer at the start, 3 days shorter at the end. call showme ( \"2008-W01-2\" ) dat = [ 2008 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 28 Dec 2008 2008-12-28 2008-W52-7 ... !     ISO year 2009 begins three days before the end of Gregorian 2008. call showme ( \"2008-W52-7\" ) dat = [ 2008 , 12 , 29 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 29 Dec 2008 2008-12-29 2009-W01-1 call showme ( \"2009-W01-1\" ) dat = [ 2008 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 30 Dec 2008 2008-12-30 2009-W01-2 call showme ( \"2009-W01-2\" ) dat = [ 2008 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Wed 31 Dec 2008 2008-12-31 2009-W01-3 call showme ( \"2009-W01-3\" ) dat = [ 2009 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 1 Jan 2009 2009-01-01 2009-W01-4 call showme ( \"2009-W01-4\" ) dat = [ 2009 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 31 Dec 2009 2009-12-31 2009-W53-4  ... !     ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010. call showme ( \"2009-W53-4\" ) dat = [ 2010 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Fri 1 Jan 2010 2010-01-01 2009-W53-5 call showme ( \"2009-W53-5\" ) dat = [ 2010 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 2 Jan 2010 2010-01-02 2009-W53-6 call showme ( \"2009-W53-6\" ) dat = [ 2010 , 01 , 03 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 3 Jan 2010 2010-01-03 2009-W53-7 call showme ( \"2009-W53-7\" ) call unit_test_end ( 'd2w' ) ! assume if got here passed checks end subroutine test_d2w subroutine showme ( string ) character ( len =* ) :: string integer :: iyear , iweek , iweekday character ( len = 10 ) :: name call d2w ( dat , iyear , iweek , iweekday , name ) call unit_test ( 'd2w' , name == string , iyear , iweek , iweekday , name , string ) end subroutine showme !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_modified_julian () real ( kind = realtime ) :: mjd integer :: ierr integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , abs ( mjd - 244058 7.5d0 - conv ) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2449719 - conv , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450010 - conv , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450083 - conv , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450084 - conv , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450449 - conv , msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'date_to_modified_julian' ) end subroutine test_date_to_modified_julian !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_modified_julian_to_date () real ( kind = realtime ) :: mjd integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime mjd = 245758 9.129d0 - conv ! set sample Modified Julian Date call modified_julian_to_date ( mjd , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call modified_julian_to_date ( mjd - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd - 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call modified_julian_to_date ( mjd + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd + 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'modified_julian_to_date' ) end subroutine test_modified_julian_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2m real ( kind = realtime ) :: mjd integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2449719 - conv ) , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450010 - conv ), msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450083 - conv ), msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450084 - conv ), msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450449 - conv ), msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'd2m' ) end subroutine test_d2m !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_m2d real ( kind = realtime ) :: mjd character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) mjd = 245758 9.129d0 - 240000 0.5_realtime ! set sample Modified Julian Date expected = '2016-07-19 11:05:45' dat = m2d ( mjd ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = m2d ( mjd - 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd - 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = m2d ( mjd + 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd + 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'm2d' ) end subroutine test_m2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_bas () type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: ierr integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2449719 , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450010 , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450083 , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450084 , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450449 , msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'date_to_bas' ) end subroutine test_date_to_bas !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_bas_to_date () type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime mjd = 245758 9.129d0 - conv ! set sample Modified Julian Date bas = BAStime ( int ( mjd ), mod ( mjd , 1.0d0 ) * 8640 0.0_realtime ) call bas_to_date ( bas , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call bas_to_date ( bas - 8640 0.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call bas_to_date ( bas + 8640 0.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'bas_to_date' ) end subroutine test_bas_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2b type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime !                            Modified Julian Dates ! !   To use this table, add the day-of-month to the tabulated entry. !   For example, 30 Jan 2000 = MJD 51573. ! __________________________________________________________________ !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009 integer , parameter :: array ( 1 : 12 , 2000 : 2009 ) = reshape ([ & 51543 , 51909 , 52274 , 52639 , 53004 , 53370 , 53735 , 54100 , 54465 , 54831 , & ! Jan 51574 , 51940 , 52305 , 52670 , 53035 , 53401 , 53766 , 54131 , 54496 , 54862 , & ! Feb 51603 , 51968 , 52333 , 52698 , 53064 , 53429 , 53794 , 54159 , 54525 , 54890 , & ! Mar 51634 , 51999 , 52364 , 52729 , 53095 , 53460 , 53825 , 54190 , 54556 , 54921 , & ! Apr 51664 , 52029 , 52394 , 52759 , 53125 , 53490 , 53855 , 54220 , 54586 , 54951 , & ! May 51695 , 52060 , 52425 , 52790 , 53156 , 53521 , 53886 , 54251 , 54617 , 54982 , & ! Jun 51725 , 52090 , 52455 , 52820 , 53186 , 53551 , 53916 , 54281 , 54647 , 55012 , & ! Jul 51756 , 52121 , 52486 , 52851 , 53217 , 53582 , 53947 , 54312 , 54678 , 55043 , & ! Aug 51787 , 52152 , 52517 , 52882 , 53248 , 53613 , 53978 , 54343 , 54709 , 55074 , & ! Sep 51817 , 52182 , 52547 , 52912 , 53278 , 53643 , 54008 , 54373 , 54739 , 55104 , & ! Oct 51848 , 52213 , 52578 , 52943 , 53309 , 53674 , 54039 , 54404 , 54770 , 55135 , & ! Nov 51878 , 52243 , 52608 , 52973 , 53339 , 53704 , 54069 , 54434 , 54800 , 55165 ],& ! Dec shape = shape ( array ), order = [ 2 , 1 ]) integer :: month , year dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2449719 , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450010 , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450083 , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450084 , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450449 , msg = \"Dec 31th, 1996 12:00\" ) do month = 1 , 12 do year = 2000 , 2009 !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds] dat = [ year , month , 1 , 0 , 0 , 0 , 0 , 0 ] bas = d2b ( dat ) call unit_test ( 'd2b' , array ( month , year ) + 1 == bas % base_day , year , month , array ( month , year ) + 1 , bas % base_day ) enddo enddo call unit_test_end ( 'd2b' ) end subroutine test_d2b !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_b2d type ( BAStime ) :: bas real ( kind = realtime ) :: mjd character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) mjd = 245758 9.129d0 - 240000 0.5_realtime ! set sample Modified Julian Date bas = BAStime ( int ( mjd ), mod ( mjd , 1.0d0 ) * 8640 0.0_realtime ) expected = '2016-07-19 11:05:45' dat = b2d ( bas ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = b2d ( bas - 8640 0.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd - 1.0 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = b2d ( bas + 8640 0.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd + 1.0 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'b2d' ) end subroutine test_b2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","url":"program/runtest.html"},{"title":"demo_ordinal_seconds – M_time","text":"Uses M_time Variables Type Attributes Name Initial character(len=*), parameter :: gen = '(*(g0))' integer :: i integer :: iend integer :: istart real, volatile :: x Source Code program demo_ordinal_seconds use M_time , only : ordinal_seconds implicit none character ( len =* ), parameter :: gen = '(*(g0))' integer :: i , istart , iend real , volatile :: x istart = ordinal_seconds () x = 0.0 do i = 1 , 1000000000 x = x + sqrt ( real ( i )) enddo print gen , 'x=' , x iend = ordinal_seconds () print gen , 'that took ' , iend - istart , ' seconds' print gen , iend , '-' , istart , '=' , iend - istart end program demo_ordinal_seconds","tags":"","url":"program/demo_ordinal_seconds.html"},{"title":"demo_d2b – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer, parameter :: array (1:12,2000:2009) = reshape([51543, 51909, 52274, 52639, 53004, 53370, 53735, 54100, 54465, 54831, 51574, 51940, 52305, 52670, 53035, 53401, 53766, 54131, 54496, 54862, 51603, 51968, 52333, 52698, 53064, 53429, 53794, 54159, 54525, 54890, 51634, 51999, 52364, 52729, 53095, 53460, 53825, 54190, 54556, 54921, 51664, 52029, 52394, 52759, 53125, 53490, 53855, 54220, 54586, 54951, 51695, 52060, 52425, 52790, 53156, 53521, 53886, 54251, 54617, 54982, 51725, 52090, 52455, 52820, 53186, 53551, 53916, 54281, 54647, 55012, 51756, 52121, 52486, 52851, 53217, 53582, 53947, 54312, 54678, 55043, 51787, 52152, 52517, 52882, 53248, 53613, 53978, 54343, 54709, 55074, 51817, 52182, 52547, 52912, 53278, 53643, 54008, 54373, 54739, 55104, 51848, 52213, 52578, 52943, 53309, 53674, 54039, 54404, 54770, 55135, 51878, 52243, 52608, 52973, 53339, 53704, 54069, 54434, 54800, 55165], shape=shape(array), order=[2, 1]) type(BAStime) :: bas integer :: dat (8) integer :: i integer :: j Source Code program demo_d2b use M_time , only : d2b , BAStime , d2j , d2m implicit none integer :: dat ( 8 ) type ( BAStime ) :: bas !                            Modified Julian Dates ! !   To use this table, add the day-of-month to the tabulated entry. !   For example, 30 Jan 2000 = MJD 51573. ! __________________________________________________________________ !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009 integer , parameter :: array ( 1 : 12 , 2000 : 2009 ) = reshape ([ & 51543 , 51909 , 52274 , 52639 , 53004 , 53370 , 53735 , 54100 , 54465 , 54831 , & ! Jan 51574 , 51940 , 52305 , 52670 , 53035 , 53401 , 53766 , 54131 , 54496 , 54862 , & ! Feb 51603 , 51968 , 52333 , 52698 , 53064 , 53429 , 53794 , 54159 , 54525 , 54890 , & ! Mar 51634 , 51999 , 52364 , 52729 , 53095 , 53460 , 53825 , 54190 , 54556 , 54921 , & ! Apr 51664 , 52029 , 52394 , 52759 , 53125 , 53490 , 53855 , 54220 , 54586 , 54951 , & ! May 51695 , 52060 , 52425 , 52790 , 53156 , 53521 , 53886 , 54251 , 54617 , 54982 , & ! Jun 51725 , 52090 , 52455 , 52820 , 53186 , 53551 , 53916 , 54281 , 54647 , 55012 , & ! Jul 51756 , 52121 , 52486 , 52851 , 53217 , 53582 , 53947 , 54312 , 54678 , 55043 , & ! Aug 51787 , 52152 , 52517 , 52882 , 53248 , 53613 , 53978 , 54343 , 54709 , 55074 , & ! Sep 51817 , 52182 , 52547 , 52912 , 53278 , 53643 , 54008 , 54373 , 54739 , 55104 , & ! Oct 51848 , 52213 , 52578 , 52943 , 53309 , 53674 , 54039 , 54404 , 54770 , 55135 , & ! Nov 51878 , 52243 , 52608 , 52973 , 53339 , 53704 , 54069 , 54434 , 54800 , 55165 ],& ! Dec shape = shape ( array ), order = [ 2 , 1 ]) integer :: i , j call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat bas = d2b ( dat ) write ( * , * ) 'Baseday and Seconds is' , bas write ( * , * ) 'Baseday is' , bas % base_day ! whole days since the MJD Epoch date write ( * , * ) 'Seconds is' , bas % secs ! offset in seconds from start of BASE_DAY ! print any date that does not match regression test values do i = 2000 , 2009 do j = 1 , 12 !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds] dat = [ i , j , 1 , 0 , 0 , 0 , 0 , 0 ] ! first day of month bas = d2b ( dat ) if ( array ( j , i ) + 1. ne . bas % base_day ) then write ( * , * ) i , j , array ( j , i ) + 1 , d2b ( dat ), d2m ( dat ), d2j ( dat ) - 240000 0.5 endif enddo enddo end program demo_d2b","tags":"","url":"program/demo_d2b.html"},{"title":"demo_d2u – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2u use M_time , only : d2u implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Unix Epoch time is ' , d2u ( dat ) end program demo_d2u","tags":"","url":"program/demo_d2u.html"},{"title":"demo_bas_to_date – M_time","text":"Uses M_time Variables Type Attributes Name Initial type(BAStime) :: bas integer :: dat (8) integer, parameter :: dp = kind(0.0d0) character(len=*), parameter :: g = '(*(g0,1x))' integer :: ierr type(BAStime) :: tomorrow type(BAStime) :: yesterday Source Code program demo_bas_to_date use M_time , only : bas_to_date , fmtdate , realtime , BAStime implicit none integer , parameter :: dp = kind ( 0.0d0 ) type ( BAStime ) :: bas , tomorrow , yesterday integer :: dat ( 8 ) integer :: ierr character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'bas_to_date:' ! set sample Baseday and Seconds date bas = BAStime ( 60700 , 0.213682349771_dp ) ! create DAT array for this date call bas_to_date ( bas , dat , ierr ) write ( * , g ) 'Sample Date=' , fmtdate ( dat ) ! write ( * , g ) 'add and subtract days from base_day:' ! go back one day yesterday = BAStime ( bas % base_day - 1 , bas % secs ) call bas_to_date ( yesterday , dat , ierr ) write ( * , g ) 'Day Before =' , fmtdate ( dat ) ! ! go forward one day tomorrow = BAStime ( bas % base_day + 1 , bas % secs ) call bas_to_date ( tomorrow , dat , ierr ) write ( * , g ) 'Day After  =' , fmtdate ( dat ) write ( * , g ) 'add and subtract seconds from BAS:' ! go back one day yesterday = bas - 86400 call bas_to_date ( yesterday , dat , ierr ) write ( * , g ) 'Day Before =' , fmtdate ( dat ) ! ! go forward one day yesterday = bas + 86400 call bas_to_date ( tomorrow , dat , ierr ) write ( * , g ) 'Day After  =' , fmtdate ( dat ) ! end program demo_bas_to_date","tags":"","url":"program/demo_bas_to_date.html"},{"title":"demo_guessdate – M_time","text":"Uses M_time Variables Type Attributes Name Initial character(len=:), allocatable :: answer integer :: dat (8) character(len=20), allocatable :: datestrings (:) integer :: i Source Code program demo_guessdate use M_time , only : guessdate , fmtdate implicit none character ( len = 20 ), allocatable :: datestrings (:) character ( len = :), allocatable :: answer integer :: dat ( 8 ) integer :: i datestrings = [ & & 'January 9th, 2001   ' ,& & ' Tue Jul 19 2016    ' ,& & ' 21/12/2016         ' ,& & ' 4th of Jul 2004    ' ] do i = 1 , size ( datestrings ) write ( * , '(a)' ) repeat ( '-' , 80 ) write ( * , * ) 'TRYING ' , datestrings ( i ) call guessdate ( datestrings ( i ), dat ) write ( * , * ) 'DAT ARRAY ' , dat answer = fmtdate ( dat ) write ( * , * ) 'FOR ' // datestrings ( i ) // ' GOT ' // trim ( answer ) enddo end program demo_guessdate","tags":"","url":"program/demo_guessdate.html"},{"title":"testit – M_time","text":"Uses M_time Source Code program testit use M_time , only : now , locale call locale ( 'show' ) write ( * , * ) now () call locale ( 'LANGUAGE' ) call locale ( 'show' ) write ( * , * ) now () call locale ( 'french' ) call locale ( 'show' ) write ( * , * ) now () call locale ( 'LANGUAGE' ) call locale ( 'show' ) write ( * , * ) now () end program testit","tags":"","url":"program/testit.html"},{"title":"demo_v2mo – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: i Source Code program demo_v2mo use M_time , only : v2mo implicit none integer :: i write ( * , * )( v2mo ( i ), i = 1 , 13 ) end program demo_v2mo","tags":"","url":"program/demo_v2mo.html"},{"title":"demo_mo2v – M_time","text":"Uses M_time Source Code program demo_mo2v use M_time , only : mo2v implicit none write ( * , * ) mo2v ( \"April\" ) write ( * , * ) mo2v ( 'Apr' ) write ( * , * ) mo2v ( 'sexember' ) write ( * , * ) mo2v ( 'unknown' ) ! returns -1 end program demo_mo2v","tags":"","url":"program/demo_mo2v.html"},{"title":"demo_julian_to_date – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) integer :: ierr real(kind=realtime) :: juliandate Source Code program demo_julian_to_date use M_time , only : julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr ! set sample Julian Date juliandate = 245758 9.129_dp ! create DAT array for this date call julian_to_date ( juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call julian_to_date ( juliandate - 1.0_dp , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call julian_to_date ( juliandate + 1.0_dp , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_julian_to_date","tags":"","url":"program/demo_julian_to_date.html"},{"title":"testit – M_time","text":"Uses M_time iso_fortran_env Subroutines subroutine to_upper_extended_ascii () Arguments None Source Code program testit use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT use M_time , only : now , locale call to_upper_extended_ascii () call locale ( 'chars' ) call locale ( 'show' ) call locale ( 'fr_FR' ) call locale ( 'show' ) call locale ( 'reset' ) ! recursive I/O is currently non-standard write ( stderr , * ) now ( 'help' ) write ( * , * ) now ( '%L %l %d %N %w %W' ) contains subroutine to_upper_extended_ascii () character ( len =* ), parameter :: month_names ( * ) = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH' , 'APRIL' , 'MAY' , 'JUNE' ,& & 'JULY' , 'AUGUST' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] character ( len =* ), parameter :: weekday_names ( * ) = [ character ( len = 10 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , & & 'SATURDAY' , 'SUNDAY' ] character ( len =* ), parameter :: month_names_abbr ( * ) = month_names (:)( 1 : 3 ) character ( len =* ), parameter :: weekday_names_abbr ( * ) = weekday_names (:)( 1 : 3 ) call locale ( 'user' , month_names , weekday_names , month_names_abbr , weekday_names_abbr ) end subroutine to_upper_extended_ascii end program testit","tags":"","url":"program/testit~2.html"},{"title":"demo_phase_of_moon – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_phase_of_moon use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' ) 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_phase_of_moon","tags":"","url":"program/demo_phase_of_moon.html"},{"title":"demo_w2d – M_time","text":"Uses M_time Subroutines subroutine printit (iso_year, iso_week, iso_weekday) Arguments Type Intent Optional Attributes Name integer :: iso_year integer :: iso_week integer :: iso_weekday Source Code program demo_w2d use M_time , only : w2d , fmtdate implicit none write ( * , '(a)' )& & 'Given Monday 29 December 2008 is written \"2009-W01-1\"' call printit ( 2009 , 1 , 1 ) write ( * , '(a)' )& & 'Given Sunday 3 January 2010 is written \"2009-W53-7\"' call printit ( 2009 , 53 , 7 ) write ( * , '(a)' )& & 'Given the Gregorian date Sun 31 December 2006 & &is written 2006-W52-7' call printit ( 2006 , 52 , 7 ) write ( * , '(a)' )& & 'Given 27 September 2008 is 2008-W39-6' call printit ( 2008 , 39 , 6 ) string : block character ( len =* ), parameter :: array ( 4 ) = [ character ( len = 80 ) :: & & '2008-W39-6' , '2008W396' , '2008-W39' , '2008W39' ] integer :: dat ( 8 ) integer :: i do i = 1 , size ( array ) write ( * , '(a)' )& & 'Given string ' // array ( i ) call w2d ( array ( i ), dat ) write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) enddo endblock string contains subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO-8601 Week: 2016-W29-1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * , '(a,i0)' ) 'GIVEN:           ' write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) end subroutine printit end program demo_w2d","tags":"","url":"program/demo_w2d.html"},{"title":"demo_date_to_modified_julian – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) character(len=*), parameter :: g = '(*(g0,1x))' integer :: ierr real(kind=realtime) :: juliandate real(kind=realtime) :: modified_juliandate Source Code program demo_date_to_modified_julian use M_time , only : date_to_modified_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: modified_juliandate real ( kind = realtime ) :: juliandate integer :: ierr character ( len =* ), parameter :: g = '(*(g0,1x))' ! ! generate DAT array call date_and_time ( values = dat ) ! ! show DAT array write ( * , '(\"Today is:\",*(i0:,\":\"))' ) dat ! ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , g ) 'Expecting:' , juliandate - 240000 0.5_realtime ! ! convert DAT to Modified Julian Date call date_to_modified_julian ( dat , modified_juliandate , ierr ) write ( * , g ) 'Modified Julian Date is ' , modified_juliandate end program demo_date_to_modified_julian","tags":"","url":"program/demo_date_to_modified_julian.html"},{"title":"demo_M_time – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) character(len=:), allocatable :: friendly character(len=*), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' real(kind=realtime) :: julian real(kind=realtime) :: unixtime Source Code program demo_M_time use M_time , only : j2d , d2j , u2d , d2u , fmtdate , realtime integer :: dat ( 8 ) real ( kind = realtime ) :: julian , unixtime character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' character ( len = :), allocatable :: friendly friendly = '%W, %L %d, %Y %H:%m:%s %N' ! a nice friendly format call date_and_time ( values = dat ) ! current time is placed in array write ( * , * ) 'Today' write ( * , * ) 'ISO       ' , fmtdate ( dat , iso_fmt ) write ( * , * ) 'Friendly  ' , fmtdate ( dat , friendly ) write ( * , * ) 'ISO week  ' , fmtdate ( dat , '%I' ) julian = d2j ( dat ) unixtime = d2u ( dat ) write ( * , * ) 'Yesterday' ! subtract a day from scalar time and print write ( * , * ) '          ' , fmtdate ( u2d ( unixtime - 86400 ), iso_fmt ) write ( * , * ) '          ' , fmtdate ( j2d ( julian - 1.0 ), friendly ) write ( * , * ) '          ' , fmtdate ( j2d ( julian - 1.0 ), '%I' ) write ( * , * ) 'Tomorrow' ! add a day to scalar time and print write ( * , * ) '          ' , fmtdate ( u2d ( unixtime + 86400 ), iso_fmt ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 1.0 ), friendly ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 1.0 ), '%I' ) write ( * , * ) 'Next Week' ! add a week to scalar time and print write ( * , * ) '          ' , fmtdate ( u2d ( unixtime + 7 * 86400 ), iso_fmt ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 7.0 ), friendly ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 7.0 ), '%I' ) end program demo_M_time","tags":"","url":"program/demo_m_time.html"},{"title":"demo_fmtdate – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_fmtdate use M_time , only : fmtdate implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , * ) fmtdate ( dat , \"current date: %w, %l %d, %Y %H:%m:%s %N\" ) end program demo_fmtdate","tags":"","url":"program/demo_fmtdate.html"},{"title":"demo_now – M_time","text":"Uses M_time Source Code program demo_now use M_time , only : now , locale implicit none ! MACROS write ( * , * ) now ( \"The current date is & &%w, %l %d, %Y %H:%m:%s %N\" ) ! If macros are not found substitute values for KEYWORDS write ( * , * ) now ( \"The current date is & &year/month/day hour:minute:second timezone\" ) write ( * , * ) now ( \"The current date is & &longweekday at HOUR GOOD, longmonth shortday, year\" ) ! including some HIGH-LEVEL KEYWORDS write ( * , * ) now ( \"iso\" ) ! and if no keywords are found, ABBREVIATED MACROS write ( * , * ) now ( \"Y-M-D h:m:s\" ) ! and basic INTERNATIONALIZATION is available call locale ( 'french' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) call locale ( 'slovak' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) call locale ( 'spanish' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) end program demo_now","tags":"","url":"program/demo_now.html"},{"title":"TimeThis_exe – M_time","text":"Uses M_time iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: all = '(*(g0,1x))' character(len=:), allocatable :: command character(len=:), allocatable :: endtime integer :: ier integer(kind=int64) :: jtime (2) character(len=:), allocatable :: starttime Functions function millisec2days (milliseconds) result(dhms) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: milliseconds Return Value character(len=:), allocatable function run (command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command Return Value integer Subroutines subroutine get_cmd (command, status) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: command integer, intent(out) :: status subroutine millijulian (jm, timestr) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out) :: jm character(len=:), allocatable :: timestr subroutine say_hello () Arguments None Source Code program TimeThis_exe !@(#) timethis(1): Emulate the DOS TimeThis command with standard Fortran use M_time , only : fmtdate use , intrinsic :: iso_fortran_env , only : int64 use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT ! @(#) given a command on the command line run the command and print wallclock time and echo command implicit none character ( len =* ), parameter :: all = '(*(g0,1x))' integer :: ier character ( len = :), allocatable :: command , starttime , endtime integer ( kind = int64 ) :: jtime ( 2 ) call get_cmd ( command , ier ) ! get the command including an attempt to requote quoted strings if ( ier . eq . 0 ) then call millijulian ( jtime ( 1 ), starttime ) if ( command . ne . '' ) ier = run ( command ) call millijulian ( jtime ( 2 ), endtime ) write ( * , all ) 'TimeThis :  Command Line : ' , trim ( adjustl ( command )) write ( * , all ) 'TimeThis :    Start Time : ' , starttime write ( * , all ) 'TimeThis :      End Time : ' , endtime write ( * , all ) 'TimeThis :  Elapsed Time : ' , millisec2days ( jtime ( 2 ) - jtime ( 1 ) ) !------------------------------------------------------ !TimeThis :  Command Line :  dir !TimeThis :    Start Time :  Wed Dec 23 12:29:38 2020 !TimeThis :      End Time :  Wed Dec 23 12:29:39 2020 !TimeThis :  Elapsed Time :  00:00:00.077 !------------------------------------------------------ else write ( * , all ) '<ERROR>*TimeThis* STATUS:' , ier endif contains function run ( command ) ! @(#) M_system run(3f) call execute_command_line as a function character ( len =* ), intent ( in ) :: command integer :: exitstat integer :: cmdstat integer :: run character ( len = 256 ) :: cmdmsg cmdmsg = ' ' call execute_command_line ( trim ( command ), wait = . true ., exitstat = exitstat , cmdstat = cmdstat , cmdmsg = cmdmsg ) if ( cmdstat . ne . 0 ) then write ( stderr , * ) trim ( cmdmsg ) endif run = cmdstat end function run function millisec2days ( milliseconds ) result ( dhms ) ! @(#) M_time millisec2days(3f) converts milliseconds to string showing days of form D-HH:MM:SS.SSS integer ( kind = int64 ), intent ( in ) :: milliseconds integer ( kind = int64 ) :: days , hours , minutes , secsleft , left integer ( kind = int64 ), parameter :: ONE_DAY = 86400 , ONE_HOUR = 3600 , ONE_MINUTE = 60 character ( len = :), allocatable :: dhms character ( len = 40 ) :: scratch secsleft = milliseconds / 1000 left = mod ( milliseconds , 1000 ) days = secsleft / ONE_DAY ! get whole number of days secsleft = secsleft - days * ONE_DAY ! calculate remainder hours = secsleft / ONE_HOUR ! get whole number of hours secsleft = secsleft - hours * ONE_HOUR minutes = secsleft / ONE_MINUTE ! get whole number of minutes secsleft = secsleft - minutes * ONE_MINUTE write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) days , hours , minutes , secsleft , left dhms = trim ( scratch ) end function millisec2days subroutine get_cmd ( command , status ) ! @(#) compose a command from all the arguments passed to the program character ( len =* ), parameter :: gen = '(*(g0))' character ( len = :), allocatable , intent ( out ) :: command ! string of all arguments to create integer , intent ( out ) :: status ! status (non-zero means error) integer :: i , j character ( len = :), allocatable :: value , valueb ! hold individual arguments one at a time character ( len = 255 ) :: errmsg integer :: length ! length of individual arguments command = \"\" ! initialize returned output string errmsg = \"\" status = 0 ERRORS : BLOCK do i = 1 , command_argument_count () !call get_command_argument(i,length=length,status=status,errmsg=errmsg)   ! get length of next argument call get_command_argument ( i , length = length , status = status ) ! get length of next argument if ( status . ne . 0 ) exit ERRORS value = repeat ( ' ' , length ) !call get_command_argument(i,value=value,status=status,errmsg=errmsg)     ! get next argument call get_command_argument ( i , value = value , status = status ) ! get next argument if ( status /= 0 ) exit ERRORS if ( length . gt . 0 ) then ! SIMPLISTIC GUESS AT RE-QUOTING STRING ! assuming an operating system shell that strips the quotes from quoted strings on the command line. ! if argument contains a space and does not contain a double-quote ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. if ( index ( value , ' ' ). ne . 0. and . index ( value , '\"' ). eq . 0 ) then value = '\"' // value // '\"' elseif ( index ( value , '\"' ). ne . 0 ) then ! assume you double doublequotes to escape them and short enough that reallocating a lot not an issue valueb = '' do j = 1 , len ( value ) if ( value ( j : j ) == '\"' ) valueb = valueb // '\"' valueb = valueb // value ( j : j ) enddo value = '\"' // valueb // '\"' endif command = command // ' ' // value ! append strings together else command = command // '\"\"' endif enddo return endblock ERRORS write ( stderr , gen ) '*get_cmd* error obtaining argument ' , i , 'errmsg=' , trim ( errmsg ) stop end subroutine get_cmd subroutine millijulian ( jm , timestr ) ! @(#)millijulian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date in milliseconds in Zulu timezone integer :: dat ( 8 ) integer ( kind = int64 ) :: a , y , m , jdn , utc integer ( kind = int64 ), intent ( out ) :: jm character ( len = :), allocatable :: timestr call date_and_time ( values = dat ) timestr = fmtdate ( dat , 'wkday Mth day hour:minute:second year' ) associate & &( year => dat ( 1 ), month => dat ( 2 ), day => dat ( 3 ), hour => dat ( 5 ), minute => dat ( 6 ), second => dat ( 7 ), milli => dat ( 8 )) !  You must first compute the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) a = ( 14_int64 - month ) / 12_int64 ! A will be 1 for January or February, and 0 for other months, with integer truncation y = year + 4800_int64 - a m = month + 12_int64 * a - 3_int64 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero ! intentionally computing with integer truncation jdn = day + ( 153_int64 * m + 2_int64 ) / 5_int64 + 365_int64 * y + y / 4_int64 - y / 100_int64 + y / 400_int64 - 32045_int64 !  Finding the Julian time in milliseconds given the JDN (Julian day number) and time of day jm = ( jdn * 86400_int64 + hour * 3600_int64 + minute * 60_int64 + second ) * 1000_int64 + milli end associate utc = dat ( 4 ) * 60 * 1000 ! Time difference with UTC in minutes converted to milliseconds jm = jm + utc ! set all values to Zulu time end subroutine millijulian subroutine say_hello () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options character ( len =* ), parameter :: all = '(*(g0,1x))' character ( len =* ), parameter :: chs = '(*(g0))' character ( len = 2 ) :: ch , split integer :: argument_length , istat , posix , dos , i character ( len = :), allocatable :: progname , options call get_command_argument ( number = 0 , length = argument_length ) if ( allocated ( progname )) deallocate ( progname ) allocate ( character ( len = argument_length ) :: progname ) call get_command_argument ( 0 , progname , status = istat ) if ( istat == 0 ) then print all , \"program name.:\" // trim ( progname ) else print all , \"Could not get the program name \" // trim ( progname ) endif print all , 'compiled by..:' , compiler_version () options = ' ' // compiler_options () if ( options /= '' ) then print all , 'using options:' ! guess which one posix = 0 dos = 0 do i = 2 , len ( options ) ch = options ( i - 1 : i ) select case ( ch ) case ( ' -' ); posix = posix + 1 case ( ' /' ); dos = dos + 1 end select enddo split = merge ( ' -' , ' /' , posix > 0 ) do i = 2 , len ( options ) ch = options ( i - 1 : i ) if ( ch == split ) then write ( * , chs , advance = 'no' ) char ( 10 ), ch else write ( * , chs , advance = 'no' ) ch ( 2 : 2 ) endif enddo print all endif print all end subroutine say_hello end program TimeThis_exe","tags":"","url":"program/timethis_exe.html"},{"title":"howlong_exe – M_time","text":"Uses M_CLI2 iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: all = '(*(g0,1x))' character(len=:), allocatable :: command character(len=:), allocatable :: help_text (:) integer :: ier integer(kind=int64) :: jtime (2) character(len=:), allocatable :: version_text (:) Functions function millijulian () Arguments None Return Value integer(kind=int64) function millisec2days (milliseconds) result(dhms) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: milliseconds Return Value character(len=:), allocatable function run (command) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: command Return Value integer Subroutines subroutine get_cmd (command, status) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: command integer, intent(out) :: status subroutine setup () Arguments None Source Code program howlong_exe ! @(#) given a command on the command line run the command and print wallclock time and echo command use , intrinsic :: iso_fortran_env , only : int64 use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT use M_CLI2 , only : set_args , lget , rget , sgets implicit none character ( len =* ), parameter :: all = '(*(g0,1x))' integer :: ier character ( len = :), allocatable :: command integer ( kind = int64 ) :: jtime ( 2 ) character ( len = :), allocatable :: help_text (:) character ( len = :), allocatable :: version_text (:) call setup () call set_args ( ' ' , help_text = help_text , version_text = version_text ) call get_cmd ( command , ier ) ! get the command including an attempt to requote quoted strings if ( ier . eq . 0 ) then jtime ( 1 ) = millijulian () if ( command . ne . '' ) ier = run ( command ) jtime ( 2 ) = millijulian () write ( * , all ) 'Wallclock:' , millisec2days ( jtime ( 2 ) - jtime ( 1 ) ), ':command:' , trim ( adjustl ( command )) else write ( * , all ) '<ERROR>STATUS:' , ier endif contains function run ( command ) ! @(#) M_system run(3f) call execute_command_line as a function character ( len =* ), intent ( in ) :: command integer :: exitstat integer :: cmdstat integer :: run character ( len = 256 ) :: cmdmsg cmdmsg = ' ' call execute_command_line ( trim ( command ), wait = . true ., exitstat = exitstat , cmdstat = cmdstat , cmdmsg = cmdmsg ) if ( cmdstat . ne . 0 ) then write ( stderr , * ) trim ( cmdmsg ) endif run = cmdstat end function run function millisec2days ( milliseconds ) result ( dhms ) ! @(#) M_time millisec2days(3f) converts milliseconds to string showing days of form D-HH:MM:SS.SSS integer ( kind = int64 ), intent ( in ) :: milliseconds integer ( kind = int64 ) :: days , hours , minutes , secsleft , left integer ( kind = int64 ), parameter :: ONE_DAY = 86400 , ONE_HOUR = 3600 , ONE_MINUTE = 60 character ( len = :), allocatable :: dhms character ( len = 40 ) :: scratch secsleft = milliseconds / 1000 left = mod ( milliseconds , 1000 ) days = secsleft / ONE_DAY ! get whole number of days secsleft = secsleft - days * ONE_DAY ! calculate remainder hours = secsleft / ONE_HOUR ! get whole number of hours secsleft = secsleft - hours * ONE_HOUR minutes = secsleft / ONE_MINUTE ! get whole number of minutes secsleft = secsleft - minutes * ONE_MINUTE write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) days , hours , minutes , secsleft , left dhms = trim ( scratch ) end function millisec2days subroutine get_cmd ( command , status ) ! @(#) compose a command from all the arguments passed to the program character ( len =* ), parameter :: gen = '(*(g0))' character ( len = :), allocatable , intent ( out ) :: command ! string of all arguments to create integer , intent ( out ) :: status ! status (non-zero means error) integer :: i , j character ( len = :), allocatable :: value , valueb ! hold individual arguments one at a time character ( len = 255 ) :: errmsg integer :: length ! length of individual arguments command = \"\" ! initialize returned output string errmsg = \"\" status = 0 ERRORS : BLOCK do i = 1 , command_argument_count () !call get_command_argument(i,length=length,status=status,errmsg=errmsg)   ! get length of next argument call get_command_argument ( i , length = length , status = status ) ! get length of next argument if ( status . ne . 0 ) exit ERRORS value = repeat ( ' ' , length ) !call get_command_argument(i,value=value,status=status,errmsg=errmsg)     ! get next argument call get_command_argument ( i , value = value , status = status ) ! get next argument if ( status /= 0 ) exit ERRORS if ( length . gt . 0 ) then ! SIMPLISTIC GUESS AT RE-QUOTING STRING ! assuming an operating system shell that strips the quotes from quoted strings on the command line. ! if argument contains a space and does not contain a double-quote ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. if ( index ( value , ' ' ). ne . 0. and . index ( value , '\"' ). eq . 0 ) then value = '\"' // value // '\"' elseif ( index ( value , '\"' ). ne . 0 ) then ! assume you double doublequotes to escape them and short enough that reallocating a lot not an issue valueb = '' do j = 1 , len ( value ) if ( value ( j : j ) == '\"' ) valueb = valueb // '\"' valueb = valueb // value ( j : j ) enddo value = '\"' // valueb // '\"' endif command = command // ' ' // value ! append strings together else command = command // '\"\"' endif enddo return endblock ERRORS write ( stderr , gen ) '*get_cmd* error obtaining argument ' , i , 'errmsg=' , trim ( errmsg ) stop end subroutine get_cmd function millijulian () ! @(#)millijulian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date in milliseconds in Zulu timezone integer :: dat ( 8 ) integer ( kind = int64 ) :: a , y , m , jdn , utc , millijulian call date_and_time ( values = dat ) associate & &( year => dat ( 1 ), month => dat ( 2 ), day => dat ( 3 ), hour => dat ( 5 ), minute => dat ( 6 ), second => dat ( 7 ), milli => dat ( 8 )) !  You must first compute the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) a = ( 14_int64 - month ) / 12_int64 ! A will be 1 for January or February, and 0 for other months, with integer truncation y = year + 4800_int64 - a m = month + 12_int64 * a - 3_int64 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero ! intentionally computing with integer truncation jdn = day + ( 153_int64 * m + 2_int64 ) / 5_int64 + 365_int64 * y + y / 4_int64 - y / 100_int64 + y / 400_int64 - 32045_int64 !  Finding the Julian time in milliseconds given the JDN (Julian day number) and time of day millijulian = ( jdn * 86400_int64 + hour * 3600_int64 + minute * 60_int64 + second ) * 1000_int64 + milli end associate utc = dat ( 4 ) * 60 * 1000 ! Time difference with UTC in minutes converted to milliseconds millijulian = millijulian + utc ! set all values to Zulu time end function millijulian subroutine setup () help_text = [ CHARACTER ( LEN = 128 ) :: & 'help_text=[ CHARACTER(LEN=128) :: &' ,& '                                   ' ,& 'NAME                               ' ,& '  howlong(1) - display wallclock time taken to execute a system command' ,& '                                                                       ' ,& 'SYNOPIS                                                                ' ,& '                                                                       ' ,& '  howlong SYSTEM_COMMAND                                               ' ,& '                                                                       ' ,& '   or                                                                  ' ,& '                                                                       ' ,& '  howlong --help|--version                                             ' ,& '                                                                       ' ,& 'DESCRIPTION                                                            ' ,& '                                                                       ' ,& 'Perhaps the simplest performance metric is to just measure the         ' ,& 'wallclock time taken by a program. This could literally be measured    ' ,& 'using a conventional clock or stopwatch. This is difficult to automate!' ,& 'So typically a command like the GNU/Linux or Unix command time(1) is used.' ,& '                                                                          ' ,& 'Commands such as time(1)                                                  ' ,& 'often provide more than wallclock times too. But lets construct a wallclock' ,& 'timing tool of our own using standard Fortran (not even the ISO_C_Binding  ' ,& 'interface will be called upon) that will measure the run time of a command.' ,& '                                                                           ' ,& 'Once passed a command to time on the command line, it will then run        ' ,& 'the command and report the wallclock time use by the program, and echo     ' ,& 'the command.                                                               ' ,& '                                                                           ' ,& 'Next we provide a simple program that calls the routine(s) of interest     ' ,& 'enough times to get useful timing information and time it.                 ' ,& '                                                                           ' ,& 'So lets say we compiled up the test program using two different sets of    ' ,& 'compiler options:                                                          ' ,& '                                                                           ' ,& '    f90 little_test.f90 -O0 -o little_test0                                ' ,& '    f90 little_test.f90 -O3 -o little_test3                                ' ,& '                                                                           ' ,& 'Now to run the programs via our timing utility only takes a few commands:  ' ,& '                                                                           ' ,& '    howlong ./little_test0                                                 ' ,& '    Wallclock: 0-00:00:25.461 :command: ./little_test0                     ' ,& '    howlong ./little_test3                                                 ' ,& '    Wallclock: 0-00:00:10.274 :command: ./little_test3                     ' ,& '                                                                           ' ,& 'SAMPLE SUBJECT PROGRAM                                                     ' ,& '                                                                           ' ,& 'An uninstrumented test program for timing :                                ' ,& '                                                                           ' ,& '   program little_test                                                     ' ,& '   use,intrinsic :: iso_fortran_env, only : int8                           ' ,& '   implicit none                                                           ' ,& '   character(len=*),parameter             :: original = \"abcdxyz ZXYDCBA _!@\"' ,& '   integer,parameter                      :: how_many_times = 100000000      ' ,& '   character(len=:),volatile,allocatable  :: t                               ' ,& '   integer                                :: i                               ' ,& '      do i=1,how_many_times                                                  ' ,& '        t=upper(original)                                                    ' ,& '        t=lower(original)                                                    ' ,& '      enddo                                                                  ' ,& '   contains                                                                  ' ,& '   function upper(str) result(translated)                                    ' ,& '   integer(kind=int8), parameter :: &                                        ' ,& '   & ascii_diff = abs(iachar(''A'',kind=int8) - iachar(''a'',kind=int8))     ' ,& '   character(*), intent(in) :: str                                           ' ,& '   integer :: i                                                              ' ,& '   character(len=len(str)) :: translated                                     ' ,& '                                                                             ' ,& '      translated=str                                                         ' ,& '      do i = 1, len(str)                                                     ' ,& '        select case(str(i:i))                                                ' ,& '          case(\"a\":\"z\")                                                      ' ,& '            translated(i:i) = achar(iachar(str(i:i))-ascii_diff)             ' ,& '        end select                                                           ' ,& '      enddo                                                                  ' ,& '   end function upper                                                        ' ,& '                                                                             ' ,& '   function lower(str) result(translated)                                    ' ,& '   integer(kind=int8), parameter :: &                                        ' ,& '   & ascii_diff = abs(iachar(''A'',kind=int8) - iachar(''a'',kind=int8))     ' ,& '   character(*), intent(in) :: str                                           ' ,& '   integer :: i                                                              ' ,& '   character(len=len(str)) :: translated                                     ' ,& '                                                                             ' ,& '      translated=str                                                         ' ,& '      do i = 1, len(str)                                                     ' ,& '        select case(str(i:i))                                                ' ,& '          case(\"A\":\"Z\")                                                      ' ,& '            translated(i:i) = achar(iachar(str(i:i))+ascii_diff)             ' ,& '        end select                                                           ' ,& '      enddo                                                                  ' ,& '   end function lower                                                        ' ,& '                                                                             ' ,& '   end program little_test                                                   ' ,& '                                                                             ' ,& 'FOOTNOTES                                                                    ' ,& '                                                                             ' ,& 'Note that in many HPC environments programs are often run via a job          ' ,& 'scheduler like Slurm, LSF, PBS, Torque, ... . In these environments          ' ,& 'there are usually account records of each job that provide resource          ' ,& 'usage statistics.                                                            ' ,& '                                                                             ' ,& 'OPTIONS                                                                      ' ,& '   --help      display this help and exit                                    ' ,& '   --version   output version information and exit                           ' ,& '                                                                             ' ,& 'EXAMPLES                                                                     ' ,& '    howlong ./myprogram                                                      ' ,& '                                                                             ' ,& 'SEE ALSO                                                                     ' ,& '    gprof(1), gcov(1)                                                        ' ,& '' ] version_text = [ CHARACTER ( LEN = 128 ) :: & 'version_text=[ CHARACTER(LEN=128) :: &' ,& '@(#)PRODUCT:         GPF (General Purpose Fortran) utilities and examples' ,& '@(#)PROGRAM:         howlong(1)                                          ' ,& '@(#)DESCRIPTION:     run a system command and return wallclock time it took to execute' ,& '@(#)VERSION:         1.0.0, 2024-09-28                                                ' ,& '@(#)AUTHOR:          John S. Urban                                                    ' ,& '@(#)HOME PAGE:       https://github.com/urbanjost?tab=repositories                    ' ,& '@(#)LICENSE:         MIT License                                                      ' ,& '' ] end subroutine setup end program howlong_exe","tags":"","url":"program/howlong_exe.html"},{"title":"month_exe – M_time","text":"Uses M_time M_kracken95 Variables Type Attributes Name Initial integer :: c character(len=21) :: calen (8) = '                    ' character(len=len=(21+2)*3) :: calenyear (8*4) = '                      ' character(len=21) :: cscr integer :: dat_values (8) character(len=*), parameter :: ident = \"@(#)month(1f):print calendar\" integer :: month integer :: r Subroutines subroutine help_usage (l_help) Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_help subroutine help_version (l_version) Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: l_version Source Code program month_exe use M_kracken95 , only : kracken , iget , lget , sget ! command line parsing use M_time , only : box_month , mo2v , locale ! date and time implicit none character ( len =* ), parameter :: ident = \"@(#)month(1f):print calendar\" character ( len = 21 ) :: calen ( 8 ) = '                    ' ! character array to hold month character ( len = ( 21 + 2 ) * 3 ) :: calenyear ( 8 * 4 ) = '                      ' ! character array to hold year integer :: month ! values of command line options integer :: dat_values ( 8 ) ! date array integer :: r , c ! row and column for month in one-year calendar character ( len = 21 ) :: cscr call date_and_time ( values = dat_values ) ! get current time and date call kracken ( 'month' , ' -year -month 0 -help .f. -version .f.' ) ! crack command line arguments call help_usage ( lget ( 'month_help' )) ! print help information and stop if requested call help_version ( lget ( 'month_version' )) ! print version information and stop if requested call locale ( 'LANGUAGE' ) !----------------------------------------------------------------------------------------------------------------------------------- ! use user-specified year date instead of current year. Try reading year from two places (-oo and -year) on command line if ( sget ( 'month_year' ) /= ' ' ) then ! check -year option for a year value dat_values ( 1 ) = iget ( 'month_year' ) ! if value was specified use it elseif ( sget ( 'month_oo' ) /= ' ' ) then dat_values ( 1 ) = iget ( 'month_oo' ) ! check -oo option for a year value if did not find -year VALUE endif !write(*,*)'YEAR=',dat_values(1) !----------------------------------------------------------------------------------------------------------------------------------- cscr = sget ( 'month_month' ) ! get month as string so can see if name or number or blank if ( cscr /= '' ) then select case ( cscr ( 1 : 1 )) case ( 'A' : 'Z' , 'a' : 'z' ) ! assume month name instead of month number month = mo2v ( trim ( cscr )) case default ! month is number month = iget ( 'month_month' ) end select else ! keyword given but no value, default to current month month = dat_values ( 2 ) endif !----------------------------------------------------------------------------------------------------------------------------------- if ( month == 0 ) then ! no month specified, display an entire year do r = 1 , 4 ! display year in four rows do c = 1 , 3 ! three months per row dat_values ( 2 ) = c + ( r - 1 ) * 3 call box_month ( dat_values , calen ) calenyear ( 8 * r - 7 : 8 * r )( 23 * c - 22 : 23 * c ) = calen ! copy month into large year array enddo enddo write ( * , '(a)' ) calenyear else ! do a month dat_values ( 2 ) = month call box_month ( dat_values , calen ) write ( * , '(a)' ) calen endif !----------------------------------------------------------------------------------------------------------------------------------- contains !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   month(1f) - [TIME] display a calendar                                        ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   month [[ -year] NNNN] [ -month NN|month_name]                                ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   month(1) displays a simple calendar. If no arguments are specified,          ' ,& '   the current year is displayed.                                               ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   -month NN   Display single month output. The month is numeric (1-12)         ' ,& '               or a month name or blank. If blank the current month is assumed. ' ,& '                                                                                ' ,& '   -year NNNN  Select the year to display. A year starts on Jan 1st.            ' ,& '                                                                                ' ,& '   -help       Display help text and exit.                                      ' ,& '   -version    Display version information and exit.                            ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '      month -month 12                                                           ' ,& '                                                                                ' ,& '       >    December 2015                                                       ' ,& '       >Mo Tu We Th Fr Sa Su                                                    ' ,& '       >    1  2  3  4  5  6                                                    ' ,& '       > 7  8  9 10 11 12 13                                                    ' ,& '       >14 15 16 17 18 19 20                                                    ' ,& '       >21 22 23 24 25 26 27                                                    ' ,& '       >28 29 30 31                                                             ' ,& '                                                                                ' ,& '      month -month April # month names may be given instead of numbers          ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    month(1f) - [TIME] display a calendar !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    month [[ -year] NNNN] [ -month NN|month_name] !! !!##DESCRIPTION !!    month(1) displays a simple calendar. If no arguments are specified, !!    the current year is displayed. !! !!##OPTIONS !!    -month NN   Display single month output. The month is numeric (1-12) !!                or a month name or blank. If blank the current month is assumed. !! !!    -year NNNN  Select the year to display. A year starts on Jan 1st. !! !!    -help       Display help text and exit. !!    -version    Display version information and exit. !! !!##EXAMPLES !! !!       month -month 12 !! !!        >    December 2015 !!        >Mo Tu We Th Fr Sa Su !!        >    1  2  3  4  5  6 !!        > 7  8  9 10 11 12 13 !!        >14 15 16 17 18 19 20 !!        >21 22 23 24 25 26 27 !!        >28 29 30 31 !! !!       month -month April # month names may be given instead of numbers !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        month(1f)>' ,& '@(#)DESCRIPTION:    displays simple calendar>' ,& '@(#)VERSION:        1.0, 2015-12-20>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- end program month_exe","tags":"","url":"program/month_exe.html"},{"title":"demo_date_to_unix – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer :: ierr real(kind=realtime) :: unixtime Source Code program demo_date_to_unix use M_time , only : date_to_unix , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: unixtime integer :: ierr call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat call date_to_unix ( dat , unixtime , ierr ) write ( * , * ) 'Unix Epoch time is ' , unixtime write ( * , * ) 'ierr is ' , ierr end program demo_date_to_unix","tags":"","url":"program/demo_date_to_unix.html"},{"title":"demo_easter – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer :: year Source Code program demo_easter use M_time , only : easter , fmtdate implicit none integer :: year integer :: dat ( 8 ) ! year,month,day,tz,hour,minute,second,millisecond call date_and_time ( values = dat ) ! get current year year = dat ( 1 ) call easter ( year , dat ) write ( * , * ) fmtdate ( dat ,& \"Easter day: the %d day of %L in the year of our Lord %Y\" ) end program demo_easter","tags":"","url":"program/demo_easter.html"},{"title":"demo_d2j – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2j use M_time , only : d2j implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Julian Date is ' , d2j ( dat ) end program demo_d2j","tags":"","url":"program/demo_d2j.html"},{"title":"demo_sec2days – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer, parameter :: dp = kind(0.0d0) Source Code program demo_sec2days use M_time , only : sec2days implicit none integer , parameter :: dp = kind ( 0.0d0 ) write ( * , * ) sec2days ( 129860 ) write ( * , * ) sec2days ( 8000 0.0_dp ) write ( * , * ) sec2days ( 8000 0.0 , crop = . true .) write ( * , * ) sec2days ( '1 day 2.0hr 100 min 300.0seconds' ) end program demo_sec2days","tags":"","url":"program/demo_sec2days~2.html"},{"title":"demo_m2d – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) integer, parameter :: dp = kind(0.0d0) real(kind=realtime) :: today Source Code program demo_m2d use M_time , only : m2d , d2m , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2m ( dat ) ! convert today to Julian Date write ( * , * ) 'Today=' , fmtdate ( m2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) 'Yesterday=' , fmtdate ( m2d ( today - 1.0_dp )) write ( * , * ) 'Tomorrow=' , fmtdate ( m2d ( today + 1.0_dp )) end program demo_m2d","tags":"","url":"program/demo_m2d.html"},{"title":"demo_d2m – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: dat (8) Source Code program demo_d2m use M_time , only : d2m , realtime implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Modified Julian Date is ' , d2m ( dat ) end program demo_d2m","tags":"","url":"program/demo_d2m.html"},{"title":"demo_fmtdate_usage – M_time","text":"Uses M_time Source Code program demo_fmtdate_usage use M_time , only : fmtdate_usage implicit none call fmtdate_usage () ! see all formatting options end program demo_fmtdate_usage","tags":"","url":"program/demo_fmtdate_usage.html"},{"title":"demo_o2d – M_time","text":"Uses M_time Variables Type Attributes Name Initial integer :: year Source Code program demo_o2d use M_time , only : o2d , fmtdate implicit none integer :: year do year = 2004 , 2008 write ( * , '(*(g0))' )& & '100th day of ' , year , ' is ' , fmtdate ( o2d ( 100 , year )) enddo write ( * , '(*(g0))' ) '100th day of this year is ' , fmtdate ( o2d ( 100 )) end program demo_o2d","tags":"","url":"program/demo_o2d.html"},{"title":"demo_dow.f90 – M_time","text":"Source Code program demo_dow use M_time , only : dow implicit none integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) call dow ( dat , weekday , day , ierr ) write ( * , '(a,i0)' ) 'weekday=' , weekday write ( * , '(a,a)' ) 'day=' , trim ( day ) write ( * , '(a,i0)' ) 'ierr=' , ierr end program demo_dow","tags":"","url":"sourcefile/demo_dow.f90.html"},{"title":"demo_date_to_bas.f90 – M_time","text":"Source Code program demo_date_to_bas use M_time , only : date_to_bas , realtime , BAStime use M_time , only : date_to_julian implicit none integer :: dat ( 8 ) type ( BAStime ) :: bas real ( kind = realtime ) :: juliandate integer :: ierr character ( len =* ), parameter :: g = '(*(g0,1x))' ! write ( * , g ) 'date_to_bas:' ! generate DAT array call date_and_time ( values = dat ) ! ! show DAT array write ( * , '(\"Today is:\",*(i0:,\":\"))' ) dat ! ! convert DAT to Julian call date_to_julian ( dat , juliandate , ierr ) ! show as Modified Julian Date write ( * , g ) 'Expecting Modified Julian Date:' , & & juliandate - 240000 0.5_realtime ! ! convert DAT to BAS call date_to_bas ( dat , bas , ierr ) write ( * , g ) 'Baseday and Seconds is ' , bas write ( * , g ) 'converted to Modified Julian Date:' , & & bas % base_day + bas % secs / 8640 0.0d0 end program demo_date_to_bas","tags":"","url":"sourcefile/demo_date_to_bas.f90.html"},{"title":"demo_date_to_julian.f90 – M_time","text":"Source Code program demo_date_to_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: juliandate integer :: ierr ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , * ) 'Julian Date is ' , juliandate write ( * , * ) 'ierr is ' , ierr end program demo_date_to_julian","tags":"","url":"sourcefile/demo_date_to_julian.f90.html"},{"title":"demo_d2o.f90 – M_time","text":"Source Code program demo_d2o use M_time , only : d2o implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Day of year is:' , d2o ( dat ) ! year,month,day,timezone,hour,minute,seconds,milliseconds dat = [ 2020 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2021 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2022 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2023 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) dat = [ 2024 , 12 , 31 , - 240 , 12 , 0 , 0 , 0 ] write ( * , * ) dat ( 1 ), ' Days in year is:' , d2o ( dat ) end program demo_d2o","tags":"","url":"sourcefile/demo_d2o.f90.html"},{"title":"demo_M_time__oop.f90 – M_time","text":"Source Code program demo_M_time__oop ! ! This is an example using the object-oriented class/type model ! This is essentially the same functionality as the procedures ! in the procedural module M_time(3fm), but allows for Object ! Oriented syntax: ! use M_time__oop , only : date_time ! The type includes the operators ... !  operator(+) !  operator(-) !  operator(>) !  operator(<) !  operator(<=) !  operator(>=) !  operator(==) !  operator(/=) implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer :: dat ( 8 ) TYPE ( date_time ) :: event TYPE ( date_time ) :: otherdate TYPE ( date_time ) :: answer character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' ! DIFFERENT INITIALIZATION STYLES ! (Still debating on how best to do this) write ( * , * ) write ( * , '(a)' ) 'Various initialization styles' ! DEFINE type(date_time) WITH CONSTRUCTOR otherdate = date_time () print * , 'DEFAULT CONSTRUCTOR %format()               ' ,& & otherdate % format () print * , 'DEFAULT CONSTRUCTOR %format(\"\")             ' ,& & otherdate % format ( \"\" ) print * , 'DEFAULT CONSTRUCTOR %format(user-specified) ' ,& & otherdate % format ( iso_fmt ) print * , 'DEFAULT CONSTRUCTOR %format(\"USA\")          ' ,& & otherdate % format ( \"USA\" ) otherdate = date_time ( 1492 , 10 , 12 , 0 , 0 , 0 , 0 , 0 ) print * , 'DEFAULT CONSTRUCTOR setting values          ' ,& & otherdate % format () otherdate = date_time ( 2016 , 6 , 11 ) print * , 'DEFAULT CONSTRUCTOR with partial values     ' ,& & otherdate % format () otherdate = date_time ( year = 2016 , month = 6 , day = 11 , tz =- 240 ,& & hour = 21 , minute = 09 , second = 11 , millisecond = 500 ) print * , 'DEFAULT CONSTRUCTOR with values by name     ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 , 0 , 0 , 0 , 0 , 0 ]) print * , 'CONSTRUCTOR with a dat array                ' ,& & otherdate % format () otherdate = date_time ([ 1776 , 7 , 4 ]) print * , 'CONSTRUCTOR with a partial dat array        ' ,& & otherdate % format () ! the init() method supports several methods ! initialize to current time using INIT call otherdate % init () ! initialize to current time using INIT call otherdate % init ( type = \"now\" ) ! initialize to beginning of Unix Epoch Time call otherdate % init ( type = \"epoch\" ) ! Note ! currently, DATE_TIME DATE array is set to Unix Epoch ! start USING LOCAL TIMEZONE ! whereas default constructor is using default of Unix Epoch ! start using Z time (GMT or UTC time) ! initialize with a DAT array using INIT, ! compatible with DATE_AND_TIME VALUES(8) call otherdate % init ( dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) ! using INIT with ordered values call otherdate % init ( 2016 , 6 , 11 , - 300 , 23 , 1 , 0 , 0 ) ! using INIT with names call otherdate % init ( year = 2016 , month = 6 , day = 11 ,& & tz =- 300 , hour = 23 , minute = 1 , second = 0 , millisecond = 0 ) ! ! take current date and exercise the OOP interface ! initialize to current time using INIT call event % init () write ( * , * ) write ( * , * ) 'Print members of type(DATE_TIME)' ! show derived type write ( * , 404 ) 'EVENT=' , event 404 format ( 1 x , a , i0 , * ( \",\" , i0 :)) ! MEMBERS ( basic time values are all integers) ! print members of type write ( * , 101 ) '%year        Year................... ' , event % year write ( * , 101 ) '%month       Month.................. ' , event % month write ( * , 101 ) '%day         Day.................... ' , event % day write ( * , 101 ) '%tz          Timezone............... ' , event % tz write ( * , 101 ) '%hour        Hour................... ' , event % hour write ( * , 101 ) '%minute      Minute................. ' , event % minute write ( * , 101 ) '%second      Second................. ' , event % second write ( * , 101 ) '%millisecond Millisecond............ ' , event % millisecond ! PRINT METHODS OF TYPE write ( * , * ) 'Print methods of type(DATE_TIME)' write ( * , 101 ) '%ordinal     Ordinal day of year.... ' , event % ordinal () write ( * , 101 ) '%weekday     Weekday................ ' , event % weekday () 101 format ( 1 x , a , i0 ) ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY write ( * , 202 ) '%epoch      Unix epoch time........ ' , event % epoch () write ( * , 202 ) '%julian     Julian date............ ' , event % julian () write ( * , 202 ) '%mjd        Modiied Julian date.... ' , event % mjd () 202 format ( 1 x , a , g0 ) ! FORMATTED STRINGS (many strings possible. ! Takes the same format string as fmtdate(3f)) write ( * , * ) write ( * , '(a)' ) ' Formatted Strings (%format(\"STRING\") & & -- see fmtdate(3f) for format descriptions' ! abbreviated month name             %l  Dec write ( * , 303 ) 'Short month............ ' ,& & event % format ( \"%l\" ) ! ! full month name                    %L  December write ( * , 303 ) 'Month.................. ' ,& & event % format ( \"%L\" ) ! ! first three characters of weekday  %w  Sat write ( * , 303 ) 'Short week............. ' ,& & event % format ( \"%w\" ) ! ! weekday name                       %W  Saturday write ( * , 303 ) 'Week .................. ' ,& & event % format ( \"%W\" ) ! ! with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( \"Y-M-D h:m:s.x z\" ) ! ! keywords with no percent (%) characters write ( * , 303 ) 'Calendar Time ......... ' ,& & event % format ( '\"year-month-day & & hour:minute:second.millisecond timezone\"' ) ! write ( * , * ) event % format ( 'Longer format.......... & &\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! a nice friendly format ! 303 format ( 1 x , a , '\"' , a , '\"' ) ! convert date_time to integer array ! (maybe to use with module M_TIME base procedures) dat = event % datout () write ( * , * ) write ( * , 404 ) 'DAT=' , dat ! OVERLOADED OPERATORS (add and subtract) ! a date_time object can have seconds added answer = event + 1 * 8640 0.0_dp ! ! a nice friendly format write ( * , * ) answer % format ( 'TOMORROW=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! a date_time object can have seconds subtracted answer = event - 1 * 8640 0.0_dp ! a nice friendly format write ( * , * ) answer % format ( 'YESTERDAY=\"%W, %L %d, %Y %H:%m:%s %N\"' ) ! ! if both operands are DATE_TIME objects a subtraction ! finds the time in seconds between the two dates write ( * , * ) 'DIFFERENCE (subtracting one date_time from another)=' ,& & answer - event ! OVERLOADED OPERATORS (logical comparisons) ! NOTE COMPARISONS ARE PERFORMED BY ! CONVERTING TIMES TO INTEGER SECONDS write ( * , * ) '> ' , event == event , event < event , event > event & & , event <= event , event >= event , event /= event ! write ( * , * ) '> ' , event == answer , event < answer , event > answer & & , event <= answer , event >= answer , event /= answer ! write ( * , * ) '> ' , answer == event , answer < event , answer > event & & , answer <= event , answer >= event , answer /= event ! %DELTA easily lets you change dates by common increments write ( * , * ) write ( * , 404 ) '%DELTA tests starting with date ' , event % delta () ! write ( * , * ) event % format ( \"                             & &%W, %L %d, %Y %H:%m:%s %N\" ) write ( * , * ) 'Remember years and months are not constant units' answer = event % delta ( year = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( month = 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( month =- 24 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( week = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( week =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( day = 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( day =- 1 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour = 4 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( hour =- 4 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( minute = 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( minute =- 180 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( second = 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( second =- 1800 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( millisecond = 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\" ) ! answer = event % delta ( millisecond =- 10000 ) write ( * , * ) answer % format (& & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( year = 3 , month = 2 , day = 100 , hour = 200 ,& & week =- 1 , minute = 300 , second = 1000 , millisecond =- 10000 ) write ( * , * ) answer % format (& ! & \"FOR %%DELTA(year=3,month=2,day=100,hour=200,& &week=-1,minute=300,second=1000,millisecond=100000)& & %W, %L %d, %Y %H:%m:%s %N\" ) answer = event % delta ( duration = \"1-20:30:40.50\" ) write ( * , * ) answer % format (& & \"FOR %%DELTA(DURATION='1-20:30:40.50')& & %W, %L %d, %Y %H:%m:%s %N\" ) end program demo_M_time__oop","tags":"","url":"sourcefile/demo_m_time__oop.f90.html"},{"title":"demo_ordinal_to_date.f90 – M_time","text":"Source Code program demo_ordinal_to_date use M_time , only : ordinal_to_date implicit none integer :: yyyy , ddd , mm , dd , yy integer :: dat ( 8 ) integer :: i , iostat character ( len = :), allocatable :: fakefile (:) fakefile = [ character ( len = 80 ) :: ' 2024 273 ' , '2024 001' ] do i = 1 , size ( fakefile ) ! Enter year YYYY and ordinal day of year DD read ( fakefile ( i ), * , iostat = iostat ) yyyy , ddd if ( iostat /= 0 ) exit ! recover month and day from year and day number. call ordinal_to_date ( yyyy , ddd , dat ) yy = dat ( 1 ) mm = dat ( 2 ) dd = dat ( 3 ) write ( * , '(*(g0))' ) 'For Year ' , yyyy , ' and Ordinal day ' , ddd write ( * , '(*(g0))' ) ' Month is ' , mm , ' and Day of Month is ' , dd , & & ' and Year is ' , yy enddo end program demo_ordinal_to_date","tags":"","url":"sourcefile/demo_ordinal_to_date.f90.html"},{"title":"julian.f90 – M_time","text":"Source Code program julian_time use M_time , only : date_to_julian implicit none integer , parameter :: dp = kind ( 0.0d0 ) integer :: dat ( 8 ) integer :: ierr real ( kind = dp ) :: time call date_and_time ( values = dat ) call date_to_julian ( dat , time , ierr ) write ( * , '(f0.7)' ) time end program julian_time","tags":"","url":"sourcefile/julian.f90.html"},{"title":"sec2days.f90 – M_time","text":"Source Code program demo_sec2days use M_kracken95 , only : kracken , lget , sget , IPvalue use M_time , only : sec2days use M_strings , only : substitute implicit none character ( len =* ), parameter :: ident = \"@(#)sec2days(1f): convert seconds to string of form dd-hh:mm:ss\" character ( len = :), allocatable :: strlocal character ( len = :), allocatable :: radix character ( len = IPvalue ) :: line call kracken ( 'sec2days' , ' -oo -crop .F -radix . -help .F. -version .F.' ) ! parse command line call help_usage ( lget ( 'sec2days_help' )) ! display help information and stop if true call help_version ( lget ( 'sec2days_version' )) ! display version information and stop if true radix = trim ( sget ( 'sec2days_radix' )) line = sget ( 'sec2days_oo' ) if ( radix /= '.' ) then call substitute ( line , '.' , ' ' ) call substitute ( line , radix , '.' ) endif strlocal = sec2days ( line , lget ( 'sec2days_crop' )) ! get command line option and convert to dd-hh:mm:ss string write ( * , '(a)' ) strlocal contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   sec2days(1f) - [TIME] Convert durations of time to string of form dd-hh:mm:ss' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   sec2days nnnn[.xxx] [ -crop]| --version| --help                              ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a numeric string representing seconds or labeled units of time         ' ,& '   convert it to a string of the form                                           ' ,& '                                                                                ' ,& '      dd-hh:mm:ss                                                               ' ,& '                                                                                ' ,& '   where dd is days, hh hours, mm minutes and ss seconds.                       ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   nnnn[.xxx]  Defaults to number of seconds to convert to string of            ' ,& '               form dd-hh:mm:ss.  nnnn may be interspersed with unit            ' ,& '               codes d,h,m,s. Spaces, commas and case are ignored. Allowed      ' ,& '               aliases for the unit codes are                                   ' ,& '                                                                                ' ,& '                 d  days and day                                                ' ,& '                 h  hours,hour,hrs, and hr                                      ' ,& '                 m  minutes,minute and min                                      ' ,& '                 s  seconds,second and sec                                      ' ,& '                                                                                ' ,& '   -crop       trim leading zero values from output                             ' ,& '   -radix      character used as decimal separator                              ' ,& '   --help      display this help and exit                                       ' ,& '   --version   output version information and exit                              ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& ' usage                                                                          ' ,& '                                                                                ' ,& '   sec2days 129860                                                              ' ,& '   1-12:04:20                                                                   ' ,& '   sec2days 1d2h3m4s                                                            ' ,& '   1-02:03:04                                                                   ' ,& '   sec2days 1.0 days 2 hours 3 minutes 4 seconds                                ' ,& '   1-02:03:04                                                                   ' ,& '   sec2days 1.5d                                                                ' ,& '   1-12:00:00                                                                   ' ,& '                                                                                ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    sec2days(1f) - [TIME] Convert durations of time to string of form dd-hh:mm:ss !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    sec2days nnnn[.xxx] [ -crop]| --version| --help !! !!##DESCRIPTION !!    Given a numeric string representing seconds or labeled units of time !!    convert it to a string of the form !! !!       dd-hh:mm:ss !! !!    where dd is days, hh hours, mm minutes and ss seconds. !! !!##OPTIONS !!    nnnn[.xxx]  Defaults to number of seconds to convert to string of !!                form dd-hh:mm:ss.  nnnn may be interspersed with unit !!                codes d,h,m,s. Spaces, commas and case are ignored. Allowed !!                aliases for the unit codes are !! !!                  d  days and day !!                  h  hours,hour,hrs, and hr !!                  m  minutes,minute and min !!                  s  seconds,second and sec !! !!    -crop       trim leading zero values from output !!    -radix      character used as decimal separator !!    --help      display this help and exit !!    --version   output version information and exit !! !!##EXAMPLES !! !!  usage !! !!    sec2days 129860 !!    1-12:04:20 !!    sec2days 1d2h3m4s !!    1-02:03:04 !!    sec2days 1.0 days 2 hours 3 minutes 4 seconds !!    1-02:03:04 !!    sec2days 1.5d !!    1-12:00:00 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        sec2days(1f)>' ,& '@(#)DESCRIPTION:    convert seconds to string of form dd-hh:mm:ss>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_sec2days","tags":"","url":"sourcefile/sec2days.f90.html"},{"title":"days2sec.f90 – M_time","text":"Source Code program demo_days2sec use M_kracken95 , only : kracken , sget , lget , rget use M_time , only : days2sec use M_strings , only : v2s implicit none character ( len =* ), parameter :: ident = \"@(#)days2sec(1): given string of form dd-hh:mm:ss convert to seconds\" character ( len = :), allocatable :: printline call kracken ( 'days2sec' , ' -oo -help .F. -version .F. -denominator 1' ) ! parse command line call help_usage ( lget ( 'days2sec_help' )) ! display help information and stop if true call help_version ( lget ( 'days2sec_version' )) ! display version information and stop if true ! get value from command line with SGET, convert to seconds with DAYS2SEC, and make into a nicer value string with V2S printline = v2s ( days2sec ( sget ( 'days2sec_oo' )) / rget ( 'days2sec_denominator' )) ! not in write statement so error message will print write ( * , '(a)' ) printline contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds                ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& ' Forms:                                                                         ' ,& '                                                                                ' ,& '    days2sec dd-hh:mm:ss                                                        ' ,& '    days2sec NNdNNhNNmNNs                                                       ' ,& '    days2sec --version| --help                                                  ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss where dd is days, hh hours,         ' ,& '   mm minutes and ss seconds convert it to seconds. Many utilities (ps(1),      ' ,& '   for example) show times in this format to make it more intelligible;         ' ,& '   but it generally easier to perform math on values represented in             ' ,& '   seconds.                                                                     ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   dd-hh:mm:ss  Given a string representing a duration of time in the           ' ,& '                following forms:                                                ' ,& '                                                                                ' ,& '                  dd-hh:mm:ss                                                   ' ,& '                     hh:mm:ss                                                   ' ,& '                        mm:ss                                                   ' ,& '                           ss                                                   ' ,& '                                                                                ' ,& '                convert it to seconds.                                          ' ,& '                                                                                ' ,& '                The numeric values may represent floating point numbers.        ' ,& '                                                                                ' ,& '                Spaces are ignored.                                             ' ,& '                                                                                ' ,& '    NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes;    ' ,& '                  where s,m,h, or d represents seconds, minutes, hours          ' ,& '                  or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are' ,& '                                                                                ' ,& '                   w -  weeks,week,wk,wks                                       ' ,& '                   d -  days,day                                                ' ,& '                   m -  minutes,minute,min                                      ' ,& '                   h -  hours,hour,hrs,hr                                       ' ,& '                   s -  seconds,second,sec,secs                                 ' ,& '                                                                                ' ,& '                  The numeric values may represent floating point numbers.      ' ,& '                                                                                ' ,& '                  Spaces, commas  and case are ignored.                         ' ,& '                                                                                ' ,& '   --denominator  divide the result by this value. Default is one(1).           ' ,& '   --help         display this help and exit                                    ' ,& '   --version      output version information and exit                           ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '  Usage                                                                         ' ,& '                                                                                ' ,& '    days2sec 1-12:04:20                                                         ' ,& '    129860                                                                      ' ,& '    days2sec 1.5 days                                                           ' ,& '    129600                                                                      ' ,& '    days2sec 1.5 days 4hrs 30minutes                                            ' ,& '    145800                                                                      ' ,& '    days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED                    ' ,& '    30                                                                          ' ,& '    days2sec 1 1 1  # SPACES ARE IGNORED                                        ' ,& '    111                                                                         ' ,& 'SEE ALSO                                                                        ' ,& '    sec2days(1)                                                                 ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!  Forms: !! !!     days2sec dd-hh:mm:ss !!     days2sec NNdNNhNNmNNs !!     days2sec --version| --help !! !!##DESCRIPTION !!    Given a duration in the form dd-hh:mm:ss where dd is days, hh hours, !!    mm minutes and ss seconds convert it to seconds. Many utilities (ps(1), !!    for example) show times in this format to make it more intelligible; !!    but it generally easier to perform math on values represented in !!    seconds. !! !!##OPTIONS !!    dd-hh:mm:ss  Given a string representing a duration of time in the !!                 following forms: !! !!                   dd-hh:mm:ss !!                      hh:mm:ss !!                         mm:ss !!                            ss !! !!                 convert it to seconds. !! !!                 The numeric values may represent floating point numbers. !! !!                 Spaces are ignored. !! !!     NNdNNhNNmNNs  Simple numeric values may also be used with unit suffixes; !!                   where s,m,h, or d represents seconds, minutes, hours !!                   or days and w represents weeks. Allowed aliases for w,d,h,m, and s units are !! !!                    w -  weeks,week,wk,wks !!                    d -  days,day !!                    m -  minutes,minute,min !!                    h -  hours,hour,hrs,hr !!                    s -  seconds,second,sec,secs !! !!                   The numeric values may represent floating point numbers. !! !!                   Spaces, commas  and case are ignored. !! !!    --denominator  divide the result by this value. Default is one(1). !!    --help         display this help and exit !!    --version      output version information and exit !! !!##EXAMPLES !! !!   Usage !! !!     days2sec 1-12:04:20 !!     129860 !!     days2sec 1.5 days !!     129600 !!     days2sec 1.5 days 4hrs 30minutes !!     145800 !!     days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED !!     30 !!     days2sec 1 1 1  # SPACES ARE IGNORED !!     111 !!##SEE ALSO !!     sec2days(1) !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        days2sec(1f)>' ,& '@(#)DESCRIPTION:    convert dd-hh:mm:ss string to seconds>' ,& '@(#)VERSION:        1.0, 2016-06-17>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_days2sec","tags":"","url":"sourcefile/days2sec.f90.html"},{"title":"demo_j2d.f90 – M_time","text":"Source Code program demo_j2d use M_time , only : j2d , d2j , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2j ( dat ) ! convert today to Julian Date write ( * , * ) 'Today=' , fmtdate ( j2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) 'Yesterday=' , fmtdate ( j2d ( today - 1.0_dp )) write ( * , * ) 'Tomorrow=' , fmtdate ( j2d ( today + 1.0_dp )) end program demo_j2d","tags":"","url":"sourcefile/demo_j2d.f90.html"},{"title":"demo_moon_fullness.f90 – M_time","text":"Source Code program demo_moon_fullness use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' )& & 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_moon_fullness","tags":"","url":"sourcefile/demo_moon_fullness.f90.html"},{"title":"today.f90 – M_time","text":"Source Code program today implicit none call main () contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '       today(1f) - [TIME] output current time for uses such as file suffixes.   ' ,& '       (LICENSE:PD)                                                             ' ,& 'SYNOPSIS                                                                        ' ,& '       today format|--help|--version|--test                                     ' ,& 'DESCRIPTION                                                                     ' ,& '       Outputs the current date using the specified format. Typically used      ' ,& '       to generate a string to be used in building filenames containing         ' ,& '       date information.                                                        ' ,& 'OPTIONS                                                                         ' ,& '       format     any allowable format for the fmtdate(3) routine.              ' ,& '                  defaults to \"Y-M-D\".                                          ' ,& '       --help     display this help and exit                                    ' ,& '       --version  output version information and exit                           ' ,& '       --test     display allowed options for building a format                 ' ,& 'EXAMPLES                                                                        ' ,& '       Sample commands:                                                         ' ,& '                                                                                ' ,& '        $today                                                                  ' ,& '        2024-05-27                                                              ' ,& '                                                                                ' ,& '        $mv -v myfile myfile.`today`                                            ' ,& '        renamed ''myfile'' -> ''myfile.2024-05-27''                             ' ,& '                                                                                ' ,& '        $find . -ls > MANIFEST.`today epoch`; ls MANIFEST.*                     ' ,& '        MANIFEST.1716840303                                                     ' ,& '                                                                                ' ,& '        $mkdir `today YMDhms`                                                   ' ,& '        20240527160333                                                          ' ,& '                                                                                ' ,& '        $today yearmonthdayhourminutesecond                                     ' ,& '        20240527160442                                                          ' ,& '                                                                                ' ,& '        $today --test                          # show formatting options        ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!        today(1f) - [TIME] output current time for uses such as file suffixes. !!        (LICENSE:PD) !!##SYNOPSIS !! !!        today format|--help|--version|--test !!##DESCRIPTION !!        Outputs the current date using the specified format. Typically used !!        to generate a string to be used in building filenames containing !!        date information. !!##OPTIONS !!        format     any allowable format for the fmtdate(3) routine. !!                   defaults to \"Y-M-D\". !!        --help     display this help and exit !!        --version  output version information and exit !!        --test     display allowed options for building a format !!##EXAMPLES !! !!        Sample commands: !! !!         $today !!         2024-05-27 !! !!         $mv -v myfile myfile.`today` !!         renamed 'myfile' -> 'myfile.2024-05-27' !! !!         $find . -ls > MANIFEST.`today epoch`; ls MANIFEST.* !!         MANIFEST.1716840303 !! !!         $mkdir `today YMDhms` !!         20240527160333 !! !!         $today yearmonthdayhourminutesecond !!         20240527160442 !! !!         $today --test                          # show formatting options !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        today(1f)>' ,& '@(#)DESCRIPTION:    output current time for uses such as file suffixes.>' ,& '@(#)VERSION:        1.0, 2009, 1.0.1 2024>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version subroutine main () use M_time , only : now , fmtdate_usage , locale use M_kracken95 , only : kracken , lget , sget ! add command-line parser module ! ident_1=\"@(#) today(1f) output current time for uses such as file suffixes.\" character ( len = :), allocatable :: options call locale ( 'LANGUAGE' ) call kracken ( 'today' , '-help .F. -version .F. -test .F.' ) ! define command arguments,default values and crack command line call help_usage ( lget ( 'today_help' )) ! if -help option is present, display help text and exit call help_version ( lget ( 'today_version' )) ! if -version option is present, display version text and exit if ( lget ( 'today_test' )) then ! special option to list date format documentation call fmtdate_usage () ! see all formatting options else options = sget ( 'today_oo' ) ! get -oo STRING if ( options == '' ) options = 'Y-M-D' ! if options are blank set a default write ( * , '(a)' ) now ( options ) ! display current date using format from command line endif end subroutine main end program today","tags":"","url":"sourcefile/today.f90.html"},{"title":"demo_b2d.f90 – M_time","text":"Source Code program demo_b2d use M_time , only : b2d , d2b , fmtdate , realtime , BAStime !BAStime includes operator(+), operator(-) implicit none integer , parameter :: dp = kind ( 0.0d0 ) type ( BAStime ) :: today type ( BAStime ) :: aday type ( BAStime ) :: newday , yesterday , tomorrow integer :: dat ( 8 ) character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'b2d:' call date_and_time ( values = dat ) ! get the date using intrinsic today = d2b ( dat ) ! convert DAT to BAS aday = BAStime ( 1 , 0.0_dp ) ! a value of one day write ( * , g ) 'Today=' , fmtdate ( b2d ( today )) write ( * , g ) 'BAStime +- BAStime' write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today + BAStime ( - 1 , 0.0_dp ))) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + BAStime ( + 1 , 0.0_dp ))) write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today + BAStime ( 0 , - 8640 0.0_dp ))) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + BAStime ( 0 , + 8640 0.0_dp ))) write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today - aday )) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + aday )) yesterday = today - aday write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( yesterday )) tomorrow = today + aday write ( * , g ) 'Tomorrow=' , fmtdate ( b2d ( tomorrow )) write ( * , g ) 'BAStime +- value_in_seconds' write ( * , g ) 'Yesterday=' , fmtdate ( b2d ( today - 86400 )) write ( * , g ) 'Tomorrow= ' , fmtdate ( b2d ( today + 86400 )) write ( * , g ) 'BAStime comparisons' newday = today + ( aday / 2 ) write ( * , g ) 'today=' , today % format () write ( * , g ) 'newday=' , newday % format () call pr ( today , newday ) call pr ( newday , today ) call pr ( today , today ) write ( * , g ) 'BAStime compound expressions' write ( * , g ) ( today + 86400 / 2 ). eq . newday , fmtdate ( b2d ( newday )) contains subroutine pr ( left , right ) type ( BAStime ), intent ( in ) :: left , right write ( * , g ) 'eq' , left . eq . right , & 'gt' , left . gt . right , & 'lt' , left . lt . right , & 'ge' , left . ge . right , & 'le' , left . le . right , & 'ne' , left . ne . right end subroutine pr end program demo_b2d","tags":"","url":"sourcefile/demo_b2d.f90.html"},{"title":"demo_days2sec.f90 – M_time","text":"Source Code program demo_days2sec use M_time , only : days2sec implicit none write ( * , * ) days2sec ( '1-12:04:20' ) write ( * , * ) 'one second ' , days2sec ( '1' ) write ( * , * ) 'one minute ' , days2sec ( '1:00' ) write ( * , * ) 'one hour ' , days2sec ( '1:00:00' ) write ( * , * ) 'one day ' , days2sec ( '1-00:00:00' ) write ( * , * ) nint ( days2sec ( ' 1-12:04:20              ' )) == 129860 write ( * , * ) nint ( days2sec ( ' 1.5 days                ' )) == 129600 write ( * , * ) nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) == 145800 write ( * , * ) nint ( days2sec ( ' 1.5d                    ' )) == 129600 write ( * , * ) nint ( days2sec ( ' 1d2h3m4s                ' )) == 93784 ! duplicates write ( * , * ) nint ( days2sec ( ' 1d1d1d                  ' )) == 259200 ! negative values write ( * , * ) nint ( days2sec ( ' 4d-12h                  ' )) == 302400 end program demo_days2sec","tags":"","url":"sourcefile/demo_days2sec.f90.html"},{"title":"demo_mo2d.f90 – M_time","text":"Source Code program demo_mo2d use M_time , only : mo2d implicit none write ( * , '(\"MARCH:\",*(i0:,\":\"))' ) mo2d ( 'March' ) end program demo_mo2d","tags":"","url":"sourcefile/demo_mo2d.f90.html"},{"title":"demo_locale.f90 – M_time","text":"Source Code program demo_locale use M_time , only : locale , now implicit none call locale ( 'POSIX' ) write ( * , * ) now () call locale ( 'french' ) write ( * , * ) now () call mine () write ( * , * ) now () contains subroutine mine () character ( len =* ), parameter :: months ( 12 ) = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH    ' , 'APRIL  ' , 'MAY     ' , 'JUNE    ' , & & 'JULY   ' , 'AUGUST  ' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] character ( len =* ), parameter :: weekdays ( 7 ) = [ character ( len = 9 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , 'SATURDAY' , 'SUNDAY' ] character ( len = 3 ), parameter :: short_months ( 12 ) = months (:)( 1 : 3 ) character ( len = 3 ), parameter :: short_weekdays ( 7 ) = weekdays (:)( 1 : 3 ) integer :: ierr call locale ( 'user' , months , short_months , weekdays , short_weekdays , ierr ) end subroutine mine end program demo_locale","tags":"","url":"sourcefile/demo_locale.f90.html"},{"title":"demo_system_sleep.f90 – M_time","text":"Source Code program demo_system_sleep use M_time , only : system_sleep , now implicit none integer :: i ! write ( * , '(a)' ) \"Time before integer call is: \" , now () call system_sleep ( 4 ) write ( * , '(a)' ) \"Time after integer call is: \" , now () ! write ( * , '(a)' ) \"Time before real call is: \" , now () call system_sleep ( 4.0 ) write ( * , '(a)' ) \"Time after real call is: \" , now () ! write ( * , '(a)' ) \"Time before loop is: \" , now () do i = 1 , 1000 call system_sleep ( 4.0 / 100 0.0 ) enddo write ( * , '(a)' ) \"Time after loop is: \" , now () ! end program demo_system_sleep","tags":"","url":"sourcefile/demo_system_sleep.f90.html"},{"title":"paws.f90 – M_time","text":"Source Code program demo_system_sleep use M_kracken , only : kracken , sget , lget , dget , igets , iget use M_time , only : days2sec , realtime , u2d , d2u , j2d , system_sleep , guessdate , now , fmtdate implicit none character ( len =* ), parameter :: ident = \"@(#)paws(1):pause until specified time or for specified duration\" real ( kind = realtime ) :: until_value real ( kind = realtime ) :: delay_value integer :: dat ( 8 ) integer :: i integer :: itimes integer :: ios logical :: until logical :: once character ( len = :), allocatable :: time_format character ( len = :), allocatable :: msg character ( len = :), allocatable :: cmd character ( len = 1 ) :: cpaws integer :: cstat character ( len = 256 ) :: sstat ! parse command line call kracken ( 'paws' , ' -oo -debug .f. -cmd -msg -uet -jd -dat -date -until -repeat 0 -fmt -help .F. -version .F.' ) call help_usage ( lget ( 'paws_help' )) ! display help information and stop if true call help_version ( lget ( 'paws_version' )) ! display version information and stop if true until = . false . until_value = 0.0 !=================================================================================================================================== ! delay until specified date has passed using various date descriptions if ( sget ( 'paws_uet' ). ne . ' ' ) then until_value = max ( 0.0d0 , dget ( 'paws_uet' ) - d2u () ) if ( lget ( 'paws_debug' )) then write ( * , * ) 'UET ...........' , dget ( 'paws_uet' ) write ( * , * ) 'd2u ...........' , d2u () write ( * , * ) 'until_value ...' , until_value call system_sleep ( nint ( until_value )) until = . true . endif endif if ( sget ( 'paws_jd' ). ne . ' ' ) then until_value = max ( 0.0d0 , d2u ( j2d ( dget ( 'paws_jd' ))) - d2u () ) call system_sleep ( nint ( until_value )) until = . true . endif if ( sget ( 'paws_dat' ). ne . ' ' ) then dat = igets ( 'paws_dat' ) until_value = max ( 0.0d0 , d2u ( dat ) - d2u ()) call system_sleep ( nint ( until_value )) until = . true . endif if ( sget ( 'paws_date' ). ne . ' ' ) then call guessdate ( sget ( 'paws_date' ), dat ) write ( * , * ) 'pausing till ' // fmtdate ( dat ) until_value = max ( 0.0d0 , d2u ( dat ) - d2u ()) call system_sleep ( nint ( until_value )) until = . true . endif if ( sget ( 'paws_until' ). ne . ' ' ) then call guessdate ( sget ( 'paws_until' ), dat ) write ( * , * ) 'pausing till ' // fmtdate ( dat ) until_value = max ( 0.0d0 , d2u ( dat ) - d2u ()) call system_sleep ( nint ( until_value )) until = . true . endif !=================================================================================================================================== ! determine value of cyclical pause duration if ( sget ( 'paws_oo' ). ne . ' ' ) then delay_value = max ( 0.0d0 , days2sec ( sget ( 'paws_oo' )) ) else delay_value = 0.0 endif !=================================================================================================================================== itimes = iget ( 'paws_repeat' ) if ( itimes . le . 0 ) then once = . true . itimes = 1 else once = . false . endif time_format = sget ( 'paws_fmt' ) msg = trim ( sget ( 'paws_msg' )) cmd = trim ( sget ( 'paws_cmd' )) !=================================================================================================================================== if ( lget ( 'paws_debug' )) then write ( * , * ) 'cmd ...........; ' , trim ( cmd ) write ( * , * ) 'msg ...........; ' , trim ( msg ) write ( * , * ) 'time_format ...; ' , trim ( time_format ) write ( * , * ) 'delay_value ...;' , delay_value write ( * , * ) 'until .........;' , until write ( * , * ) 'until_value ...;' , until_value write ( * , * ) 'once ..........;' , once write ( * , * ) 'itimes ........;' , itimes endif !=================================================================================================================================== do i = itimes , 1 , - 1 if ( msg . ne . ' ' ) then write ( * , '(a)' ) msg endif if (. not . once ) then write ( * , '(i0.3,1x,a)' ) i , now ( time_format ) endif if ( cmd . ne . ' ' ) then call execute_command_line ( cmd , cmdstat = cstat , cmdmsg = sstat ) endif if (. not . until . and . delay_value . le . 0 ) then ! no pause time specified. Prompt and read from stdin write ( * , '(\"continue...\")' , advance = \"no\" ) read ( * , '(a)' , iostat = ios ) cpaws else call system_sleep ( delay_value ) endif enddo if (. not . once ) then write ( * , '(i0.3,1x,a)' ) i , now ( time_format ) endif contains subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   paws(1f) - [TIME] pause until specified time or for specified duration       ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   paws [dd-hh:mm:ss[.xxx]|xxx.yyy[s|m|h|d]][ -msg message][ -cmd command][ -repeat TIMES[ -fmt ]]|...' ,& '   [ -uet|-jd|-dat|[ -date|-until]]                                             ' ,& '   paws --version|--help                                                        ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   Given a duration in the form dd-hh:mm:ss.xxx where dd is days, hh hours,     ' ,& '   mm minutes and ss.xxx seconds convert it to seconds. Then, pause for that    ' ,& '   many seconds. Alternatively, pause until specified date has passed.          ' ,& '   If no duration is specified wait until a carriage return is entered.         ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   dd-hh:mm:ss   Given a string representing a duration of time in the          ' ,& '                 following forms:                                               ' ,& '                                                                                ' ,& '                   dd-hh:mm:ss[.xx]                                             ' ,& '                      hh:mm:ss[.xx]                                             ' ,& '                         mm:ss[.xx]                                             ' ,& '                            ss[.xx]                                             ' ,& '                      or                                                        ' ,& '                   xx[.yy]SUFFIX                                                ' ,& '                                                                                ' ,& '                 convert it to seconds and pause for that amount of time.       ' ,& '                 Suffix may be s for seconds, m for minutes, h for hours,       ' ,& '                 or d for days.                                                 ' ,& '   -date|-until  wait until the specified date has passed (before starting      ' ,& '                 optional pause). See guessdate(3f) for syntax allowed for      ' ,& '                 the date.                                                      ' ,& '   -uet          wait until the specified Unix Epoch Time has passed            ' ,& '   -jd           wait until the specified Julian Date has passed                ' ,& '   -dat          wait until the specified date vector has passed                ' ,& '                 (year month day timezone hour minutes seconds milliseconds)    ' ,& '   -repeat NNN   The duration is repeated NNN times with the date displayed     ' ,& '                 at the end of each pause.                                      ' ,& '   --msg         message to display before pausing                              ' ,& '   --cmd         command to execute after a pause                               ' ,& '   --fmt         date format (see fmtdate(3f) for details)                      ' ,& '   --help        display this help and exit                                     ' ,& '   --version     output version information and exit                            ' ,& '                                                                                ' ,& '   For more information on the format of the dates, see the now(1) command.     ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& ' Typical usage:                                                                 ' ,& '                                                                                ' ,& '  paws 2:00:00              # pause for two hours                               ' ,& '  paws 3600                 # pause one hour                                    ' ,& '  paws 0.10                 # pause one tenth of a second                       ' ,& '  paws 1 -repeat 60         # pause sixty seconds, displaying date each second  ' ,& '  paws -until 23:59:59      # pause until midnight                              ' ,& '  paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes  ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    paws(1f) - [TIME] pause until specified time or for specified duration !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    paws [dd-hh:mm:ss[.xxx]|xxx.yyy[s|m|h|d]][ -msg message][ -cmd command][ -repeat TIMES[ -fmt ]]|... !!    [ -uet|-jd|-dat|[ -date|-until]] !!    paws --version|--help !! !!##DESCRIPTION !!    Given a duration in the form dd-hh:mm:ss.xxx where dd is days, hh hours, !!    mm minutes and ss.xxx seconds convert it to seconds. Then, pause for that !!    many seconds. Alternatively, pause until specified date has passed. !!    If no duration is specified wait until a carriage return is entered. !! !!##OPTIONS !!    dd-hh:mm:ss   Given a string representing a duration of time in the !!                  following forms: !! !!                    dd-hh:mm:ss[.xx] !!                       hh:mm:ss[.xx] !!                          mm:ss[.xx] !!                             ss[.xx] !!                       or !!                    xx[.yy]SUFFIX !! !!                  convert it to seconds and pause for that amount of time. !!                  Suffix may be s for seconds, m for minutes, h for hours, !!                  or d for days. !!    -date|-until  wait until the specified date has passed (before starting !!                  optional pause). See guessdate(3f) for syntax allowed for !!                  the date. !!    -uet          wait until the specified Unix Epoch Time has passed !!    -jd           wait until the specified Julian Date has passed !!    -dat          wait until the specified date vector has passed !!                  (year month day timezone hour minutes seconds milliseconds) !!    -repeat NNN   The duration is repeated NNN times with the date displayed !!                  at the end of each pause. !!    --msg         message to display before pausing !!    --cmd         command to execute after a pause !!    --fmt         date format (see fmtdate(3f) for details) !!    --help        display this help and exit !!    --version     output version information and exit !! !!    For more information on the format of the dates, see the now(1) command. !! !!##EXAMPLES !! !!  Typical usage: !! !!   paws 2:00:00              # pause for two hours !!   paws 3600                 # pause one hour !!   paws 0.10                 # pause one tenth of a second !!   paws 1 -repeat 60         # pause sixty seconds, displaying date each second !!   paws -until 23:59:59      # pause until midnight !!   paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        paws(1f)>' ,& '@(#)DESCRIPTION:    pause until specified time or for specified duration>' ,& '@(#)VERSION:        1.0, 20160731>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program demo_system_sleep","tags":"","url":"sourcefile/paws.f90.html"},{"title":"demo_modified_julian_to_date.f90 – M_time","text":"Source Code program demo_modified_julian_to_date use M_time , only : modified_julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: modified_juliandate , tomorrow , yesterday integer :: dat ( 8 ) integer :: ierr ! set sample Modified Julian Date modified_juliandate = 6070 0.503682349771_dp ! create DAT array for this date call modified_julian_to_date ( modified_juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! ! go back one day yesterday = modified_juliandate - 1.0 call modified_julian_to_date ( yesterday , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! ! go forward one day tomorrow = modified_juliandate + 1 call modified_julian_to_date ( tomorrow , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) ! end program demo_modified_julian_to_date","tags":"","url":"sourcefile/demo_modified_julian_to_date.f90.html"},{"title":"demo_box_month.f90 – M_time","text":"Source Code program demo_box_month use M_time , only : box_month implicit none integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) call date_and_time ( values = dat ) call box_month ( dat , calendar ) write ( * , '(a)' ) calendar end program demo_box_month","tags":"","url":"sourcefile/demo_box_month.f90.html"},{"title":"now.f90 – M_time","text":"Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !----------------------------------------------------------------------------------------------------------------------------------- program display_date use M_kracken95 , only : kracken , lget , retrev , sget , dget ! command line parameter cracking module use M_time , only : now , fmtdate_usage , fmtdate , days2sec , d2u , u2d , realtime , guessdate , j2d , locale use m_strings , only : string_to_values , isdigit , isspace , switch implicit none character ( len =* ), parameter :: ident = \"@(#)now(1f): writes timestamp using specified syntax\" integer :: dat ( 8 ) = 0 real :: rdat ( 8 ) = 0 real ( kind = realtime ) :: duration = 0 character ( len = :), allocatable :: output !character(len=1),allocatable   :: chars(:) integer :: ierr , inums call locale ( 'LANGUAGE' ) !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - call kracken ( 'now' , ' -help .F. -version .F. -dat -date -jd -uet -test .false. -delta' ) ! crack command line call help_version ( lget ( 'now_version' )) ! display version number if --version is present !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_help' )) then ! display help text and exit if --help is present call usage () stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( lget ( 'now_test' )) then ! try each format type call fmtdate_usage ( 3 ) stop endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - if ( sget ( 'now_uet' ) /= ' ' ) then dat = u2d ( dget ( 'now_uet' )) ! convert command option to UET number, convert to dat elseif ( sget ( 'now_jd' ) /= ' ' ) then dat = j2d ( dget ( 'now_jd' )) ! convert command option to JD number, convert to dat elseif ( sget ( 'now_dat' ) /= ' ' ) then dat = u2d () ! initialize DAT with current date and time to get time zone dat = [ dat ( 1 ), 1 , 1 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! default is Jan 1st in current year and timezone 00:00:00 call string_to_values ( sget ( 'now_dat' ), size ( dat ), rdat , inums , ' ,:/' , ierr ) ! convert string to array and overlay default values dat ( 1 : inums ) = nint ( rdat ( 1 : inums )) ! if -date is all integer digits and whitespace and +- and only one - (for UTC value) then use it directly to load a DAT !chars=switch(trim(sget('now_dat'))) !if( all(isdigit(chars).or.isspace(chars).or.chars == '-'.or.chars == '+' ) .and. count(chars == '-') <= 1 )then !else !   write(*,*)'*now* error: invalid characters in -dat input '//trim(sget('now_dat')) !endif elseif ( sget ( 'now_date' ) /= ' ' ) then ! convert command option to date string and try to guess date call guessdate ( sget ( 'now_date' ), dat ) else ! create DAT for current time dat = u2d () ! current time endif !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - duration = days2sec ( sget ( 'now_delta' )) ! convert string to duration in seconds dat = u2d ( d2u ( dat ) + duration ) ! convert DAT to UET, add duration, place back in DAT !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - output = fmtdate ( dat , sget ( 'now_oo' )) ! create output string by applying format !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - write ( * , '(a)' ) trim ( output ) ! write output !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - contains !----------------------------------------------------------------------------------------------------------------------------------- subroutine usage () ! character ( len =* ), parameter :: ident = \"@(#)usage(3f,private): writes program help to stdout and exits\" character ( len = 80 ), allocatable :: text (:) integer :: i ! NOTE: Without the type specification this constructor would have to specify all of the constants with the same character length. text = [ character ( len = len ( text ( 1 ))) :: & & 'NAME                                                                            ' ,& & '   now(1f)  - [TIME] print the date and time                                    ' ,& & '   (LICENSE:PD)                                                                 ' ,& & '                                                                                ' ,& & 'SYNOPSIS                                                                        ' ,& & '  now [Format [ -date date_str|-ued Unix_time|-jd Julian_Date|-dat date_vector] ' ,& & '      [ -delta dd-hh:mm:ss]]|--help |--version|-test]                           ' ,& & '                                                                                ' ,& & 'DESCRIPTION                                                                     ' ,& & '   Report the current time or a Fortran date vector in a variety of formats.    ' ,& & '   Julian dates, Unix Epoch time, weekdays, monthnames, ordinal days,           ' ,& & '   AM/PM and iso-8601 week-numbering are supported by building a format         ' ,& & '   string containing the desired macros.                                        ' ,& & 'OPTIONS                                                                         ' ,& & '   Format  :                                                                    ' ,& & '     This string, containing macro names or keywords, creates the format used   ' ,& & '     to print the specified date.                                               ' ,& & '                                                                                ' ,& & '     The FORMAT string is expanded using the following macros:                  ' ,& & '                                                                                ' ,& & 'CALL FMTDATE_USAGE                                                              ' ,& & '                                                                                ' ,& & '   -dat date_vector  :                                                          ' ,& & '      A date vector is eight integers representing a date in the same manner as ' ,& & '      the Fortran DATE_AND_TIME(3f) function:                                   ' ,& & '          yyyy mm dd zone hh mm ss mss                                          ' ,& & '      only numeric time zones are supported.                                    ' ,& & '                                                                                ' ,& & '      When present, the specified date is used instead of the current time.     ' ,& & '                                                                                ' ,& & '   -uet Unix_Epoch_Time  :                                                      ' ,& & '      When present a value is used as the Unix Epoch Time. This date is         ' ,& & '      is then adjusted using any -delta value and then printed using            ' ,& & '      the specified format.                                                     ' ,& & '                                                                                ' ,& & '   -jd Julian_Date  :                                                           ' ,& & '      When present a value is used as the Julian Date.                          ' ,& & '                                                                                ' ,& & '   -delta dd-hh:mm:ss  :                                                        ' ,& & '      Add the specified duration to the date.                                   ' ,& & '                                                                                ' ,& & '   -date date_str  :                                                            ' ,& & '      The guessdate(3f) routine is used to try to convert a date description    ' ,& & '      to a date vector. For the guess to work, dates must either be in the      ' ,& & '      form YYYY-MM-DD or the order of numeric values must be \"\"dd yy yyy\".      ' ,& & '      Only four-digit years are supported. Month names are preferred over       ' ,& & '      numeric values. See the guessdate(3f) documentation for further details.  ' ,& & '                                                                                ' ,& & '   -test :                                                                      ' ,& & '      To list allowed macros use the -test switch.                              ' ,& & '                                                                                ' ,& & '   When present, the specified date is used instead of the current time.        ' ,& & 'EXAMPLES                                                                        ' ,& & ' Sample commands:                                                               ' ,& & '                                                                                ' ,& & '  now                                                                           ' ,& & '    Friday, June 17th, 2016 03:22:53 PM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta  1-0:0:0  # Tomorrow                                               ' ,& & '    Sunday, June 19th, 2016 11:32:26 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now -delta -1-0:0:0  # Yesterday                                              ' ,& & '    Friday, June 17th, 2016 11:32:43 AM UTC-4:00                                ' ,& & '                                                                                ' ,& & '  now long -delta  7-0:0:0  # Next week                                         ' ,& & '    Saturday, June 25th, 2016 11:32:57 AM UTC-04:00                             ' ,& & '                                                                                ' ,& & '  now The date is %Y/%M/%D %h:%m:%s  # user-specified formats using macros      ' ,& & '    The date is 2009/08/10 00:33:48                                             ' ,& & '                                                                                ' ,& & '  now Y/M/D h:m:s # user-specified format with no % character                   ' ,& & '    2009/08/10 00:33:48                                                         ' ,& & '                                                                                ' ,& & '  now year-month-day # user-specified format with no % with long keywords       ' ,& & '  2016-07-29                                                                    ' ,& & '                                                                                ' ,& & '  now -dat 2016 07 23 -240 1 01 00 00  # alternate date                         ' ,& & '  Saturday, July 23rd, 2016 1:01:00 AM UTC-4:00                                 ' ,& & '                                                                                ' ,& & '  now -uet  1469250060                 # alternate Unix Epoch date              ' ,& & '  now -date January 4th, 1999 10:20:30 # try to determine date from description.' ,& & '                                                                                ' ,& & '  now YEAR=%Y MONTH=%M DAY=%D          # YEAR=2009 MONTH=08 DAY=10              ' ,& & '                                                                                ' ,& & '  now HOUR=%h MINUTES=%m SECONDS=%s MILLISECONDS=%x                             ' ,& & '      HOUR=01 MINUTES=18 SECONDS=44 MILLISECONDS=946                            ' ,& & '                                                                                ' ,& & '  # double-quotes are tricky (double them) to put in literally in this program: ' ,& & '  now ''\"\"year-month-day\"\",\"\"hour-minute-second\"\"'' #  \"2017-04-23\",\"14-41-09\"  ' ,& & '                                                                                ' ,& & '  # quotes are easier to control using the single-letter macros(use %q and %Q): ' ,& & '  now QY-M-DQ,Qh:m:sQ                                                           ' ,& & '     \"2017-04-23\",\"14-41-09\"                                                    ' ,& & '                                                                                ' ,& & '  now -test       # Show formatting options, handy way to look up macro names   ' ,& & '                                                                                ' ,& & 'LIMITS                                                                          ' ,& & '  See the M_time module description. Basically, A Gregorian Calendar is         ' ,& & '  assumed, and Leap Seconds are not specifically accounted for.                 ' ,& & 'SEE ALSO                                                                        ' ,& & '   month(1), sec2days(1), days2sec(1), easter(1), paws(1), today(1), ttee(1)    ' ,& & 'AUTHOR                                                                          ' ,& & '   John S. Urban                                                                ' ,& & 'LICENSE                                                                         ' ,& & '   Public Domain                                                                ' ,& & '                                                                                ' ] do i = 1 , size ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 6 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo stop end subroutine usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        now(1f)>' ,& '@(#)DESCRIPTION:    Report a date in a variety of formats>' ,& '@(#)VERSION:        1.0, 2009>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program display_date !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","url":"sourcefile/now.f90.html"},{"title":"demo_u2d.f90 – M_time","text":"Source Code program demo_u2d use M_time , only : u2d , d2u , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) ! get the date using intrinsic call date_and_time ( values = dat ) ! convert today to Julian Date today = d2u ( dat ) write ( * , * ) 'Today=' , fmtdate ( u2d ( today )) ! subtract day write ( * , * ) 'Yesterday=' , fmtdate ( u2d ( today - 8640 0.0_dp )) ! add day write ( * , * ) 'Tomorrow=' , fmtdate ( u2d ( today + 8640 0.0_dp )) end program demo_u2d","tags":"","url":"sourcefile/demo_u2d.f90.html"},{"title":"test_a_A.f90 – M_time","text":"Source Code program test_a_A_format use M_time , only : fmtdate , u2d , days2sec use , intrinsic :: iso_fortran_env , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT implicit none integer , parameter :: wp = kind ( 0.0d0 ) integer :: datnow ( 8 ) integer :: datstart ( 8 ) real ( kind = wp ) :: a , b character ( len = :), allocatable :: string ! %a -- Time since now as d-hh:mm:ss   %a  100-22:59:01 ! %A -- Time since now as seconds      %A  23423008.543 call date_and_time ( values = datnow ) datstart = u2d ( 0 ) ! compare Linux Epoch time to age of now from beginning of Epoch, ! which should be the same value string = fmtdate ( datnow , \"%e\" ) // ' ' // fmtdate ( datstart , \"%A\" ) read ( string , * ) a , b if ( nint ( b - a ). ne . 0 ) then write ( * , * ) 'FAILED: %A test:' , b , a , b - a stop 1 endif ! get same thing in D-hh:mm:ss format and then convert that ! to seconds using days2sec(3f) and should get same result string = fmtdate ( datstart , \"%a\" ) if ( nint ( days2sec ( string ) - b ) . ne . 0 ) then write ( * , * ) 'FAILED: a% test:' , days2sec ( string ), b , days2sec ( string ) - b stop 2 endif stop 'PASSED: tested %a and %A' end program test_a_A_format","tags":"","url":"sourcefile/test_a_a.f90.html"},{"title":"demo_unix_to_date.f90 – M_time","text":"Source Code program demo_unix_to_date use M_time , only : unix_to_date , u2d , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: unixtime ! seconds in a day real ( kind = realtime ), parameter :: DAY = 8640 0.0_dp integer :: dat ( 8 ) integer :: ierr ! sample Unix Epoch time unixtime = 146893903 8.4639933_dp ! create DAT array for today call unix_to_date ( unixtime , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call unix_to_date ( unixtime - DAY , dat , ierr ) ! subtract day and print write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call unix_to_date ( unixtime + DAY , dat , ierr ) ! add day print write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_unix_to_date","tags":"","url":"sourcefile/demo_unix_to_date.f90.html"},{"title":"demo_d2w.f90 – M_time","text":"Source Code program demo_d2w use M_time , only : d2w implicit none integer :: dat ( 8 ) ! input date array integer :: iso_year , iso_week , iso_weekday character ( len = 10 ) :: iso_name call date_and_time ( values = dat ) call d2w ( dat , iso_year , iso_week , iso_weekday , iso_name ) write ( * , '(\"ISO-8601 Week:   \",a)' ) iso_name write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday end program demo_d2w","tags":"","url":"sourcefile/demo_d2w.f90.html"},{"title":"ttee.f90 – M_time","text":"Source Code program ttee ! @(#) ttee(1) writes stdin to stdout and another file with an optional timestamp prefix use iso_fortran_env , only : iostat_end use m_kracken , only : kracken , lget , sget , retrev , IPvalue ! command line parameter cracking module use m_time , only : now , fmtdate_usage use m_strings , only : v2s , chomp implicit none character ( len = IPvalue ) :: string ! hold line read from input character ( len = IPvalue ) :: timestamp ! hold value of --timestamp option character ( len = IPvalue ) :: prefix ! prefix string character ( len = 10 ) :: access ! whether to append or overwrite output file character ( len = IPvalue ) :: file ! output filenames integer :: outfile ! unit number for output file integer :: ios ! value of iostat on i/o errors integer :: ilen , ier logical :: stamp_stdout , stamp_output integer :: len1 , len2 , len3 ! scratch variables for accumulating output filenames integer :: i10 ! counter for looping through file names character ( len = IPvalue ) :: format ! alternate format for the time stamp using the now(3f) function integer :: ii ! length of trimmed format character ( len =* ), parameter :: delimiters = ' ' // char ( 9 ) // char ( 13 ) // char ( 10 ) ! token delimiters (space, tab, return, line feed) character ( len = :), allocatable :: token !  crack command line call kracken ( 'ttee' , '            & & -o -output                     & & -a .F. -append .F.             & & -t \"#N#\" -timestamp \"#N#\"      & & -help .F.                      & & -fmt %Y/%M/%D %h:%m:%s.%x>     & & -version .F.                   & & ' ) call help_version ( lget ( 'ttee_version' )) !  display version number if --version is present !  display help text and exit if --help is present if ( lget ( 'ttee_help' )) then call usage () stop endif !  get time format call retrev ( 'ttee_fmt' , format , ii , ier ) ! assuming timestamp has same length as current timestamp , which might not be if change now(3f) !  decide whether to append to output file or overwrite it if -a or --append is present access = 'sequential' if ( lget ( 'ttee_a' )) then access = 'append' endif if ( lget ( 'ttee_append' )) then access = 'append' endif !  open optional output file ... simply append FILENAME, -o FILENAME, -output FILENAME file = ' ' call retrev ( 'ttee_oo' , file , len1 , ier ) ! get any filename before any keywords len2 = min ( IPvalue , len1 + 2 ) call retrev ( 'ttee_o' , file ( len2 :), len1 , ier ) ! append any filenames after -o keyword len2 = min ( IPvalue , len2 + 2 + len1 + 2 ) call retrev ( 'ttee_output' , file ( len2 :), len1 , ier ) ! append any filenames after -output keyword len3 = len_trim ( file ) ! length of appended filenames if ( len3 . ne . 0 ) then outfile = 9 ! initialize value used to get unit numbers for output files ! get list of filename separators do while ( chomp ( file , token , delimiters ). ge . 0 ) ! open each filename outfile = outfile + 1 open ( unit = outfile , file = token , access = access , iostat = ios ) if ( ios . ne . 0 ) then call stderr ( 'error opening output,iostat=' // v2s ( ios )) exit endif enddo else outfile =- 1 ! flag there is no output file specified endif !  set prefix length to 0 or PLEN depending on whether --timestamp value flags file to have timestamp prefix stamp_stdout = . true . ! prefix stdout stamp_output = . true . ! prefix outfiles prefix = '' ! initialize prefix string call retrev ( 'ttee_t' , timestamp , ilen , ier ) if ( timestamp . eq . '#N#' ) then call retrev ( 'ttee_timestamp' , timestamp , ilen , ier ) endif select case ( timestamp (: ilen )) case ( 'all' , '' , '#N#' ) stamp_stdout = . true . stamp_output = . true . case ( 'stdout' ) stamp_stdout = . true . stamp_output = . false . case ( 'output' ) stamp_stdout = . false . stamp_output = . true . case ( 'none' ) stamp_stdout = . false . stamp_output = . false . case default call stderr ( 'unknown timestamp value [stdout|all|output|none]' ) stop end select !  loop reading stdin till end-of-file or error and write to stdout and output file with optional timestamp prefix infinite : do prefix = now ( format (: ii )) ios = 0 read ( * , '(a)' , iostat = ios ) string if ( ios . ne . 0 ) then if ( ios . ne . iostat_end ) then call stderr ( 'error reading from stdin, iostat=' // v2s ( ios )) endif exit infinite endif ios = 0 ilen = len_trim ( string ) if ( stamp_stdout ) then write ( * , '(a,a)' , iostat = ios ) trim ( prefix ), string (: ilen ) else write ( * , '(a)' , iostat = ios ) string (: ilen ) endif if ( ios . ne . 0 ) then call stderr ( 'error writing to stdout,iostat=' // v2s ( ios )) exit infinite endif ios = 0 if ( outfile . ge . 0 ) then if ( stamp_output ) then do i10 = 10 , outfile write ( i10 , '(a,a)' , iostat = ios ) trim ( prefix ), string (: ilen ) enddo else do i10 = 10 , outfile write ( i10 , '(a)' , iostat = ios ) string (: ilen ) enddo endif endif if ( ios . ne . 0 ) then call stderr ( 'error writing to output,iostat=' // v2s ( ios )) exit infinite endif enddo infinite stop contains subroutine stderr ( msg ) use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT implicit none ! @(#) M_verify stderr(3f) writes a message to standard error character ( len =* ), intent ( in ) :: msg integer :: iostat write ( error_unit , '(a)' , iostat = iostat ) trim ( msg ) flush ( unit = output_unit , iostat = iostat ) flush ( unit = error_unit , iostat = iostat ) end subroutine stderr subroutine usage () ! \"@(#) usage(3f90) writes program help to stdout and exits !character(len=132),parameter :: text(:)= [& character ( len = 132 ), allocatable :: text (:) integer :: i text = [& & 'NAME                                                                            ' , & & '   ttee(1f) - [TIME] write input to stdout and a file with timing info.         ' , & & '   (LICENSE:PD)                                                                 ' , & & '                                                                                ' , & & 'SYNOPSIS                                                                        ' , & & '   ttee [[ -o|--output] filename(s)] [ -a|--append] [ --timestamp FLAG]] ...    ' , & & '        [ -fmt FORMAT] [ --help | --version]                                    ' , & & '                                                                                ' , & & 'DESCRIPTION                                                                     ' , & & '   Read from standard input and write to standard output and files              ' , & & '   with an optional timestamp in front of each line.                            ' , & & '                                                                                ' , & & '   -o|--output FILENAME(S)                                                      ' , & & '         specify name of output file(s). If the filenames are first the         ' , & & '         keyword -o|--output is optional.                                       ' , & & '                                                                                ' , & & '   -a|--append                                                                  ' , & & '         append to the given output file(s), do not overwrite                   ' , & & '                                                                                ' , & & '   -t|--timestamp FLAG                                                          ' , & & '         which files to add the timestamp to. Default is \"all\"                  ' , & & '         Allowed values are stdout, output, all, none.                          ' , & & '                                                                                ' , & & '   -fmt FORMAT                                                                  ' , & & '         Change format for timestamp prefix using a call to now(3f).            ' , & & '                                                                                ' , & & 'CALL FMTDATE_USAGE                                                              ' , & & '   --help     display this help and exit                                        ' , & & '   --version  output version information and exit                               ' , & & 'LIMITS                                                                          ' , & & '    Program limits:                                                             ' , & & '                                                                                ' , & & '    o  Input line width maximum is 1024 characters.                             ' , & & '    o  Maximum length of output filenames is 4098, individual filename is 1024. ' , & & '    o  Minimum number of output files is probably at least 90; but is           ' , & & '       system dependent.                                                        ' , & & '                                                                                ' , & & 'EXAMPLES                                                                        ' , & & '   Basic command usage:                                                         ' , & & '                                                                                ' , & & '    # write stdout of \"program\" to ttee.out with a timestamp and stdout         ' , & & '    program|ttee --output ttee.out --timestamp output|grep -i iteration         ' , & & '                                                                                ' , & & '    # write stdout of \"program\" to log.txt and stdout with a Julian Day         ' , & & '    program|ttee log.txt -fmt \"%J :\"                                            ' , & & '    2457565.488 :Iteration 1 : Error: 1.20                                      ' , & & '    2457565.558 :Iteration 2 : Error: 0.08                                      ' , & & '    2467569.684 :Iteration 3 : Error: 1.2e-3                                    ' , & & 'AUTHOR                                                                          ' , & & '  John S. Urban                                                                 ' , & & 'LICENSE                                                                         ' , & & '  Public Domain                                                                 ' , & & '                                                                                ' ] do i = 1 , SIZE ( text ) select case ( text ( i )) case ( 'CALL FMTDATE_USAGE' ) call fmtdate_usage ( 10 ) case default write ( * , '(a)' ) trim ( text ( i )) end select enddo end subroutine usage subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        ttee(1f)>' ,& '@(#)DESCRIPTION:    split stdout to a file with optional timestamp labeling>' ,& '@(#)VERSION:        1.0, 2015-09-13>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)COPYRIGHT:      Copyright (C) 2009 John S. Urban>' ,& '@(#)LICENSE:        This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version end program ttee !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","url":"sourcefile/ttee.f90.html"},{"title":"test_suite_M_time.F90 – M_time","text":"Source Code program runtest use , intrinsic :: iso_c_binding , only : c_int , c_char , c_null_char use , intrinsic :: iso_fortran_env , only : stdout => OUTPUT_UNIT , stderr => ERROR_UNIT use M_framework__verify , only : unit_test , unit_test_end , unit_test_mode use M_framework__verify , only : unit_test_start , unit_test_msg , unit_test_level use M_framework__verify , only : unit_test_stop use M_time , only : & dow , guessdate , & mo2v , now , ordinal_seconds , & realtime , BAStime , & fmtdate , box_month , & days2sec , sec2days , & phase_of_moon , moon_fullness , easter , & ordinal_to_date , o2d , & unix_to_date , date_to_unix , u2d , d2u , & julian_to_date , date_to_julian , j2d , d2j , & modified_julian_to_date , date_to_modified_julian , m2d , d2m , & bas_to_date , date_to_bas , b2d , d2b , & w2d , d2w , & d2o , & mo2d , & v2mo use M_time , only : locale implicit none integer :: dat ( 8 ) integer :: ierr character ( len =* ), parameter :: SAME = '' ! '-library libGPF -section 3 -description \"' character ( len =* ), parameter :: SAMEEND = '' ! '\"' logical , parameter :: T = . true ., F = . false . integer , parameter :: dp = kind ( 0.0d0 ) call unit_test_mode ( & keep_going = T , & flags = [ 0 ], & luns = [ stdout ], & command = '' , & brief = F , & match = '' , & interactive = F , & CMDLINE = T , & debug = F ) unit_test_level = 0 !! no not use M_system version or will create a circular dependency call put_environment_variable ( 'TZ' , 'America/New_York' , ierr ) ! some of the test values assume EST call put_environment_variable ( 'TZ' , 'UTC+04:00' , ierr ) ! some of the test values assume EST call unit_test_msg ( 'M_time' , 'This section contains unit tests for procedures in the M_time(3f) module.' ) call unit_test_start ( 'box_month      ' , SAME // 'print specified month into character array' // SAMEEND ) call test_box_month () call unit_test_start ( 'd2o            ' , SAME // 'Converts date-time array to Ordinal day' // SAMEEND ) call test_d2o () call unit_test_start ( 'ordinal_seconds' , SAME // 'seconds since begiing of year' // SAMEEND ) call test_ordinal_seconds () call unit_test_start ( 'd2u            ' , SAME // 'Convert date array to Unix Time' // SAMEEND ) call test_d2u () call unit_test_start ( 'd2w            ' , SAME // 'Calculate iso-8601 Week-numbering year date yyyy-Www-d' // SAMEEND ) call test_d2w () call unit_test_start ( 'date_to_unix   ' , SAME // 'Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970, UTC)' // SAMEEND ) call test_date_to_unix () call unit_test_start ( 'days2sec       ' , SAME // 'converts string D-HH:MM:SS to seconds from small to large' // SAMEEND ) call test_days2sec () call unit_test_start ( 'dow            ' , SAME // 'Return the day of the week' // SAMEEND ) call test_dow () call unit_test_start ( 'easter         ' , SAME // 'Determine month and day Easter falls on for given year' // SAMEEND ) call test_easter () !!call unit_test_start('ephemeris      ',SAME//'ephemeris position of planets for adjusting an equatorial telescope'//SAMEEND) !!call test_ephemeris() call unit_test_start ( 'locale        ' , SAME // 'select language for month and weekday names' // SAMEEND ) call test_locale () call unit_test_start ( 'fmtdate        ' , SAME // 'given date array return date as string using format' // SAMEEND ) call test_fmtdate () call unit_test_start ( 'fmtdate_usage  ' , SAME // 'display macros recognized by fmtdate(3f)' // SAMEEND ) call test_fmtdate_usage () call unit_test_start ( 'guessdate      ' , SAME // 'Reads in a date, in various formats' // SAMEEND ) call test_guessdate () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'julian_to_date ' , SAME // 'Converts Julian Date to (year, month, day, hour, minute, second)' // SAMEEND ) call test_julian_to_date () call unit_test_start ( 'j2d            ' , SAME // 'Convert Julian Date to date array' // SAMEEND ) call test_j2d () call unit_test_start ( 'date_to_julian ' , SAME // 'Converts Proleptic Gregorian date array to Julian Date' // SAMEEND ) call test_date_to_julian () call unit_test_start ( 'd2j            ' , SAME // 'Convert date array to Julian Date' // SAMEEND ) call test_d2j () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'modified_julian_to_date' , SAME // 'Convert Modified Julian Date to (year,month,day,hour,minute,second)' // SAMEEND ) call test_modified_julian_to_date () call unit_test_start ( 'm2d            ' , SAME // 'Convert Modified Julian Date to date array' // SAMEEND ) call test_m2d () call unit_test_start ( 'date_to_modified_julian ' , SAME // 'Converts Proleptic Gregorian date array to Modified Julian Date' // SAMEEND ) call test_date_to_julian () call unit_test_start ( 'd2m            ' , SAME // 'Convert date array to Modified Julian Date' // SAMEEND ) call test_d2m () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'bas_to_date    ' , SAME // 'Converts Baseday and Seconds to (year, month, day, hour, minute, second)' // SAMEEND ) call test_bas_to_date () call unit_test_start ( 'b2d            ' , SAME // 'Convert Baseday and Seconds to date array' // SAMEEND ) call test_b2d () call unit_test_start ( 'date_to_bas    ' , SAME // 'Converts Proleptic Gregorian date array to Baseday and Seconds' // SAMEEND ) call test_date_to_bas () call unit_test_start ( 'd2b            ' , SAME // 'Convert date array to Baseday and Seconds' // SAMEEND ) call test_d2b () !----------------------------------------------------------------------------------------------------------------------------------- call unit_test_start ( 'mo2d           ' , SAME // 'return date array for beginning of given month name in specified year' // SAMEEND ) call test_mo2d () call unit_test_start ( 'mo2v           ' , SAME // 'given month as name return month number (1-12) of that month' // SAMEEND ) call test_mo2v () call unit_test_start ( 'moon_fullness  ' , SAME // 'return name for phase of moon for given date' // SAMEEND ) call test_moon_fullness () call unit_test_start ( 'now            ' , SAME // 'return string representing current time given format' // SAMEEND ) call test_now () call unit_test_start ( 'now_ex         ' , SAME // 'use of now(3f) outside of a module' // SAMEEND ) call test_now_ex () call unit_test_start ( 'o2d            ' , SAME // 'given ordinal day of year return date array, Jan 1st=1' // SAMEEND ) call test_o2d () call unit_test_start ( 'ordinal_to_date' , SAME // 'given ordinal day of year return date array, Jan 1st=1' // SAMEEND ) call test_ordinal_to_date () call unit_test_start ( 'phase_of_moon  ' , SAME // 'percentage of moon phase from new to full' // SAMEEND ) call test_phase_of_moon () call unit_test_start ( 'sec2days       ' , SAME // 'converts seconds to string D-HH:MM:SS' // SAMEEND ) call test_sec2days () call unit_test_start ( 'u2d            ' , SAME // 'Convert Unix Time to date array' // SAMEEND ) call test_u2d () call unit_test_start ( 'unix_to_date   ' , SAME // 'Converts Unix Time to date array' // SAMEEND ) call test_unix_to_date () call unit_test_start ( 'v2mo           ' , SAME // 'returns the month name of a Common month' // SAMEEND ) call test_v2mo () call unit_test_start ( 'w2d            ' , SAME // 'Given iso-8601 Week-numbering year date yyyy-Www-d calculate date' // SAMEEND ) call test_w2d () call unit_test_stop ( 'M_time tests completed' ) contains !=================================================================================================================================== subroutine to_upper_extended_ascii () character ( len = :), allocatable :: month_names (:), weekday_names (:), month_names_abbr (:), weekday_names_abbr (:) month_names = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH' , 'APRIL' , 'MAY' , 'JUNE' , 'JULY' , 'AUGUST' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] weekday_names = [ character ( len = 10 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , 'SATURDAY' , 'SUNDAY' ] month_names_abbr = month_names (:)( 1 : 3 ) weekday_names_abbr = weekday_names (:)( 1 : 3 ) call locale ( 'user' , month_names , weekday_names , month_names_abbr , weekday_names_abbr ) end subroutine to_upper_extended_ascii !=================================================================================================================================== #ifndef _WIN32 subroutine put_environment_variable ( name , value , status ) !  This is an private copy of the set_environment_variable routine(3f) routine from !  M_system.FF that is duplicated in order to prevent a circular dependency. ! ident_33=\"@(#)M_system::put_environment_variable(3f): call setenv(3c) to set environment variable\" character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS integer :: loc_err character ( kind = c_char , len = 1 ), allocatable :: temp_chars1 (:) character ( kind = c_char , len = 1 ), allocatable :: temp_chars2 (:) interface integer ( kind = c_int ) function c_setenv ( c_name , c_VALUE ) bind ( C , NAME = \"setenv\" ) import c_int , c_char character ( kind = c_char ) :: c_name ( * ) character ( kind = c_char ) :: c_VALUE ( * ) end function end interface temp_chars1 = str2arr ( trim ( NAME )) temp_chars2 = str2arr ( VALUE ) loc_err = c_setenv ( temp_chars1 , temp_chars2 ) if ( present ( STATUS )) STATUS = loc_err end subroutine put_environment_variable #else subroutine put_environment_variable ( name , value , status ) character ( len =* ) :: NAME character ( len =* ) :: VALUE integer , optional , intent ( out ) :: STATUS write ( * , * ) '<WARNING>put_environment_variable is not working on this platform' if ( present ( STATUS )) STATUS = - 1 end subroutine put_environment_variable #endif !=================================================================================================================================== pure function str2arr ( string ) result ( array ) ! ident_34=\"@(#)M_system::str2arr(3fp): function copies string to null terminated char array\" character ( len =* ), intent ( in ) :: string character ( len = 1 , kind = c_char ) :: array ( len ( string ) + 1 ) integer :: i do i = 1 , len_trim ( string ) array ( i ) = string ( i : i ) enddo array ( size ( array )) = c_null_char end function str2arr !=================================================================================================================================== !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_julian () real ( kind = realtime ) :: julian integer :: ierr integer :: dat ( 8 ) dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , abs ( julian - 244058 7.5d0 ) < 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_julian ( dat , julian , ierr ) call unit_test ( 'date_to_julian' , int ( julian ) == 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_test_end ( 'date_to_julian' ) end subroutine test_date_to_julian !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_julian_to_date () real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected juliandate = 245758 9.129d0 ! set sample Julian Date call julian_to_date ( juliandate , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate - 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call julian_to_date ( juliandate + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & juliandate + 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'julian_to_date' ) end subroutine test_julian_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2j real ( kind = realtime ) :: julian integer :: dat ( 8 ) dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , abs ( julian - 244058 7.5d0 ) < 0.00001 , msg = \"Dec 31st, 1969  8:00(2440587.5)\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2449719 , msg = \"Jan  1st, 1995 12:00(2449719)\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450010 , msg = \"Oct 19th, 1995 12:00(2450010)\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450083 , msg = \"Dec 31st, 1995 12:00(2450083)\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450084 , msg = \"Jan  1st, 1996 12:00(2450084)\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] julian = d2j ( dat ) call unit_test ( 'd2j' , int ( julian ) == 2450449 , msg = \"Dec 31th, 1996 12:00(2450449)\" ) call unit_test_end ( 'd2j' ) end subroutine test_d2j !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_j2d real ( kind = realtime ) :: juliandate character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) juliandate = 245758 9.129d0 ! set sample Julian Date expected = '2016-07-19 11:05:45' dat = j2d ( juliandate ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = j2d ( juliandate - 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate - 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = j2d ( juliandate + 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'j2d' , resulted == expected , juliandate + 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'j2d' ) end subroutine test_j2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_unix real ( kind = realtime ) :: unixtime integer :: ierr integer :: in ( 8 ) integer :: expected in = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] expected = 1490766407 call date_to_unix ( in , unixtime , ierr ) call unit_test ( 'date_to_unix' , abs ( unixtime - expected ) < 0.001 , 'EXPECTED' , expected , 'RESULT' , unixtime ) call unit_test_end ( 'date_to_unix' ) end subroutine test_date_to_unix !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_unix_to_date integer :: ierr integer :: dat ( 8 ) integer :: result ( 8 ) integer :: unixtime dat = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] unixtime = 1490766407 call unix_to_date ( unixtime , result , ierr ) call unit_test ( 'unix_to_date' , all ( dat == result ), 'IN' , unixtime ) !JSU call unit_test ( 'unix_to_date' , ierr == 0 , 'IERR' , ierr ) call unit_test_end ( 'unix_to_date' ) end subroutine test_unix_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2o () integer :: iday , iyear , omonth , oday , rday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) rday = d2o ( dat ) call unit_test ( 'd2o' , iday == rday , msg = tests ( i )) enddo call unit_test_end ( 'd2o' ) end subroutine test_d2o !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_seconds () integer :: rday rday = ordinal_seconds () / ( 60 * 60 * 24 ) call unit_test ( 'ordinal_seconds' , rday == d2o (), rday , d2o ()) call unit_test_end ( 'ordinal_seconds' ) end subroutine test_ordinal_seconds !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_ordinal_to_date () !!use M_time, only : o2d, ordinal_to_date, d2o integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday call ordinal_to_date ( iyear , iday , dat ) call unit_test ( 'ordinal_to_date' , dat ( 2 ) == omonth . and . dat ( 3 ) == oday , 'year' , iyear , 'ordinal' , iday ) enddo call unit_test_end ( 'ordinal_to_date' ) end subroutine test_ordinal_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_o2d () integer :: iday , iyear , omonth , oday integer :: i , dat ( 8 ) character ( len = 40 ), parameter :: tests ( * ) = [ & 'ordinal  year  month  month_day  ' , & '100      2004  4      9          ' , & '100      2005  4      10         ' , & '100      2006  4      10         ' , & '100      2007  4      10         ' , & '100      2008  4      9          ' , & '100      2016  4      9          ' ] character ( len = 40 ) :: readme do i = 2 , size ( tests ) readme = tests ( i ) read ( readme , * ) iday , iyear , omonth , oday dat = o2d ( iday , iyear ) call unit_test ( 'o2d' , dat ( 1 ) == iyear . and . dat ( 2 ) == omonth . and . dat ( 3 ) == oday , msg = tests ( i )) enddo call unit_test_end ( 'o2d' ) end subroutine test_o2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_v2mo call unit_test ( 'v2mo' , v2mo ( 1 ) == 'January' , 'January' , v2mo ( 1 ) ) call unit_test ( 'v2mo' , v2mo ( 2 ) == 'February' , 'February' , v2mo ( 2 ) ) call unit_test ( 'v2mo' , v2mo ( 3 ) == 'March' , 'March' , v2mo ( 3 ) ) call unit_test ( 'v2mo' , v2mo ( 4 ) == 'April' , 'April' , v2mo ( 4 ) ) call unit_test ( 'v2mo' , v2mo ( 5 ) == 'May' , 'May' , v2mo ( 5 ) ) call unit_test ( 'v2mo' , v2mo ( 6 ) == 'June' , 'June' , v2mo ( 6 ) ) call unit_test ( 'v2mo' , v2mo ( 7 ) == 'July' , 'July' , v2mo ( 7 ) ) call unit_test ( 'v2mo' , v2mo ( 8 ) == 'August' , 'August' , v2mo ( 8 ) ) call unit_test ( 'v2mo' , v2mo ( 9 ) == 'September' , 'September' , v2mo ( 9 ) ) call unit_test ( 'v2mo' , v2mo ( 10 ) == 'October' , 'October' , v2mo ( 10 ) ) call unit_test ( 'v2mo' , v2mo ( 11 ) == 'November' , 'November' , v2mo ( 11 ) ) call unit_test ( 'v2mo' , v2mo ( 12 ) == 'December' , 'December' , v2mo ( 12 ) ) call unit_test_end ( 'v2mo' ) end subroutine test_v2mo !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2d integer :: dat ( 8 ) call date_and_time ( values = dat ) call unit_test ( 'mo2d' , all ( mo2d ( 'january' , 2019 ) == [ 2019 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'January    2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'february' , 2019 ) == [ 2019 , 02 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'February   2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'march' , 2019 ) == [ 2019 , 03 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'March      2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'april' , 2019 ) == [ 2019 , 04 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'April      2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'may' , 2019 ) == [ 2019 , 05 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'May        2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'june' , 2019 ) == [ 2019 , 06 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'June       2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'july' , 2019 ) == [ 2019 , 07 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'July       2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'august' , 2019 ) == [ 2019 , 08 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'August     2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'september' , 2019 ) == [ 2019 , 09 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'September  2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'october' , 2019 ) == [ 2019 , 10 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'October    2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'november' , 2019 ) == [ 2019 , 11 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'November   2019' ) call unit_test ( 'mo2d' , all ( mo2d ( 'december' , 2019 ) == [ 2019 , 12 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ]), msg = 'December   2019' ) call unit_test_end ( 'mo2d' ) end subroutine test_mo2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_mo2v () call unit_test ( 'mo2v' , mo2v ( 'jan' ) == 1 , msg = 'Check January' ) call unit_test ( 'mo2v' , mo2v ( 'Feb' ) == 2 , msg = 'Check February' ) call unit_test ( 'mo2v' , mo2v ( 'March' ) == 3 , msg = 'Check March' ) call unit_test ( 'mo2v' , mo2v ( 'APR' ) == 4 , msg = 'Check April' ) call unit_test ( 'mo2v' , mo2v ( 'may' ) == 5 , msg = 'Check May' ) call unit_test ( 'mo2v' , mo2v ( 'jun' ) == 6 , msg = 'Check Jun' ) call unit_test ( 'mo2v' , mo2v ( 'july' ) == 7 , msg = 'Check July' ) call unit_test ( 'mo2v' , mo2v ( 'Aug' ) == 8 , msg = 'Check August' ) call unit_test ( 'mo2v' , mo2v ( 'Sept' ) == 9 , msg = 'Check September' ) call unit_test ( 'mo2v' , mo2v ( 'Oct' ) == 10 , msg = 'Check October' ) call unit_test ( 'mo2v' , mo2v ( 'Nov' ) == 11 , msg = 'Check November' ) call unit_test ( 'mo2v' , mo2v ( 'December' ) == 12 , msg = 'Check December' ) call unit_test ( 'mo2v' , mo2v ( 'ja' ) == 1 , msg = 'Check \"ja\"' ) call unit_test ( 'mo2v' , mo2v ( 'j' ) == - 1 , msg = 'Check \"j\"' ) call unit_test ( 'mo2v' , mo2v ( '' ) == - 1 , msg = 'Check \"\"' ) call unit_test ( 'mo2v' , mo2v ( 'jax' ) == - 1 , msg = 'Check \"jax\"' ) call unit_test_end ( 'mo2v' ) ! assume if got here passed checks end subroutine test_mo2v !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now call unit_test_end ( 'now' ) end subroutine test_now !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_locale () integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr real ( kind = realtime ) :: julian character ( len = :), allocatable :: expected character ( len = :), allocatable :: returned call to_upper_extended_ascii () dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|MAR|MARCH|SAT|SATURDAY|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|MARCH|MAR|MAR|SAT|SAT|SATURDAY|' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|' ) call unit_test ( 'locale' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) ! go forward one day call date_to_julian ( dat , julian , ierr ) julian = julian + 1 dat = j2d ( julian ) expected = '|MAR|MARCH|SUN|SUNDAY|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|MARCH|MAR|MAR|SUN|SUN|SUNDAY|' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|' ) call unit_test ( 'locale' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) call unit_test ( 'locale' , v2mo ( 1 ) == 'JANUARY' , 'JANUARY' , 'expected  JANUARY    got' , v2mo ( 1 ) ) call unit_test ( 'locale' , v2mo ( 2 ) == 'FEBRUARY' , 'FEBRUARY' , 'expected  FEBRUARY   got' , v2mo ( 2 ) ) call unit_test ( 'locale' , v2mo ( 3 ) == 'MARCH' , 'MARCH' , 'expected  MARCH      got' , v2mo ( 3 ) ) call unit_test ( 'locale' , v2mo ( 4 ) == 'APRIL' , 'APRIL' , 'expected  APRIL      got' , v2mo ( 4 ) ) call unit_test ( 'locale' , v2mo ( 5 ) == 'MAY' , 'MAY' , 'expected  MAY        got' , v2mo ( 5 ) ) call unit_test ( 'locale' , v2mo ( 6 ) == 'JUNE' , 'JUNE' , 'expected  JUNE       got' , v2mo ( 6 ) ) call unit_test ( 'locale' , v2mo ( 7 ) == 'JULY' , 'JULY' , 'expected  JULY       got' , v2mo ( 7 ) ) call unit_test ( 'locale' , v2mo ( 8 ) == 'AUGUST' , 'AUGUST' , 'expected  AUGUST     got' , v2mo ( 8 ) ) call unit_test ( 'locale' , v2mo ( 9 ) == 'SEPTEMBER' , 'SEPTEMBER' , 'expected  SEPTEMBER  got' , v2mo ( 9 ) ) call unit_test ( 'locale' , v2mo ( 10 ) == 'OCTOBER' , 'OCTOBER' , 'expected  OCTOBER    got' , v2mo ( 10 ) ) call unit_test ( 'locale' , v2mo ( 11 ) == 'NOVEMBER' , 'NOVEMBER' , 'expected  NOVEMBER   got' , v2mo ( 11 ) ) call unit_test ( 'locale' , v2mo ( 12 ) == 'DECEMBER' , 'DECEMBER' , 'expected  DECEMBER   got' , v2mo ( 12 ) ) call date_and_time ( values = dat ) dat = [ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ] call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'SATURDAY' . and . weekday == 6 , 'expected SATURDAY,6 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'SUNDAY' . and . weekday == 7 , 'expected SUNDAY,7 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'MONDAY' . and . weekday == 1 , 'expected MONDAY,1 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'TUESDAY' . and . weekday == 2 , 'expected TUESDAY,2 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'WEDNESDAY' . and . weekday == 3 , 'expected WEDNESDAY,3 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'THURSDAY' . and . weekday == 4 , 'expected THURSDAY,4 got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 ! next day call dow ( dat , weekday , day , ierr ) call unit_test ( 'locale' , day == 'FRIDAY' . and . weekday == 5 , 'expected FRIDAY,5 got ' , day , weekday ) if ( unit_test_level > 0 ) then call locale ( 'show' ) endif call locale ( 'reset' ) if ( unit_test_level > 0 ) then call locale ( 'show' ) endif dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|Mar|March|Sat|Saturday|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'locale' , returned . eq . expected , 'after reset macros: expected' , expected , 'returned' , returned ) expected = '|March|Mar|Mar|Sat|Sat|Saturday|Sat|Saturday|Mar|March' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|shortweekday|longweekday|shortmonth|longmonth' ) call unit_test ( 'locale' , returned . eq . expected , 'after reset keywords: expected' , expected , 'returned' , returned ) call unit_test_end ( 'locale' ) end subroutine test_locale !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i character ( len = :), allocatable :: expected character ( len = :), allocatable :: returned ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment if ( unit_test_level > 0 ) then call unit_test_msg ( 'fmtdate' , 'GIVEN:' // trim ( date1 ) // ' ' // trim ( comment )) endif call guessdate ( date1 , dat ) ! convert date string to DAT call unit_test ( 'fmtdate' , fmtdate ( dat , 'year-month-day' ) == trim ( date2 ), 'GOT' , fmtdate ( dat , 'year-month-day' ), 'expected' , date2 ) ! convert DAT to ISO week date, all generated dates should match ISO week date call unit_test ( 'fmtdate' , fmtdate ( dat , \"%I\" ) == iso_week_date , msg = iso_week_date ) enddo dat = [ 1957 , 3 , 2 , - 240 , 2 , 0 , 0 , 0 ] expected = '|Mar|March|Sat|Saturday|' returned = fmtdate ( dat , '|%l|%L|%w|%W|' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) expected = '|March|Mar|Mar|Sat|Sat|Saturday|Sat|Saturday' returned = fmtdate ( dat , '|MONTH|Month|Mth|Weekday|wkday|WEEKDAY|shortweekday|longweekday' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'keywords: expected' , expected , 'returned' , returned ) expected = '|2nd|second|02|' returned = fmtdate ( dat , '|shortday|longday|day|' ) call unit_test ( 'fmtdate' , returned . eq . expected , 'macros: expected' , expected , 'returned' , returned ) call unit_test_end ( 'fmtdate' ) end subroutine test_fmtdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_fmtdate_usage call unit_test_end ( 'fmtdate_usage' ) end subroutine test_fmtdate_usage !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_guessdate character ( len = 80 ) :: date1 character ( len = 80 ) :: date2 character ( len = 80 ) :: iso_week_date character ( len = 132 ) :: comment character ( len = 372 ), allocatable :: line (:) integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' \"Sat 1 Jan 2005\",  \"2005-01-01\", \"2004-W53-6\", \" \" ' , & & ' \"Sun 2 Jan 2005\",  \"2005-01-02\", \"2004-W53-7\", \" \" ' , & & ' \"Sat 31 Dec 2005\", \"2005-12-31\", \"2005-W52-6\", \" \" ' , & & ' \"Mon 1 Jan 2007\",  \"2007-01-01\", \"2007-W01-1\", \"Both years 2007 start with the same day.\" ' , & & ' \"Sun 30 Dec 2007\", \"2007-12-30\", \"2007-W52-7\", \" \" ' , & & ' \"Mon 31 Dec 2007\", \"2007-12-31\", \"2008-W01-1\", \" \" ' , & & ' \"Tue 1 Jan 2008\",  \"2008-01-01\", \"2008-W01-2\", & & \"Gregorian year 2008 is a leap year. ISO year 2008 is 2 days shorter: 1 day longer at the start,  3 days shorter at the end.\" ' , & & ' \"Sun 28 Dec 2008\", \"2008-12-28\", \"2008-W52-7\", \" ISO year 2009 begins three days before the end of Gregorian 2008.\" ' , & & ' \"Mon 29 Dec 2008\", \"2008-12-29\", \"2009-W01-1\", \" \" ' , & & ' \"Tue 30 Dec 2008\", \"2008-12-30\", \"2009-W01-2\", \" \" ' , & & ' \"Wed 31 Dec 2008\", \"2008-12-31\", \"2009-W01-3\", \" \" ' , & & ' \"Thu 1 Jan 2009\",  \"2009-01-01\", \"2009-W01-4\", \" \" ' , & & ' \"Thu 31 Dec 2009\", \"2009-12-31\", \"2009-W53-4\", \"ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010.\" ' , & & ' \"Fri 1 Jan 2010\",  \"2010-01-01\", \"2009-W53-5\", \" \" ' , & & ' \"Sat 2 Jan 2010\",  \"2010-01-02\", \"2009-W53-6\", \" \" ' , & & ' \"Sun 3 Jan 2010\",  \"2010-01-03\", \"2009-W53-7\", \" \" ' , & & ' ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) date1 , date2 , iso_week_date , comment call guessdate ( date1 , dat ) ! convert date string to DAT call unit_test ( 'guessdate' ,& & fmtdate ( dat , \"%I\" ) == iso_week_date , 'input' , date1 , 'produced' , fmtdate ( dat , \"%I\" ), 'expected' , iso_week_date ) call unit_test ( 'guessdate' ,& & fmtdate ( dat , \"year-month-day\" ) == date2 , 'input' , date1 , 'produced' , fmtdate ( dat , \"year-month-day\" ), 'expected' , date2 ) enddo call unit_test_end ( 'guessdate' ) end subroutine test_guessdate !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dow integer :: dat ( 8 ) ! input date array integer :: weekday character ( len = 9 ) :: day integer :: ierr call date_and_time ( values = dat ) dat = [ 1957 , 3 , 2 , dat ( 4 ), 12 , 0 , 0 , 0 ] call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Saturday' . and . weekday == 6 , ' expected Saturday,6 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Sunday' . and . weekday == 7 , ' expected Sunday,7 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Monday' . and . weekday == 1 , ' expected Monday,1 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Tuesday' . and . weekday == 2 , ' expected Tuesday,2 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Wednesday' . and . weekday == 3 , ' expected Wednesday,3 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Thursday' . and . weekday == 4 , ' expected Thursday,4 and got ' , day , weekday ) dat ( 3 ) = dat ( 3 ) + 1 call dow ( dat , weekday , day , ierr ) call unit_test ( 'dow' , day == 'Friday' . and . weekday == 5 , ' expected Friday,5 and got ' , day , weekday ) call unit_test_end ( 'dow' ) end subroutine test_dow !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_w2d character ( len = 372 ), allocatable :: line (:) integer :: y , m , d integer :: iso_year integer :: iso_week integer :: iso_weekday integer :: dat ( 8 ) integer :: i ! the data file with dates to read and expected answers and comments line = [ character ( len = 372 ) :: & & ' 2005 01 01  2004 53 6   ' , & & ' 2005 01 02  2004 53 7   ' , & & ' 2005 12 31  2005 52 6   ' , & & ' 2007 01 01  2007 01 1   ' , & & ' 2007 12 30  2007 52 7   ' , & & ' 2007 12 31  2008 01 1   ' , & & ' 2008 01 01  2008 01 2   ' , & & ' 2008 12 28  2008 52 7   ' , & & ' 2008 12 29  2009 01 1   ' , & & ' 2008 12 30  2009 01 2   ' , & & ' 2008 12 31  2009 01 3   ' , & & ' 2009 01 01  2009 01 4   ' , & & ' 2009 12 31  2009 53 4   ' , & & ' 2010 01 01  2009 53 5   ' , & & ' 2010 01 02  2009 53 6   ' , & & ' 2010 01 03  2009 53 7   ' , & & '                          ' ] do i = 1 , size ( line ) - 1 read ( line ( i ), * ) y , m , d , iso_year , iso_week , iso_weekday call w2d ( iso_year , iso_week , iso_weekday , dat ) ! convert ISO week date to DAT call unit_test ( 'w2d' , dat ( 1 ) == y . and . dat ( 2 ) == m . and . dat ( 3 ) == d , msg = line ( i )) ! all should match enddo call unit_test_end ( 'w2d' ) end subroutine test_w2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_box_month integer :: dat ( 8 ) character ( len = 21 ) :: calendar ( 8 ) character ( len = 21 ) :: mnth ( 8 ) dat = [ 2016 , 07 , 01 , - 240 , 12 , 0 , 0 , 0 ] mnth = [ & '      July 2016      ' , & 'Mo Tu We Th Fr Sa Su ' , & '             1  2  3 ' , & ' 4  5  6  7  8  9 10 ' , & '11 12 13 14 15 16 17 ' , & '18 19 20 21 22 23 24 ' , & '25 26 27 28 29 30 31 ' , & '                     ' ] call box_month ( dat , calendar ) if ( unit_test_level > 0 ) then write ( * , '(a)' ) calendar write ( * , '(a)' ) mnth endif call unit_test ( 'box_month' , all ( calendar == mnth ), 'July 2016' ) call unit_test_end ( 'box_month' ) end subroutine test_box_month !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2u () integer , parameter :: aday ( * ) = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] !  Note that time zones are usually -HHMM or -HH:MM and not MM, which is what the DAT array uses !  Comparing to Unix date(1) command: !    date --date \"Wed Mar 29 01:46:47 EDT 2017\" +%s      ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 2017\" +%s          ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 -400 2017\" +%s     ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-400 2017\" +%s  ! 1490766407 !    date --date \"Wed Mar 29 01:46:47 UTC-4:00 2017\" +%s ! 1490766407 ! nint() changed to int(anint() to avoid gfortran OpenBSD bug on i386 call unit_test ( 'd2u' , int ( anint ( d2u ( aday ))) == 1490766407 , d2u ( aday ) ) call unit_test_end ( 'd2u' ) end subroutine test_d2u !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_u2d integer :: ex ( 8 ) integer :: re ( 8 ) integer :: utime utime = 1490766407 ex = [ 2017 , 03 , 29 , - 240 , 01 , 46 , 47 , 0 ] re = u2d ( 1490766407 ) call unit_test ( 'u2d' , all ( re == ex ),& & 'EXPECTED' , 1490766407 , & & 'GOT' , d2u ( ex ) ) call unit_test_end ( 'u2d' ) end subroutine test_u2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_sec2days () call unit_test ( 'sec2days' , sec2days ( 129860 ) == '1-12:04:20' , '129860 is 1-12:04:20' ) call unit_test ( 'sec2days' , sec2days ( 8000 0.0d0 ) == '0-22:13:20' , '80000.0d0 is 0-22:13:20' ) call unit_test ( 'sec2days' , sec2days ( 80000 , crop = . true .) == '22:13:20' , '80000 is 22:13:20' ) call unit_test ( 'sec2days' , sec2days ( '1day 2hr 3 min 4s' ) == '1-02:03:04' , '1day 2hr 3 min 4s is 1-02:03:04' ) call unit_test_end ( 'sec2days' ) end subroutine test_sec2days !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_days2sec () ! add 0 to nint function because of gfortran-11 bug passing some arguments with functions to class(*) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1' )) == 1 , 'expected' , 1 , 'got' , 0 + nint ( days2sec ( '1' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1:00' )) == 60 , 'expected' , 60 , 'got' , 0 + nint ( days2sec ( '1:00' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1:00:00' )) == 3600 , 'expected' , 3600 , 'got' , 0 + nint ( days2sec ( '1:00:00' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( '1-00:00:00' )) == 86400 , 'expected' , 86400 , 'got' , 0 + nint ( days2sec ( '1-00:00:00' ))) call unit_test ( 'days2sec' ,& & nint ( days2sec ( '1d2h 3.0 minutes 4sec' )) == 93784 , 'expected' , 1 , 'got' , 0 + nint ( days2sec ( '1d2h 3.0 minutes 4sec' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1-12:04:20              ' )) == 129860 , & & 'expected' , 129860 , 'got' , 0 + nint ( days2sec ( '1.12:03:20' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5 days                ' )) == 129600 , & & 'expected' , 129600 , 'got' , 0 + nint ( days2sec ( '1.5 days' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5 days 4hrs 30minutes ' )) == 145800 , & & 'expected' , 145800 , 'got' , 0 + nint ( days2sec ( '1.5 days 4hrs 30minutes' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1.5d                    ' )) == 129600 , & & 'expected' , 129600 , 'got' , 0 + nint ( days2sec ( '1.5d' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1d2h3m4s                ' )) == 93784 , & & 'expected' , 93784 , 'got' , 0 + nint ( days2sec ( '1d2h3m4s' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 1d1d1d                  ' )) == 259200 , & & 'expected' , 259200 , 'got' , 0 + nint ( days2sec ( '1d1d1d' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 4d-12h                  ' )) == 302400 , & & 'expected' , 302400 , 'got' , 0 + nint ( days2sec ( '4d-12h' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 3  d  1 2   h           ' )) == 302400 , & & 'expected' , 302400 , 'got' , 0 + nint ( days2sec ( '3 d 1 s  h' ))) call unit_test ( 'days2sec' , 0 + nint ( days2sec ( ' 3h10''20\"' )) == 11420 , & & 'expected' , 11420 , 'got' , 0 + nint ( days2sec ( '3 h 10''20\"' ))) call unit_test_end ( 'days2sec' ) end subroutine test_days2sec !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_phase_of_moon integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_test ( 'phase_of_moon' , phase_of_moon ( dat ) == 'Waning crescent' ) call unit_test_end ( 'phase_of_moon' ) end subroutine test_phase_of_moon !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_moon_fullness integer :: dat ( 8 ) = [ 2018 , 11 , 3 , - 240 , 20 , 18 , 44 , 245 ] call unit_test ( 'moon_fullness' , moon_fullness ( dat ) == - 30 ) call unit_test_end ( 'moon_fullness' ) end subroutine test_moon_fullness !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_easter () character ( len = 20 ), parameter :: tests ( * ) = [ & '1980,4,6  ' , & '1981,4,19 ' , & '1982,4,11 ' , & '1983,4,3  ' , & '1984,4,22 ' , & '1985,4,7  ' , & '1986,3,30 ' , & '1987,4,19 ' , & '1988,4,3  ' , & '1989,3,26 ' , & '1990,4,15 ' , & '1991,3,31 ' , & '1992,4,19 ' , & '1993,4,11 ' , & '1994,4,3  ' , & '1995,4,16 ' , & '1996,4,7  ' , & '1997,3,30 ' , & '1998,4,12 ' , & '1999,4,4  ' , & '2000,4,23 ' , & '2001,4,15 ' , & '2002,3,31 ' , & '2003,4,20 ' , & '2004,4,11 ' , & '2005,3,27 ' , & '2006,4,16 ' , & '2007,4,8  ' , & '2008,3,23 ' , & '2009,4,12 ' , & '2010,4,4  ' , & '2011,4,24 ' , & '2012,4,8  ' , & '2013,3,31 ' , & '2014,4,20 ' , & '2015,4,5  ' , & '2016,3,27 ' , & '2017,4,16 ' , & '2018,4,1  ' , & '2019,4,21 ' , & '2020,4,12 ' , & '2021,4,4  ' , & '2022,4,17 ' , & '2023,4,9  ' , & '2024,3,31 ' ] character ( len = 20 ) :: readme integer :: tmonth , tday integer :: inyear , outmonth , outday integer :: ii integer :: dat ( 8 ) character ( len = 5 ) :: mon ( 3 : 4 ) = ( / 'march' , 'april' / ) do ii = 1 , size ( tests ) readme = tests ( ii ) ! cannot do internal read on a parameter read ( readme , * ) inyear , tmonth , tday call easter ( inyear , dat ) outmonth = dat ( 2 ) outday = dat ( 3 ) call unit_test ( 'easter' , tmonth == outmonth . and . tday == outday , tests ( ii ), 'month=' , mon ( outmonth )) enddo call unit_test_end ( 'easter' ) ! assume if got here passed checks end subroutine test_easter !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_now_ex call unit_test_end ( 'now_ex' ) end subroutine test_now_ex !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2w () call date_and_time ( values = dat ) dat = [ 2005 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 1 Jan 2005 2005-01-01 2004-W53-6 call showme ( \"2004-W53-6\" ) dat = [ 2005 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 2 Jan 2005 2005-01-02 2004-W53-7 call showme ( \"2004-W53-7\" ) dat = [ 2005 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 31 Dec 2005 2005-12-31 2005-W52-6 call showme ( \"2005-W52-6\" ) dat = [ 2007 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 1 Jan 2007 2007-01-01 2007-W01-1 Both years 2007 start with the same day. call showme ( \"2007-W01-1\" ) dat = [ 2007 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 30 Dec 2007 2007-12-30 2007-W52-7 call showme ( \"2007-W52-7\" ) dat = [ 2007 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 31 Dec 2007 2007-12-31 2008-W01-1 call showme ( \"2008-W01-1\" ) dat = [ 2008 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 1 Jan 2008 2008-01-01 2008-W01-2 !     Gregorian year 2008 is a leap year. ... !     ISO year 2008 is 2 days shorter: 1 day longer at the start, 3 days shorter at the end. call showme ( \"2008-W01-2\" ) dat = [ 2008 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 28 Dec 2008 2008-12-28 2008-W52-7 ... !     ISO year 2009 begins three days before the end of Gregorian 2008. call showme ( \"2008-W52-7\" ) dat = [ 2008 , 12 , 29 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Mon 29 Dec 2008 2008-12-29 2009-W01-1 call showme ( \"2009-W01-1\" ) dat = [ 2008 , 12 , 30 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Tue 30 Dec 2008 2008-12-30 2009-W01-2 call showme ( \"2009-W01-2\" ) dat = [ 2008 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Wed 31 Dec 2008 2008-12-31 2009-W01-3 call showme ( \"2009-W01-3\" ) dat = [ 2009 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 1 Jan 2009 2009-01-01 2009-W01-4 call showme ( \"2009-W01-4\" ) dat = [ 2009 , 12 , 31 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Thu 31 Dec 2009 2009-12-31 2009-W53-4  ... !     ISO year 2009 has 53 weeks and ends three days into Gregorian year 2010. call showme ( \"2009-W53-4\" ) dat = [ 2010 , 01 , 01 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Fri 1 Jan 2010 2010-01-01 2009-W53-5 call showme ( \"2009-W53-5\" ) dat = [ 2010 , 01 , 02 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sat 2 Jan 2010 2010-01-02 2009-W53-6 call showme ( \"2009-W53-6\" ) dat = [ 2010 , 01 , 03 , dat ( 4 ), 0 , 0 , 0 , 0 ] !  Sun 3 Jan 2010 2010-01-03 2009-W53-7 call showme ( \"2009-W53-7\" ) call unit_test_end ( 'd2w' ) ! assume if got here passed checks end subroutine test_d2w subroutine showme ( string ) character ( len =* ) :: string integer :: iyear , iweek , iweekday character ( len = 10 ) :: name call d2w ( dat , iyear , iweek , iweekday , name ) call unit_test ( 'd2w' , name == string , iyear , iweek , iweekday , name , string ) end subroutine showme !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_modified_julian () real ( kind = realtime ) :: mjd integer :: ierr integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , abs ( mjd - 244058 7.5d0 - conv ) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2449719 - conv , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450010 - conv , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450083 - conv , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450084 - conv , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_modified_julian ( dat , mjd , ierr ) call unit_test ( 'date_to_modified_julian' , int ( mjd ) == 2450449 - conv , msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'date_to_modified_julian' ) end subroutine test_date_to_modified_julian !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_modified_julian_to_date () real ( kind = realtime ) :: mjd integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime mjd = 245758 9.129d0 - conv ! set sample Modified Julian Date call modified_julian_to_date ( mjd , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call modified_julian_to_date ( mjd - 1.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd - 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call modified_julian_to_date ( mjd + 1.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'modified_julian_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd + 1 , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'modified_julian_to_date' ) end subroutine test_modified_julian_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2m real ( kind = realtime ) :: mjd integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2449719 - conv ) , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450010 - conv ), msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450083 - conv ), msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450084 - conv ), msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] mjd = d2m ( dat ) call unit_test ( 'd2m' , int ( mjd ) == int ( 2450449 - conv ), msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'd2m' ) end subroutine test_d2m !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_m2d real ( kind = realtime ) :: mjd character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) mjd = 245758 9.129d0 - 240000 0.5_realtime ! set sample Modified Julian Date expected = '2016-07-19 11:05:45' dat = m2d ( mjd ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = m2d ( mjd - 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd - 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = m2d ( mjd + 1.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'm2d' , resulted == expected , mjd + 1 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'm2d' ) end subroutine test_m2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_date_to_bas () type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: ierr integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2449719 , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450010 , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450083 , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450084 , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] call date_to_bas ( dat , bas , ierr ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'date_to_bas' , int ( mjd + conv ) == 2450449 , msg = \"Dec 31th, 1996 12:00\" ) call unit_test_end ( 'date_to_bas' ) end subroutine test_date_to_bas !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_bas_to_date () type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: dat ( 8 ) integer :: ierr character ( len = :), allocatable :: expected real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime mjd = 245758 9.129d0 - conv ! set sample Modified Julian Date bas = BAStime ( int ( mjd ), mod ( mjd , 1.0d0 ) * 8640 0.0_realtime ) call bas_to_date ( bas , dat , ierr ) ! create DAT array for this date expected = '2016-07-19 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call bas_to_date ( bas - 8640 0.0d0 , dat , ierr ) ! go back one day expected = '2016-07-18 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call bas_to_date ( bas + 8640 0.0d0 , dat , ierr ) ! go forward one day expected = '2016-07-20 11:05:45' call unit_test ( 'bas_to_date' , fmtdate ( dat , 'year-month-day hour:minute:second' ) == expected ,& & mjd , '==> EXPECTED ' , expected , ' GOT ' , fmtdate ( dat ), 'year-month-day hour:minute:second' ) call unit_test_end ( 'bas_to_date' ) end subroutine test_bas_to_date !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_d2b type ( BAStime ) :: bas real ( kind = realtime ) :: mjd integer :: dat ( 8 ) real ( kind = realtime ), parameter :: conv = 240000 0.5_realtime !                            Modified Julian Dates ! !   To use this table, add the day-of-month to the tabulated entry. !   For example, 30 Jan 2000 = MJD 51573. ! __________________________________________________________________ !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009 integer , parameter :: array ( 1 : 12 , 2000 : 2009 ) = reshape ([ & 51543 , 51909 , 52274 , 52639 , 53004 , 53370 , 53735 , 54100 , 54465 , 54831 , & ! Jan 51574 , 51940 , 52305 , 52670 , 53035 , 53401 , 53766 , 54131 , 54496 , 54862 , & ! Feb 51603 , 51968 , 52333 , 52698 , 53064 , 53429 , 53794 , 54159 , 54525 , 54890 , & ! Mar 51634 , 51999 , 52364 , 52729 , 53095 , 53460 , 53825 , 54190 , 54556 , 54921 , & ! Apr 51664 , 52029 , 52394 , 52759 , 53125 , 53490 , 53855 , 54220 , 54586 , 54951 , & ! May 51695 , 52060 , 52425 , 52790 , 53156 , 53521 , 53886 , 54251 , 54617 , 54982 , & ! Jun 51725 , 52090 , 52455 , 52820 , 53186 , 53551 , 53916 , 54281 , 54647 , 55012 , & ! Jul 51756 , 52121 , 52486 , 52851 , 53217 , 53582 , 53947 , 54312 , 54678 , 55043 , & ! Aug 51787 , 52152 , 52517 , 52882 , 53248 , 53613 , 53978 , 54343 , 54709 , 55074 , & ! Sep 51817 , 52182 , 52547 , 52912 , 53278 , 53643 , 54008 , 54373 , 54739 , 55104 , & ! Oct 51848 , 52213 , 52578 , 52943 , 53309 , 53674 , 54039 , 54404 , 54770 , 55135 , & ! Nov 51878 , 52243 , 52608 , 52973 , 53339 , 53704 , 54069 , 54434 , 54800 , 55165 ],& ! Dec shape = shape ( array ), order = [ 2 , 1 ]) integer :: month , year dat = [ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , abs ( mjd - ( 244058 7.5d0 - conv )) < 0.00001 , msg = \"Dec 31st, 1969  8:00\" ) dat = [ 1995 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2449719 , msg = \"Jan  1st, 1995 12:00\" ) dat = [ 1995 , 10 , 19 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450010 , msg = \"Oct 19th, 1995 12:00\" ) dat = [ 1995 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450083 , msg = \"Dec 31st, 1995 12:00\" ) dat = [ 1996 , 1 , 1 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450084 , msg = \"Jan  1st, 1996 12:00\" ) dat = [ 1996 , 12 , 31 , 0 , 12 , 0 , 0 , 0 ] bas = d2b ( dat ) mjd = bas % base_day + bas % secs / 8640 0.0_realtime call unit_test ( 'd2b' , int ( mjd + conv ) == 2450449 , msg = \"Dec 31th, 1996 12:00\" ) do month = 1 , 12 do year = 2000 , 2009 !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds] dat = [ year , month , 1 , 0 , 0 , 0 , 0 , 0 ] bas = d2b ( dat ) call unit_test ( 'd2b' , array ( month , year ) + 1 == bas % base_day , year , month , array ( month , year ) + 1 , bas % base_day ) enddo enddo call unit_test_end ( 'd2b' ) end subroutine test_d2b !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_b2d type ( BAStime ) :: bas real ( kind = realtime ) :: mjd character ( len = :), allocatable :: expected character ( len = :), allocatable :: resulted integer :: dat ( 8 ) mjd = 245758 9.129d0 - 240000 0.5_realtime ! set sample Modified Julian Date bas = BAStime ( int ( mjd ), mod ( mjd , 1.0d0 ) * 8640 0.0_realtime ) expected = '2016-07-19 11:05:45' dat = b2d ( bas ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go back one day expected = '2016-07-18 11:05:45' dat = b2d ( bas - 8640 0.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd - 1.0 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) ! go forward one day expected = '2016-07-20 11:05:45' dat = b2d ( bas + 8640 0.0d0 ) resulted = fmtdate ( dat , 'year-month-day hour:minute:second' ) call unit_test ( 'b2d' , resulted == expected , mjd + 1.0 , '==> EXPECTED ' , expected , ' GOT ' , resulted ) call unit_test_end ( 'b2d' ) end subroutine test_b2d !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT","tags":"","url":"sourcefile/test_suite_m_time.f90.html"},{"title":"demo_ordinal_seconds.f90 – M_time","text":"Source Code program demo_ordinal_seconds use M_time , only : ordinal_seconds implicit none character ( len =* ), parameter :: gen = '(*(g0))' integer :: i , istart , iend real , volatile :: x istart = ordinal_seconds () x = 0.0 do i = 1 , 1000000000 x = x + sqrt ( real ( i )) enddo print gen , 'x=' , x iend = ordinal_seconds () print gen , 'that took ' , iend - istart , ' seconds' print gen , iend , '-' , istart , '=' , iend - istart end program demo_ordinal_seconds","tags":"","url":"sourcefile/demo_ordinal_seconds.f90.html"},{"title":"demo_d2b.f90 – M_time","text":"Source Code program demo_d2b use M_time , only : d2b , BAStime , d2j , d2m implicit none integer :: dat ( 8 ) type ( BAStime ) :: bas !                            Modified Julian Dates ! !   To use this table, add the day-of-month to the tabulated entry. !   For example, 30 Jan 2000 = MJD 51573. ! __________________________________________________________________ !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009 integer , parameter :: array ( 1 : 12 , 2000 : 2009 ) = reshape ([ & 51543 , 51909 , 52274 , 52639 , 53004 , 53370 , 53735 , 54100 , 54465 , 54831 , & ! Jan 51574 , 51940 , 52305 , 52670 , 53035 , 53401 , 53766 , 54131 , 54496 , 54862 , & ! Feb 51603 , 51968 , 52333 , 52698 , 53064 , 53429 , 53794 , 54159 , 54525 , 54890 , & ! Mar 51634 , 51999 , 52364 , 52729 , 53095 , 53460 , 53825 , 54190 , 54556 , 54921 , & ! Apr 51664 , 52029 , 52394 , 52759 , 53125 , 53490 , 53855 , 54220 , 54586 , 54951 , & ! May 51695 , 52060 , 52425 , 52790 , 53156 , 53521 , 53886 , 54251 , 54617 , 54982 , & ! Jun 51725 , 52090 , 52455 , 52820 , 53186 , 53551 , 53916 , 54281 , 54647 , 55012 , & ! Jul 51756 , 52121 , 52486 , 52851 , 53217 , 53582 , 53947 , 54312 , 54678 , 55043 , & ! Aug 51787 , 52152 , 52517 , 52882 , 53248 , 53613 , 53978 , 54343 , 54709 , 55074 , & ! Sep 51817 , 52182 , 52547 , 52912 , 53278 , 53643 , 54008 , 54373 , 54739 , 55104 , & ! Oct 51848 , 52213 , 52578 , 52943 , 53309 , 53674 , 54039 , 54404 , 54770 , 55135 , & ! Nov 51878 , 52243 , 52608 , 52973 , 53339 , 53704 , 54069 , 54434 , 54800 , 55165 ],& ! Dec shape = shape ( array ), order = [ 2 , 1 ]) integer :: i , j call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat bas = d2b ( dat ) write ( * , * ) 'Baseday and Seconds is' , bas write ( * , * ) 'Baseday is' , bas % base_day ! whole days since the MJD Epoch date write ( * , * ) 'Seconds is' , bas % secs ! offset in seconds from start of BASE_DAY ! print any date that does not match regression test values do i = 2000 , 2009 do j = 1 , 12 !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds] dat = [ i , j , 1 , 0 , 0 , 0 , 0 , 0 ] ! first day of month bas = d2b ( dat ) if ( array ( j , i ) + 1. ne . bas % base_day ) then write ( * , * ) i , j , array ( j , i ) + 1 , d2b ( dat ), d2m ( dat ), d2j ( dat ) - 240000 0.5 endif enddo enddo end program demo_d2b","tags":"","url":"sourcefile/demo_d2b.f90.html"},{"title":"demo_d2u.f90 – M_time","text":"Source Code program demo_d2u use M_time , only : d2u implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Unix Epoch time is ' , d2u ( dat ) end program demo_d2u","tags":"","url":"sourcefile/demo_d2u.f90.html"},{"title":"demo_bas_to_date.f90 – M_time","text":"Source Code program demo_bas_to_date use M_time , only : bas_to_date , fmtdate , realtime , BAStime implicit none integer , parameter :: dp = kind ( 0.0d0 ) type ( BAStime ) :: bas , tomorrow , yesterday integer :: dat ( 8 ) integer :: ierr character ( len =* ), parameter :: g = '(*(g0,1x))' write ( * , g ) 'bas_to_date:' ! set sample Baseday and Seconds date bas = BAStime ( 60700 , 0.213682349771_dp ) ! create DAT array for this date call bas_to_date ( bas , dat , ierr ) write ( * , g ) 'Sample Date=' , fmtdate ( dat ) ! write ( * , g ) 'add and subtract days from base_day:' ! go back one day yesterday = BAStime ( bas % base_day - 1 , bas % secs ) call bas_to_date ( yesterday , dat , ierr ) write ( * , g ) 'Day Before =' , fmtdate ( dat ) ! ! go forward one day tomorrow = BAStime ( bas % base_day + 1 , bas % secs ) call bas_to_date ( tomorrow , dat , ierr ) write ( * , g ) 'Day After  =' , fmtdate ( dat ) write ( * , g ) 'add and subtract seconds from BAS:' ! go back one day yesterday = bas - 86400 call bas_to_date ( yesterday , dat , ierr ) write ( * , g ) 'Day Before =' , fmtdate ( dat ) ! ! go forward one day yesterday = bas + 86400 call bas_to_date ( tomorrow , dat , ierr ) write ( * , g ) 'Day After  =' , fmtdate ( dat ) ! end program demo_bas_to_date","tags":"","url":"sourcefile/demo_bas_to_date.f90.html"},{"title":"demo_guessdate.f90 – M_time","text":"Source Code program demo_guessdate use M_time , only : guessdate , fmtdate implicit none character ( len = 20 ), allocatable :: datestrings (:) character ( len = :), allocatable :: answer integer :: dat ( 8 ) integer :: i datestrings = [ & & 'January 9th, 2001   ' ,& & ' Tue Jul 19 2016    ' ,& & ' 21/12/2016         ' ,& & ' 4th of Jul 2004    ' ] do i = 1 , size ( datestrings ) write ( * , '(a)' ) repeat ( '-' , 80 ) write ( * , * ) 'TRYING ' , datestrings ( i ) call guessdate ( datestrings ( i ), dat ) write ( * , * ) 'DAT ARRAY ' , dat answer = fmtdate ( dat ) write ( * , * ) 'FOR ' // datestrings ( i ) // ' GOT ' // trim ( answer ) enddo end program demo_guessdate","tags":"","url":"sourcefile/demo_guessdate.f90.html"},{"title":"language.f90 – M_time","text":"Source Code program testit use M_time , only : now , locale call locale ( 'show' ) write ( * , * ) now () call locale ( 'LANGUAGE' ) call locale ( 'show' ) write ( * , * ) now () call locale ( 'french' ) call locale ( 'show' ) write ( * , * ) now () call locale ( 'LANGUAGE' ) call locale ( 'show' ) write ( * , * ) now () end program testit","tags":"","url":"sourcefile/language.f90.html"},{"title":"demo_v2mo.f90 – M_time","text":"Source Code program demo_v2mo use M_time , only : v2mo implicit none integer :: i write ( * , * )( v2mo ( i ), i = 1 , 13 ) end program demo_v2mo","tags":"","url":"sourcefile/demo_v2mo.f90.html"},{"title":"demo_mo2v.f90 – M_time","text":"Source Code program demo_mo2v use M_time , only : mo2v implicit none write ( * , * ) mo2v ( \"April\" ) write ( * , * ) mo2v ( 'Apr' ) write ( * , * ) mo2v ( 'sexember' ) write ( * , * ) mo2v ( 'unknown' ) ! returns -1 end program demo_mo2v","tags":"","url":"sourcefile/demo_mo2v.f90.html"},{"title":"demo_julian_to_date.f90 – M_time","text":"Source Code program demo_julian_to_date use M_time , only : julian_to_date , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: juliandate integer :: dat ( 8 ) integer :: ierr ! set sample Julian Date juliandate = 245758 9.129_dp ! create DAT array for this date call julian_to_date ( juliandate , dat , ierr ) write ( * , * ) 'Sample Date=' , fmtdate ( dat ) ! go back one day call julian_to_date ( juliandate - 1.0_dp , dat , ierr ) write ( * , * ) 'Day Before =' , fmtdate ( dat ) ! go forward one day call julian_to_date ( juliandate + 1.0_dp , dat , ierr ) write ( * , * ) 'Day After  =' , fmtdate ( dat ) end program demo_julian_to_date","tags":"","url":"sourcefile/demo_julian_to_date.f90.html"},{"title":"to.f90 – M_time","text":"Source Code program testit use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT use M_time , only : now , locale call to_upper_extended_ascii () call locale ( 'chars' ) call locale ( 'show' ) call locale ( 'fr_FR' ) call locale ( 'show' ) call locale ( 'reset' ) ! recursive I/O is currently non-standard write ( stderr , * ) now ( 'help' ) write ( * , * ) now ( '%L %l %d %N %w %W' ) contains subroutine to_upper_extended_ascii () character ( len =* ), parameter :: month_names ( * ) = [ character ( len = 9 ) :: & & 'JANUARY' , 'FEBRUARY' , 'MARCH' , 'APRIL' , 'MAY' , 'JUNE' ,& & 'JULY' , 'AUGUST' , 'SEPTEMBER' , 'OCTOBER' , 'NOVEMBER' , 'DECEMBER' ] character ( len =* ), parameter :: weekday_names ( * ) = [ character ( len = 10 ) :: & & 'MONDAY' , 'TUESDAY' , 'WEDNESDAY' , 'THURSDAY' , 'FRIDAY' , & & 'SATURDAY' , 'SUNDAY' ] character ( len =* ), parameter :: month_names_abbr ( * ) = month_names (:)( 1 : 3 ) character ( len =* ), parameter :: weekday_names_abbr ( * ) = weekday_names (:)( 1 : 3 ) call locale ( 'user' , month_names , weekday_names , month_names_abbr , weekday_names_abbr ) end subroutine to_upper_extended_ascii end program testit","tags":"","url":"sourcefile/to.f90.html"},{"title":"demo_phase_of_moon.f90 – M_time","text":"Source Code program demo_phase_of_moon use M_time , only : now use M_time , only : phase_of_moon use M_time , only : moon_fullness implicit none integer :: dat ( 8 ) ! generate DAT array call date_and_time ( values = dat ) ! show DAT array write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat ! the %p and %P fields are supported by fmtdate(3f) write ( * , * )& & now ( 'The phase of the moon is %p, with a fullness of %P' ) write ( * , '(1x,*(a))' , advance = 'no' )& & 'The phase of the moon is ' , trim ( phase_of_moon ( dat )), ',' write ( * , '(1x,a,i0,a)' ) 'with a fullness of ' , moon_fullness ( dat ), '%' end program demo_phase_of_moon","tags":"","url":"sourcefile/demo_phase_of_moon.f90.html"},{"title":"demo_w2d.f90 – M_time","text":"Source Code program demo_w2d use M_time , only : w2d , fmtdate implicit none write ( * , '(a)' )& & 'Given Monday 29 December 2008 is written \"2009-W01-1\"' call printit ( 2009 , 1 , 1 ) write ( * , '(a)' )& & 'Given Sunday 3 January 2010 is written \"2009-W53-7\"' call printit ( 2009 , 53 , 7 ) write ( * , '(a)' )& & 'Given the Gregorian date Sun 31 December 2006 & &is written 2006-W52-7' call printit ( 2006 , 52 , 7 ) write ( * , '(a)' )& & 'Given 27 September 2008 is 2008-W39-6' call printit ( 2008 , 39 , 6 ) string : block character ( len =* ), parameter :: array ( 4 ) = [ character ( len = 80 ) :: & & '2008-W39-6' , '2008W396' , '2008-W39' , '2008W39' ] integer :: dat ( 8 ) integer :: i do i = 1 , size ( array ) write ( * , '(a)' )& & 'Given string ' // array ( i ) call w2d ( array ( i ), dat ) write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) enddo endblock string contains subroutine printit ( iso_year , iso_week , iso_weekday ) ! ISO-8601 Week: 2016-W29-1 integer :: iso_year , iso_week , iso_weekday ! input date array integer :: dat ( 8 ) call w2d ( iso_year , iso_week , iso_weekday , dat ) write ( * , '(a,i0)' ) 'GIVEN:           ' write ( * , '(a,i0)' ) 'ISO-8601 year    ' , iso_year write ( * , '(a,i0)' ) 'ISO-8601 week    ' , iso_week write ( * , '(a,i0)' ) 'ISO-8601 weekday ' , iso_weekday write ( * , '(a,i0)' ) 'RESULT:          ' write ( * , '(a,*(i0:,\",\"))' ) '   DAT array        ' , dat write ( * , '(a,/,67(\"=\"))' ) '    ' // fmtdate ( dat , 'long' ) end subroutine printit end program demo_w2d","tags":"","url":"sourcefile/demo_w2d.f90.html"},{"title":"demo_date_to_modified_julian.f90 – M_time","text":"Source Code program demo_date_to_modified_julian use M_time , only : date_to_modified_julian use M_time , only : date_to_julian , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: modified_juliandate real ( kind = realtime ) :: juliandate integer :: ierr character ( len =* ), parameter :: g = '(*(g0,1x))' ! ! generate DAT array call date_and_time ( values = dat ) ! ! show DAT array write ( * , '(\"Today is:\",*(i0:,\":\"))' ) dat ! ! convert DAT to Julian Date call date_to_julian ( dat , juliandate , ierr ) write ( * , g ) 'Expecting:' , juliandate - 240000 0.5_realtime ! ! convert DAT to Modified Julian Date call date_to_modified_julian ( dat , modified_juliandate , ierr ) write ( * , g ) 'Modified Julian Date is ' , modified_juliandate end program demo_date_to_modified_julian","tags":"","url":"sourcefile/demo_date_to_modified_julian.f90.html"},{"title":"demo_M_time.f90 – M_time","text":"Source Code program demo_M_time use M_time , only : j2d , d2j , u2d , d2u , fmtdate , realtime integer :: dat ( 8 ) real ( kind = realtime ) :: julian , unixtime character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' character ( len = :), allocatable :: friendly friendly = '%W, %L %d, %Y %H:%m:%s %N' ! a nice friendly format call date_and_time ( values = dat ) ! current time is placed in array write ( * , * ) 'Today' write ( * , * ) 'ISO       ' , fmtdate ( dat , iso_fmt ) write ( * , * ) 'Friendly  ' , fmtdate ( dat , friendly ) write ( * , * ) 'ISO week  ' , fmtdate ( dat , '%I' ) julian = d2j ( dat ) unixtime = d2u ( dat ) write ( * , * ) 'Yesterday' ! subtract a day from scalar time and print write ( * , * ) '          ' , fmtdate ( u2d ( unixtime - 86400 ), iso_fmt ) write ( * , * ) '          ' , fmtdate ( j2d ( julian - 1.0 ), friendly ) write ( * , * ) '          ' , fmtdate ( j2d ( julian - 1.0 ), '%I' ) write ( * , * ) 'Tomorrow' ! add a day to scalar time and print write ( * , * ) '          ' , fmtdate ( u2d ( unixtime + 86400 ), iso_fmt ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 1.0 ), friendly ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 1.0 ), '%I' ) write ( * , * ) 'Next Week' ! add a week to scalar time and print write ( * , * ) '          ' , fmtdate ( u2d ( unixtime + 7 * 86400 ), iso_fmt ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 7.0 ), friendly ) write ( * , * ) '          ' , fmtdate ( j2d ( julian + 7.0 ), '%I' ) end program demo_M_time","tags":"","url":"sourcefile/demo_m_time.f90.html"},{"title":"demo_fmtdate.f90 – M_time","text":"Source Code program demo_fmtdate use M_time , only : fmtdate implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , * ) fmtdate ( dat , \"current date: %w, %l %d, %Y %H:%m:%s %N\" ) end program demo_fmtdate","tags":"","url":"sourcefile/demo_fmtdate.f90.html"},{"title":"demo_now.f90 – M_time","text":"Source Code program demo_now use M_time , only : now , locale implicit none ! MACROS write ( * , * ) now ( \"The current date is & &%w, %l %d, %Y %H:%m:%s %N\" ) ! If macros are not found substitute values for KEYWORDS write ( * , * ) now ( \"The current date is & &year/month/day hour:minute:second timezone\" ) write ( * , * ) now ( \"The current date is & &longweekday at HOUR GOOD, longmonth shortday, year\" ) ! including some HIGH-LEVEL KEYWORDS write ( * , * ) now ( \"iso\" ) ! and if no keywords are found, ABBREVIATED MACROS write ( * , * ) now ( \"Y-M-D h:m:s\" ) ! and basic INTERNATIONALIZATION is available call locale ( 'french' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) call locale ( 'slovak' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) call locale ( 'spanish' ) write ( * , * ) now ( \"%W, %L %D, %Y %h:%m:%s \" ) end program demo_now","tags":"","url":"sourcefile/demo_now.f90.html"},{"title":"timethis.f90 – M_time","text":"Source Code program TimeThis_exe !@(#) timethis(1): Emulate the DOS TimeThis command with standard Fortran use M_time , only : fmtdate use , intrinsic :: iso_fortran_env , only : int64 use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT ! @(#) given a command on the command line run the command and print wallclock time and echo command implicit none character ( len =* ), parameter :: all = '(*(g0,1x))' integer :: ier character ( len = :), allocatable :: command , starttime , endtime integer ( kind = int64 ) :: jtime ( 2 ) call get_cmd ( command , ier ) ! get the command including an attempt to requote quoted strings if ( ier . eq . 0 ) then call millijulian ( jtime ( 1 ), starttime ) if ( command . ne . '' ) ier = run ( command ) call millijulian ( jtime ( 2 ), endtime ) write ( * , all ) 'TimeThis :  Command Line : ' , trim ( adjustl ( command )) write ( * , all ) 'TimeThis :    Start Time : ' , starttime write ( * , all ) 'TimeThis :      End Time : ' , endtime write ( * , all ) 'TimeThis :  Elapsed Time : ' , millisec2days ( jtime ( 2 ) - jtime ( 1 ) ) !------------------------------------------------------ !TimeThis :  Command Line :  dir !TimeThis :    Start Time :  Wed Dec 23 12:29:38 2020 !TimeThis :      End Time :  Wed Dec 23 12:29:39 2020 !TimeThis :  Elapsed Time :  00:00:00.077 !------------------------------------------------------ else write ( * , all ) '<ERROR>*TimeThis* STATUS:' , ier endif contains function run ( command ) ! @(#) M_system run(3f) call execute_command_line as a function character ( len =* ), intent ( in ) :: command integer :: exitstat integer :: cmdstat integer :: run character ( len = 256 ) :: cmdmsg cmdmsg = ' ' call execute_command_line ( trim ( command ), wait = . true ., exitstat = exitstat , cmdstat = cmdstat , cmdmsg = cmdmsg ) if ( cmdstat . ne . 0 ) then write ( stderr , * ) trim ( cmdmsg ) endif run = cmdstat end function run function millisec2days ( milliseconds ) result ( dhms ) ! @(#) M_time millisec2days(3f) converts milliseconds to string showing days of form D-HH:MM:SS.SSS integer ( kind = int64 ), intent ( in ) :: milliseconds integer ( kind = int64 ) :: days , hours , minutes , secsleft , left integer ( kind = int64 ), parameter :: ONE_DAY = 86400 , ONE_HOUR = 3600 , ONE_MINUTE = 60 character ( len = :), allocatable :: dhms character ( len = 40 ) :: scratch secsleft = milliseconds / 1000 left = mod ( milliseconds , 1000 ) days = secsleft / ONE_DAY ! get whole number of days secsleft = secsleft - days * ONE_DAY ! calculate remainder hours = secsleft / ONE_HOUR ! get whole number of hours secsleft = secsleft - hours * ONE_HOUR minutes = secsleft / ONE_MINUTE ! get whole number of minutes secsleft = secsleft - minutes * ONE_MINUTE write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) days , hours , minutes , secsleft , left dhms = trim ( scratch ) end function millisec2days subroutine get_cmd ( command , status ) ! @(#) compose a command from all the arguments passed to the program character ( len =* ), parameter :: gen = '(*(g0))' character ( len = :), allocatable , intent ( out ) :: command ! string of all arguments to create integer , intent ( out ) :: status ! status (non-zero means error) integer :: i , j character ( len = :), allocatable :: value , valueb ! hold individual arguments one at a time character ( len = 255 ) :: errmsg integer :: length ! length of individual arguments command = \"\" ! initialize returned output string errmsg = \"\" status = 0 ERRORS : BLOCK do i = 1 , command_argument_count () !call get_command_argument(i,length=length,status=status,errmsg=errmsg)   ! get length of next argument call get_command_argument ( i , length = length , status = status ) ! get length of next argument if ( status . ne . 0 ) exit ERRORS value = repeat ( ' ' , length ) !call get_command_argument(i,value=value,status=status,errmsg=errmsg)     ! get next argument call get_command_argument ( i , value = value , status = status ) ! get next argument if ( status /= 0 ) exit ERRORS if ( length . gt . 0 ) then ! SIMPLISTIC GUESS AT RE-QUOTING STRING ! assuming an operating system shell that strips the quotes from quoted strings on the command line. ! if argument contains a space and does not contain a double-quote ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. if ( index ( value , ' ' ). ne . 0. and . index ( value , '\"' ). eq . 0 ) then value = '\"' // value // '\"' elseif ( index ( value , '\"' ). ne . 0 ) then ! assume you double doublequotes to escape them and short enough that reallocating a lot not an issue valueb = '' do j = 1 , len ( value ) if ( value ( j : j ) == '\"' ) valueb = valueb // '\"' valueb = valueb // value ( j : j ) enddo value = '\"' // valueb // '\"' endif command = command // ' ' // value ! append strings together else command = command // '\"\"' endif enddo return endblock ERRORS write ( stderr , gen ) '*get_cmd* error obtaining argument ' , i , 'errmsg=' , trim ( errmsg ) stop end subroutine get_cmd subroutine millijulian ( jm , timestr ) ! @(#)millijulian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date in milliseconds in Zulu timezone integer :: dat ( 8 ) integer ( kind = int64 ) :: a , y , m , jdn , utc integer ( kind = int64 ), intent ( out ) :: jm character ( len = :), allocatable :: timestr call date_and_time ( values = dat ) timestr = fmtdate ( dat , 'wkday Mth day hour:minute:second year' ) associate & &( year => dat ( 1 ), month => dat ( 2 ), day => dat ( 3 ), hour => dat ( 5 ), minute => dat ( 6 ), second => dat ( 7 ), milli => dat ( 8 )) !  You must first compute the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) a = ( 14_int64 - month ) / 12_int64 ! A will be 1 for January or February, and 0 for other months, with integer truncation y = year + 4800_int64 - a m = month + 12_int64 * a - 3_int64 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero ! intentionally computing with integer truncation jdn = day + ( 153_int64 * m + 2_int64 ) / 5_int64 + 365_int64 * y + y / 4_int64 - y / 100_int64 + y / 400_int64 - 32045_int64 !  Finding the Julian time in milliseconds given the JDN (Julian day number) and time of day jm = ( jdn * 86400_int64 + hour * 3600_int64 + minute * 60_int64 + second ) * 1000_int64 + milli end associate utc = dat ( 4 ) * 60 * 1000 ! Time difference with UTC in minutes converted to milliseconds jm = jm + utc ! set all values to Zulu time end subroutine millijulian subroutine say_hello () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options character ( len =* ), parameter :: all = '(*(g0,1x))' character ( len =* ), parameter :: chs = '(*(g0))' character ( len = 2 ) :: ch , split integer :: argument_length , istat , posix , dos , i character ( len = :), allocatable :: progname , options call get_command_argument ( number = 0 , length = argument_length ) if ( allocated ( progname )) deallocate ( progname ) allocate ( character ( len = argument_length ) :: progname ) call get_command_argument ( 0 , progname , status = istat ) if ( istat == 0 ) then print all , \"program name.:\" // trim ( progname ) else print all , \"Could not get the program name \" // trim ( progname ) endif print all , 'compiled by..:' , compiler_version () options = ' ' // compiler_options () if ( options /= '' ) then print all , 'using options:' ! guess which one posix = 0 dos = 0 do i = 2 , len ( options ) ch = options ( i - 1 : i ) select case ( ch ) case ( ' -' ); posix = posix + 1 case ( ' /' ); dos = dos + 1 end select enddo split = merge ( ' -' , ' /' , posix > 0 ) do i = 2 , len ( options ) ch = options ( i - 1 : i ) if ( ch == split ) then write ( * , chs , advance = 'no' ) char ( 10 ), ch else write ( * , chs , advance = 'no' ) ch ( 2 : 2 ) endif enddo print all endif print all end subroutine say_hello end program TimeThis_exe","tags":"","url":"sourcefile/timethis.f90.html"},{"title":"howlong.f90 – M_time","text":"Source Code program howlong_exe ! @(#) given a command on the command line run the command and print wallclock time and echo command use , intrinsic :: iso_fortran_env , only : int64 use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT use M_CLI2 , only : set_args , lget , rget , sgets implicit none character ( len =* ), parameter :: all = '(*(g0,1x))' integer :: ier character ( len = :), allocatable :: command integer ( kind = int64 ) :: jtime ( 2 ) character ( len = :), allocatable :: help_text (:) character ( len = :), allocatable :: version_text (:) call setup () call set_args ( ' ' , help_text = help_text , version_text = version_text ) call get_cmd ( command , ier ) ! get the command including an attempt to requote quoted strings if ( ier . eq . 0 ) then jtime ( 1 ) = millijulian () if ( command . ne . '' ) ier = run ( command ) jtime ( 2 ) = millijulian () write ( * , all ) 'Wallclock:' , millisec2days ( jtime ( 2 ) - jtime ( 1 ) ), ':command:' , trim ( adjustl ( command )) else write ( * , all ) '<ERROR>STATUS:' , ier endif contains function run ( command ) ! @(#) M_system run(3f) call execute_command_line as a function character ( len =* ), intent ( in ) :: command integer :: exitstat integer :: cmdstat integer :: run character ( len = 256 ) :: cmdmsg cmdmsg = ' ' call execute_command_line ( trim ( command ), wait = . true ., exitstat = exitstat , cmdstat = cmdstat , cmdmsg = cmdmsg ) if ( cmdstat . ne . 0 ) then write ( stderr , * ) trim ( cmdmsg ) endif run = cmdstat end function run function millisec2days ( milliseconds ) result ( dhms ) ! @(#) M_time millisec2days(3f) converts milliseconds to string showing days of form D-HH:MM:SS.SSS integer ( kind = int64 ), intent ( in ) :: milliseconds integer ( kind = int64 ) :: days , hours , minutes , secsleft , left integer ( kind = int64 ), parameter :: ONE_DAY = 86400 , ONE_HOUR = 3600 , ONE_MINUTE = 60 character ( len = :), allocatable :: dhms character ( len = 40 ) :: scratch secsleft = milliseconds / 1000 left = mod ( milliseconds , 1000 ) days = secsleft / ONE_DAY ! get whole number of days secsleft = secsleft - days * ONE_DAY ! calculate remainder hours = secsleft / ONE_HOUR ! get whole number of hours secsleft = secsleft - hours * ONE_HOUR minutes = secsleft / ONE_MINUTE ! get whole number of minutes secsleft = secsleft - minutes * ONE_MINUTE write ( scratch , '(i0,\"-\",i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) days , hours , minutes , secsleft , left dhms = trim ( scratch ) end function millisec2days subroutine get_cmd ( command , status ) ! @(#) compose a command from all the arguments passed to the program character ( len =* ), parameter :: gen = '(*(g0))' character ( len = :), allocatable , intent ( out ) :: command ! string of all arguments to create integer , intent ( out ) :: status ! status (non-zero means error) integer :: i , j character ( len = :), allocatable :: value , valueb ! hold individual arguments one at a time character ( len = 255 ) :: errmsg integer :: length ! length of individual arguments command = \"\" ! initialize returned output string errmsg = \"\" status = 0 ERRORS : BLOCK do i = 1 , command_argument_count () !call get_command_argument(i,length=length,status=status,errmsg=errmsg)   ! get length of next argument call get_command_argument ( i , length = length , status = status ) ! get length of next argument if ( status . ne . 0 ) exit ERRORS value = repeat ( ' ' , length ) !call get_command_argument(i,value=value,status=status,errmsg=errmsg)     ! get next argument call get_command_argument ( i , value = value , status = status ) ! get next argument if ( status /= 0 ) exit ERRORS if ( length . gt . 0 ) then ! SIMPLISTIC GUESS AT RE-QUOTING STRING ! assuming an operating system shell that strips the quotes from quoted strings on the command line. ! if argument contains a space and does not contain a double-quote ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. if ( index ( value , ' ' ). ne . 0. and . index ( value , '\"' ). eq . 0 ) then value = '\"' // value // '\"' elseif ( index ( value , '\"' ). ne . 0 ) then ! assume you double doublequotes to escape them and short enough that reallocating a lot not an issue valueb = '' do j = 1 , len ( value ) if ( value ( j : j ) == '\"' ) valueb = valueb // '\"' valueb = valueb // value ( j : j ) enddo value = '\"' // valueb // '\"' endif command = command // ' ' // value ! append strings together else command = command // '\"\"' endif enddo return endblock ERRORS write ( stderr , gen ) '*get_cmd* error obtaining argument ' , i , 'errmsg=' , trim ( errmsg ) stop end subroutine get_cmd function millijulian () ! @(#)millijulian(3f): Converts proleptic Gregorian DAT date-time array to Julian Date in milliseconds in Zulu timezone integer :: dat ( 8 ) integer ( kind = int64 ) :: a , y , m , jdn , utc , millijulian call date_and_time ( values = dat ) associate & &( year => dat ( 1 ), month => dat ( 2 ), day => dat ( 3 ), hour => dat ( 5 ), minute => dat ( 6 ), second => dat ( 7 ), milli => dat ( 8 )) !  You must first compute the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) a = ( 14_int64 - month ) / 12_int64 ! A will be 1 for January or February, and 0 for other months, with integer truncation y = year + 4800_int64 - a m = month + 12_int64 * a - 3_int64 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero ! intentionally computing with integer truncation jdn = day + ( 153_int64 * m + 2_int64 ) / 5_int64 + 365_int64 * y + y / 4_int64 - y / 100_int64 + y / 400_int64 - 32045_int64 !  Finding the Julian time in milliseconds given the JDN (Julian day number) and time of day millijulian = ( jdn * 86400_int64 + hour * 3600_int64 + minute * 60_int64 + second ) * 1000_int64 + milli end associate utc = dat ( 4 ) * 60 * 1000 ! Time difference with UTC in minutes converted to milliseconds millijulian = millijulian + utc ! set all values to Zulu time end function millijulian subroutine setup () help_text = [ CHARACTER ( LEN = 128 ) :: & 'help_text=[ CHARACTER(LEN=128) :: &' ,& '                                   ' ,& 'NAME                               ' ,& '  howlong(1) - display wallclock time taken to execute a system command' ,& '                                                                       ' ,& 'SYNOPIS                                                                ' ,& '                                                                       ' ,& '  howlong SYSTEM_COMMAND                                               ' ,& '                                                                       ' ,& '   or                                                                  ' ,& '                                                                       ' ,& '  howlong --help|--version                                             ' ,& '                                                                       ' ,& 'DESCRIPTION                                                            ' ,& '                                                                       ' ,& 'Perhaps the simplest performance metric is to just measure the         ' ,& 'wallclock time taken by a program. This could literally be measured    ' ,& 'using a conventional clock or stopwatch. This is difficult to automate!' ,& 'So typically a command like the GNU/Linux or Unix command time(1) is used.' ,& '                                                                          ' ,& 'Commands such as time(1)                                                  ' ,& 'often provide more than wallclock times too. But lets construct a wallclock' ,& 'timing tool of our own using standard Fortran (not even the ISO_C_Binding  ' ,& 'interface will be called upon) that will measure the run time of a command.' ,& '                                                                           ' ,& 'Once passed a command to time on the command line, it will then run        ' ,& 'the command and report the wallclock time use by the program, and echo     ' ,& 'the command.                                                               ' ,& '                                                                           ' ,& 'Next we provide a simple program that calls the routine(s) of interest     ' ,& 'enough times to get useful timing information and time it.                 ' ,& '                                                                           ' ,& 'So lets say we compiled up the test program using two different sets of    ' ,& 'compiler options:                                                          ' ,& '                                                                           ' ,& '    f90 little_test.f90 -O0 -o little_test0                                ' ,& '    f90 little_test.f90 -O3 -o little_test3                                ' ,& '                                                                           ' ,& 'Now to run the programs via our timing utility only takes a few commands:  ' ,& '                                                                           ' ,& '    howlong ./little_test0                                                 ' ,& '    Wallclock: 0-00:00:25.461 :command: ./little_test0                     ' ,& '    howlong ./little_test3                                                 ' ,& '    Wallclock: 0-00:00:10.274 :command: ./little_test3                     ' ,& '                                                                           ' ,& 'SAMPLE SUBJECT PROGRAM                                                     ' ,& '                                                                           ' ,& 'An uninstrumented test program for timing :                                ' ,& '                                                                           ' ,& '   program little_test                                                     ' ,& '   use,intrinsic :: iso_fortran_env, only : int8                           ' ,& '   implicit none                                                           ' ,& '   character(len=*),parameter             :: original = \"abcdxyz ZXYDCBA _!@\"' ,& '   integer,parameter                      :: how_many_times = 100000000      ' ,& '   character(len=:),volatile,allocatable  :: t                               ' ,& '   integer                                :: i                               ' ,& '      do i=1,how_many_times                                                  ' ,& '        t=upper(original)                                                    ' ,& '        t=lower(original)                                                    ' ,& '      enddo                                                                  ' ,& '   contains                                                                  ' ,& '   function upper(str) result(translated)                                    ' ,& '   integer(kind=int8), parameter :: &                                        ' ,& '   & ascii_diff = abs(iachar(''A'',kind=int8) - iachar(''a'',kind=int8))     ' ,& '   character(*), intent(in) :: str                                           ' ,& '   integer :: i                                                              ' ,& '   character(len=len(str)) :: translated                                     ' ,& '                                                                             ' ,& '      translated=str                                                         ' ,& '      do i = 1, len(str)                                                     ' ,& '        select case(str(i:i))                                                ' ,& '          case(\"a\":\"z\")                                                      ' ,& '            translated(i:i) = achar(iachar(str(i:i))-ascii_diff)             ' ,& '        end select                                                           ' ,& '      enddo                                                                  ' ,& '   end function upper                                                        ' ,& '                                                                             ' ,& '   function lower(str) result(translated)                                    ' ,& '   integer(kind=int8), parameter :: &                                        ' ,& '   & ascii_diff = abs(iachar(''A'',kind=int8) - iachar(''a'',kind=int8))     ' ,& '   character(*), intent(in) :: str                                           ' ,& '   integer :: i                                                              ' ,& '   character(len=len(str)) :: translated                                     ' ,& '                                                                             ' ,& '      translated=str                                                         ' ,& '      do i = 1, len(str)                                                     ' ,& '        select case(str(i:i))                                                ' ,& '          case(\"A\":\"Z\")                                                      ' ,& '            translated(i:i) = achar(iachar(str(i:i))+ascii_diff)             ' ,& '        end select                                                           ' ,& '      enddo                                                                  ' ,& '   end function lower                                                        ' ,& '                                                                             ' ,& '   end program little_test                                                   ' ,& '                                                                             ' ,& 'FOOTNOTES                                                                    ' ,& '                                                                             ' ,& 'Note that in many HPC environments programs are often run via a job          ' ,& 'scheduler like Slurm, LSF, PBS, Torque, ... . In these environments          ' ,& 'there are usually account records of each job that provide resource          ' ,& 'usage statistics.                                                            ' ,& '                                                                             ' ,& 'OPTIONS                                                                      ' ,& '   --help      display this help and exit                                    ' ,& '   --version   output version information and exit                           ' ,& '                                                                             ' ,& 'EXAMPLES                                                                     ' ,& '    howlong ./myprogram                                                      ' ,& '                                                                             ' ,& 'SEE ALSO                                                                     ' ,& '    gprof(1), gcov(1)                                                        ' ,& '' ] version_text = [ CHARACTER ( LEN = 128 ) :: & 'version_text=[ CHARACTER(LEN=128) :: &' ,& '@(#)PRODUCT:         GPF (General Purpose Fortran) utilities and examples' ,& '@(#)PROGRAM:         howlong(1)                                          ' ,& '@(#)DESCRIPTION:     run a system command and return wallclock time it took to execute' ,& '@(#)VERSION:         1.0.0, 2024-09-28                                                ' ,& '@(#)AUTHOR:          John S. Urban                                                    ' ,& '@(#)HOME PAGE:       https://github.com/urbanjost?tab=repositories                    ' ,& '@(#)LICENSE:         MIT License                                                      ' ,& '' ] end subroutine setup end program howlong_exe","tags":"","url":"sourcefile/howlong.f90.html"},{"title":"month.f90 – M_time","text":"Source Code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== program month_exe use M_kracken95 , only : kracken , iget , lget , sget ! command line parsing use M_time , only : box_month , mo2v , locale ! date and time implicit none character ( len =* ), parameter :: ident = \"@(#)month(1f):print calendar\" character ( len = 21 ) :: calen ( 8 ) = '                    ' ! character array to hold month character ( len = ( 21 + 2 ) * 3 ) :: calenyear ( 8 * 4 ) = '                      ' ! character array to hold year integer :: month ! values of command line options integer :: dat_values ( 8 ) ! date array integer :: r , c ! row and column for month in one-year calendar character ( len = 21 ) :: cscr call date_and_time ( values = dat_values ) ! get current time and date call kracken ( 'month' , ' -year -month 0 -help .f. -version .f.' ) ! crack command line arguments call help_usage ( lget ( 'month_help' )) ! print help information and stop if requested call help_version ( lget ( 'month_version' )) ! print version information and stop if requested call locale ( 'LANGUAGE' ) !----------------------------------------------------------------------------------------------------------------------------------- ! use user-specified year date instead of current year. Try reading year from two places (-oo and -year) on command line if ( sget ( 'month_year' ) /= ' ' ) then ! check -year option for a year value dat_values ( 1 ) = iget ( 'month_year' ) ! if value was specified use it elseif ( sget ( 'month_oo' ) /= ' ' ) then dat_values ( 1 ) = iget ( 'month_oo' ) ! check -oo option for a year value if did not find -year VALUE endif !write(*,*)'YEAR=',dat_values(1) !----------------------------------------------------------------------------------------------------------------------------------- cscr = sget ( 'month_month' ) ! get month as string so can see if name or number or blank if ( cscr /= '' ) then select case ( cscr ( 1 : 1 )) case ( 'A' : 'Z' , 'a' : 'z' ) ! assume month name instead of month number month = mo2v ( trim ( cscr )) case default ! month is number month = iget ( 'month_month' ) end select else ! keyword given but no value, default to current month month = dat_values ( 2 ) endif !----------------------------------------------------------------------------------------------------------------------------------- if ( month == 0 ) then ! no month specified, display an entire year do r = 1 , 4 ! display year in four rows do c = 1 , 3 ! three months per row dat_values ( 2 ) = c + ( r - 1 ) * 3 call box_month ( dat_values , calen ) calenyear ( 8 * r - 7 : 8 * r )( 23 * c - 22 : 23 * c ) = calen ! copy month into large year array enddo enddo write ( * , '(a)' ) calenyear else ! do a month dat_values ( 2 ) = month call box_month ( dat_values , calen ) write ( * , '(a)' ) calen endif !----------------------------------------------------------------------------------------------------------------------------------- contains !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- subroutine help_usage ( l_help ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_usage(3f): prints help information\" logical , intent ( in ) :: l_help character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_help ) then help_text = [ CHARACTER ( LEN = 128 ) :: & 'NAME                                                                            ' ,& '   month(1f) - [TIME] display a calendar                                        ' ,& '   (LICENSE:PD)                                                                 ' ,& '                                                                                ' ,& 'SYNOPSIS                                                                        ' ,& '   month [[ -year] NNNN] [ -month NN|month_name]                                ' ,& '                                                                                ' ,& 'DESCRIPTION                                                                     ' ,& '   month(1) displays a simple calendar. If no arguments are specified,          ' ,& '   the current year is displayed.                                               ' ,& '                                                                                ' ,& 'OPTIONS                                                                         ' ,& '   -month NN   Display single month output. The month is numeric (1-12)         ' ,& '               or a month name or blank. If blank the current month is assumed. ' ,& '                                                                                ' ,& '   -year NNNN  Select the year to display. A year starts on Jan 1st.            ' ,& '                                                                                ' ,& '   -help       Display help text and exit.                                      ' ,& '   -version    Display version information and exit.                            ' ,& '                                                                                ' ,& 'EXAMPLES                                                                        ' ,& '      month -month 12                                                           ' ,& '                                                                                ' ,& '       >    December 2015                                                       ' ,& '       >Mo Tu We Th Fr Sa Su                                                    ' ,& '       >    1  2  3  4  5  6                                                    ' ,& '       > 7  8  9 10 11 12 13                                                    ' ,& '       >14 15 16 17 18 19 20                                                    ' ,& '       >21 22 23 24 25 26 27                                                    ' ,& '       >28 29 30 31                                                             ' ,& '                                                                                ' ,& '      month -month April # month names may be given instead of numbers          ' ,& 'AUTHOR                                                                          ' ,& '   John S. Urban                                                                ' ,& 'LICENSE                                                                         ' ,& '   Public Domain                                                                ' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )), i = 1 , size ( help_text )) stop ! if --help was specified, stop endif end subroutine help_usage !> !!##NAME !!    month(1f) - [TIME] display a calendar !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    month [[ -year] NNNN] [ -month NN|month_name] !! !!##DESCRIPTION !!    month(1) displays a simple calendar. If no arguments are specified, !!    the current year is displayed. !! !!##OPTIONS !!    -month NN   Display single month output. The month is numeric (1-12) !!                or a month name or blank. If blank the current month is assumed. !! !!    -year NNNN  Select the year to display. A year starts on Jan 1st. !! !!    -help       Display help text and exit. !!    -version    Display version information and exit. !! !!##EXAMPLES !! !!       month -month 12 !! !!        >    December 2015 !!        >Mo Tu We Th Fr Sa Su !!        >    1  2  3  4  5  6 !!        > 7  8  9 10 11 12 13 !!        >14 15 16 17 18 19 20 !!        >21 22 23 24 25 26 27 !!        >28 29 30 31 !! !!       month -month April # month names may be given instead of numbers !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine help_version ( l_version ) implicit none character ( len =* ), parameter :: ident = \"@(#)help_version(3f): prints version information\" logical , intent ( in ) :: l_version character ( len = :), allocatable :: help_text (:) integer :: i logical :: stopit = . false . stopit = . false . if ( l_version ) then help_text = [ CHARACTER ( LEN = 128 ) :: & '@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>' ,& '@(#)PROGRAM:        month(1f)>' ,& '@(#)DESCRIPTION:    displays simple calendar>' ,& '@(#)VERSION:        1.0, 2015-12-20>' ,& '@(#)AUTHOR:         John S. Urban>' ,& '@(#)REPORTING BUGS: http://www.urbanjost.altervista.org/>' ,& '@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>' ,& '@(#)LICENSE:        Public Domain. This is free software: you are free to change and redistribute it.>' ,& '@(#)                There is NO WARRANTY, to the extent permitted by law.>' ,& '@(#)COMPILED:       2025-03-28 13:27:15 UTC-240>' ,& '' ] WRITE ( * , '(a)' )( trim ( help_text ( i )( 5 : len_trim ( help_text ( i )) - 1 )), i = 1 , size ( help_text )) stop ! if --version was specified, stop endif end subroutine help_version !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- end program month_exe","tags":"","url":"sourcefile/month.f90.html"},{"title":"demo_date_to_unix.f90 – M_time","text":"Source Code program demo_date_to_unix use M_time , only : date_to_unix , realtime implicit none integer :: dat ( 8 ) real ( kind = realtime ) :: unixtime integer :: ierr call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat call date_to_unix ( dat , unixtime , ierr ) write ( * , * ) 'Unix Epoch time is ' , unixtime write ( * , * ) 'ierr is ' , ierr end program demo_date_to_unix","tags":"","url":"sourcefile/demo_date_to_unix.f90.html"},{"title":"demo_easter.f90 – M_time","text":"Source Code program demo_easter use M_time , only : easter , fmtdate implicit none integer :: year integer :: dat ( 8 ) ! year,month,day,tz,hour,minute,second,millisecond call date_and_time ( values = dat ) ! get current year year = dat ( 1 ) call easter ( year , dat ) write ( * , * ) fmtdate ( dat ,& \"Easter day: the %d day of %L in the year of our Lord %Y\" ) end program demo_easter","tags":"","url":"sourcefile/demo_easter.f90.html"},{"title":"M_time__duplicate.f90 – M_time","text":"Source Code module M_time__duplicate use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT ! copy of other GPF routines used here implicit none !(type,external) private public lower public substitute public upper public adjustc public compact public s2v public split public string_to_values public string_to_value public transliterate public v2s interface v2s module procedure d2s , r2s , i2s , l2s end interface interface string_to_value module procedure a2d , a2r , a2i end interface character ( len =* ), parameter :: gen = '(*(g0))' contains !> !!##NAME !!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes one substring for another in string !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine substitute(targetline,old,new,ierr,start,end) !! !!     character(len=*)              :: targetline !!     character(len=*),intent(in)   :: old !!     character(len=*),intent(in)   :: new !!     integer,intent(out),optional  :: ierr !!     integer,intent(in),optional   :: start !!     integer,intent(in),optional   :: end !!##DESCRIPTION !!   Globally substitute one substring for another in string. !! !!##OPTIONS !!     TARGETLINE  input line to be changed. Must be long enough to !!                 hold altered output. !!     OLD         substring to find and replace !!     NEW         replacement for OLD substring !!     IERR        error code. If IER = -1 bad directive, >= 0 then !!                 count of changes made. !!     START       sets the left margin to be scanned for OLD in !!                 TARGETLINE. !!     END         sets the right margin to be scanned for OLD in !!                 TARGETLINE. !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_substitute !!     use M_time, only : substitute !!     implicit none !!     ! must be long enough to hold changed line !!     character(len=80) :: targetline !! !!     targetline='this is the input string' !!     write(*,*)'ORIGINAL    : '//trim(targetline) !! !!     ! changes the input to 'THis is THe input string' !!     call substitute(targetline,'th','TH') !!     write(*,*)'th => TH    : '//trim(targetline) !! !!     ! a null old substring means \"at beginning of line\" !!     ! changes the input to 'BEFORE:this is the input string' !!     call substitute(targetline,'','BEFORE:') !!     write(*,*)'\"\" => BEFORE: '//trim(targetline) !! !!     ! a null new string deletes occurrences of the old substring !!     ! changes the input to 'ths s the nput strng' !!     call substitute(targetline,'i','') !!     write(*,*)'i => \"\"     : '//trim(targetline) !! !!     end program demo_substitute !! !!    Expected output !! !!     ORIGINAL    : this is the input string !!     th => TH    : THis is THe input string !!     \"\" => BEFORE: BEFORE:THis is THe input string !!     i => \"\"     : BEFORE:THs s THe nput strng !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine substitute ( targetline , old , new , ierr , start , end ) !character(len=*),parameter::ident_11=\"@(#)M_strings::substitute(3f): Globally substitute one substring for another in string\" !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ) :: targetline ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( out ), optional :: ierr ! error code. if ierr = -1 bad directive, >=0 then ierr changes made integer , intent ( in ), optional :: start ! start sets the left margin integer , intent ( in ), optional :: end ! end sets the right margin !----------------------------------------------------------------------------------------------------------------------------------- character ( len = len ( targetline )) :: dum1 ! scratch string buffers integer :: ml , mr , ier1 integer :: maxlengthout ! MAXIMUM LENGTH ALLOWED FOR NEW STRING integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: ir integer :: ind integer :: il integer :: id integer :: ic integer :: ichar !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( start )) then ! optional starting column ml = start else ml = 1 endif if ( present ( end )) then ! optional ending column mr = end else mr = len ( targetline ) endif !----------------------------------------------------------------------------------------------------------------------------------- ier1 = 0 ! initialize error flag/change count maxlengthout = len ( targetline ) ! max length of output string original_input_length = len_trim ( targetline ) ! get non-blank length of input line dum1 (:) = ' ' ! initialize string to build output in id = mr - ml ! check for window option !x! change to optional parameter(s) !----------------------------------------------------------------------------------------------------------------------------------- len_old = len ( old ) ! length of old substring to be replaced len_new = len ( new ) ! length of new substring to replace old substring if ( id <= 0 ) then ! no window so change entire input string il = 1 ! il is left margin of window to change ir = maxlengthout ! ir is right margin of window to change dum1 (:) = ' ' ! begin with a blank line else ! if window is set il = ml ! use left margin ir = min0 ( mr , maxlengthout ) ! use right margin or rightmost dum1 = targetline (: il - 1 ) ! begin with what's below margin endif ! end of window settings !----------------------------------------------------------------------------------------------------------------------------------- if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichar = len_new + original_input_length if ( ichar > maxlengthout ) then write ( stderr , gen ) '<ERROR>*substitute* - new line will be too long' ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( len_new > 0 ) then dum1 ( il :) = new (: len_new ) // targetline ( il : original_input_length ) else dum1 ( il :) = targetline ( il : original_input_length ) endif targetline ( 1 : maxlengthout ) = dum1 (: maxlengthout ) ier1 = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( ierr )) ierr = ier1 return endif !----------------------------------------------------------------------------------------------------------------------------------- ichar = il ! place to put characters into output string ic = il ! place looking at in input string loop : do ind = index ( targetline ( ic :), old (: len_old )) + ic - 1 ! try to find start of old string in remaining part of input in change window if ( ind == ic - 1. or . ind > ir ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif ier1 = ier1 + 1 ! found an old string to change, so increment count of changes if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output if ( ichar - 1 + ladd > maxlengthout ) then ier1 =- 1 exit loop endif dum1 ( ichar :) = targetline ( ic : ind - 1 ) ichar = ichar + ladd endif if ( ichar - 1 + len_new > maxlengthout ) then ier1 =- 2 exit loop endif if ( len_new /= 0 ) then dum1 ( ichar :) = new (: len_new ) ichar = ichar + len_new endif ic = ind + len_old enddo loop !----------------------------------------------------------------------------------------------------------------------------------- select case ( ier1 ) case (: - 1 ) write ( stderr , gen ) '<ERROR>*substitute* - new line will be too long' case ( 0 ) ! there were no changes made to the window case default ladd = original_input_length - ic if ( ichar + ladd > maxlengthout ) then write ( stderr , gen ) '<ERROR>*substitute* - new line will be too long' ier1 =- 1 if ( present ( ierr )) ierr = ier1 return endif if ( ic < len ( targetline )) then dum1 ( ichar :) = targetline ( ic : max ( ic , original_input_length )) endif targetline = dum1 (: maxlengthout ) end select if ( present ( ierr )) ierr = ier1 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine substitute !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! upper(3f) - [M_strings:CASE] changes a string to uppercase !! (LICENSE:PD) !! !!##SYNOPSIS !! !!    elemental pure function upper(str,begin,end) result (string) !! !!     character(*), intent(in)    :: str !!     integer,optional,intent(in) :: begin,end !!     character(len(str))         :: string  ! output string !!##DESCRIPTION !!   upper(string) returns a copy of the input string with all characters !!   converted in the optionally specified range to uppercase, assuming !!   ASCII character sets are being used. If no range is specified the !!   entire string is converted to uppercase. !! !!##OPTIONS !!    str    string to convert to uppercase !!    begin  optional starting position in \"str\" to begin converting to uppercase !!    end    optional ending position in \"str\" to stop converting to uppercase !! !!##RESULTS !!    upper  copy of the input string with all characters converted to uppercase !!            over optionally specified range. !! !!##TRIVIA !!   The terms \"uppercase\" and \"lowercase\" date back to the early days of !!   the mechanical printing press. Individual metal alloy casts of each !!   needed letter, or punctuation symbol, were meticulously added to a !!   press block, by hand, before rolling out copies of a page. These !!   metal casts were stored and organized in wooden cases. The more !!   often needed miniscule letters were placed closer to hand, in the !!   lower cases of the work bench. The less often needed, capitalized, !!   majuscule letters, ended up in the harder to reach upper cases. !! !!##EXAMPLES !! !!    Sample program: !! !!     program demo_upper !!     use M_time, only: upper !!     implicit none !!     character(len=:),allocatable  :: s !!        s=' ABCDEFG abcdefg ' !!        write(*,*) 'mixed-case input string is ....',s !!        write(*,*) 'upper-case output string is ...',upper(s) !!        write(*,*) 'make first character uppercase  ... ',upper('this is a sentence.',1,1) !!        write(*,'(1x,a,*(a:,\"+\"))') 'upper(3f) is elemental ==>',upper([\"abc\",\"def\",\"ghi\"]) !!     end program demo_upper !! !!    Expected output !! !!     mixed-case input string is .... ABCDEFG abcdefg !!     upper-case output string is ... ABCDEFG ABCDEFG !!     make first character uppercase  ... This is a sentence. !!     upper(3f) is elemental ==>ABC+DEF+GHI !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !=================================================================================================================================== elemental pure function upper ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_21=\"@(#)M_strings::upper(3f): Changes a string to uppercase\" character ( * ), intent ( In ) :: str ! inpout string to convert to all uppercase integer , intent ( in ), optional :: begin , end character ( len ( str )) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: ibegin , iend string = str ! initialize output string to input string ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'a' : 'z' ) ! located miniscule letter string ( i : i ) = achar ( iachar ( str ( i : i )) - 32 ) ! change miniscule letter to uppercase end select end do end function upper !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    lower(3f) - [M_strings:CASE] changes a string to lowercase over specified range !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    elemental pure function lower(str,begin,end) result (string) !! !!     character(*), intent(in) :: str !!     integer,optional         :: begin, end !!     character(len(str))      :: string  ! output string !!##DESCRIPTION !!   lower(string) returns a copy of the input string with all characters !!   converted to miniscule over the specified range, assuming ASCII !!   character sets are being used. If no range is specified the entire !!   string is converted to miniscule. !! !!##OPTIONS !!    str    string to convert to miniscule !!    begin  optional starting position in \"str\" to begin converting to miniscule !!    end    optional ending position in \"str\" to stop converting to miniscule !! !!##RESULTS !!    lower  copy of the input string with all characters converted to miniscule !!           over optionally specified range. !! !!##TRIVIA !!    The terms \"uppercase\" and \"lowercase\" date back to the early days of !!    the mechanical printing press. Individual metal alloy casts of each !!    needed letter, or punctuation symbol, were meticulously added to a !!    press block, by hand, before rolling out copies of a page. These !!    metal casts were stored and organized in wooden cases. The more !!    often needed miniscule letters were placed closer to hand, in the !!    lower cases of the work bench. The less often needed, capitalized, !!    majuscule letters, ended up in the harder to reach upper cases. !! !!##EXAMPLES !! !!    Sample program: !! !!     program demo_lower !!     use M_time, only: lower !!     implicit none !!     character(len=:),allocatable  :: s !!        s=' ABCDEFG abcdefg ' !!        write(*,*) 'mixed-case input string is ....',s !!        write(*,*) 'lower-case output string is ...',lower(s) !!     end program demo_lower !! !!    Expected output !! !!       mixed-case input string is .... ABCDEFG abcdefg !!       lower-case output string is ... abcdefg abcdefg !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== elemental pure function lower ( str , begin , end ) result ( string ) !character(len=*),parameter::ident_22=\"@(#)M_strings::lower(3f): Changes a string to lowercase over specified range\" character ( * ), intent ( In ) :: str character ( len ( str )) :: string integer , intent ( in ), optional :: begin , end integer :: i integer :: ibegin , iend string = str ibegin = 1 if ( present ( begin )) then ibegin = max ( ibegin , begin ) endif iend = len_trim ( str ) if ( present ( end )) then iend = min ( iend , end ) endif do i = ibegin , iend ! step thru each letter in the string in specified range select case ( str ( i : i )) case ( 'A' : 'Z' ) string ( i : i ) = achar ( iachar ( str ( i : i )) + 32 ) ! change letter to miniscule case default end select end do end function lower !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!       adjustc(3f) - [M_strings:WHITESPACE] center text !!       (LICENSE:PD) !! !!##SYNOPSIS !! !!   pure function adjustc(string[,length]) !! !!    character(len=*),intent(in)  :: string !!    integer,intent(in),optional  :: length !!    character(len=:),allocatable :: adjustc !!##DESCRIPTION !!   Centers input text in a string of the length specified. Returns a !!   string of length LENGTH if LENGTH is present. Otherwise returns a !!   string of the length of the input string. !!##OPTIONS !!     string  input string to trim and center !!     length  line length to center text in, optional. !!##RETURNS !!     adjustc  centered output string !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_adjustc !!     use M_strings, only : adjustc !!     !  using length of the input string !!        write(*,'(a)')       '================================' !!        write(*,'(a)')adjustc('centered string                 ') !!        write(*,'(a)')adjustc('                 centered string') !!        write(*,'(a)')adjustc('  centered string               ') !!     !  using explicit output string length !!        write(*,'(a)')repeat('=',50) !!        write(*,'(a)')adjustc('this is a centered string',50) !!        write(*,'(a)')repeat('=',50) !!     end program demo_adjustc !! !!    Expected output: !! !!     \\================================ !!             centered string !!             centered string !!             centered string !!     \\================================================== !!                 this is a centered string !!     \\================================================== !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== pure function adjustc ( string , length ) !character(len=*),parameter::ident_32=\"@(#)M_strings::adjustc(3f): center text\" !> !! PROCEDURE   adjustc(3f) !! DESCRIPTION center text using implicit or explicit length !!##VERSION     2.0, 20160711 !! AUTHOR      John S. Urban !=================================================================================================================================== !----------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: string ! input string to trim and center integer , intent ( in ), optional :: length ! line length to center text in character ( len = :), allocatable :: adjustc ! output string integer :: inlen integer :: ileft ! left edge of string if it is centered !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( length )) then ! optional length inlen = length ! length will be requested length if ( inlen <= 0 ) then ! bad input length inlen = len ( string ) ! could not use input value, fall back to length of input string endif else ! output length was not explicitly specified, use input string length inlen = len ( string ) endif allocate ( character ( len = inlen ) :: adjustc ) ! create output at requested length adjustc ( 1 : inlen ) = ' ' ! initialize output string to all blanks !----------------------------------------------------------------------------------------------------------------------------------- ileft = ( inlen - len_trim ( adjustl ( string ))) / 2 ! find starting point to start input string to center it if ( ileft > 0 ) then ! if string will fit centered in output adjustc ( ileft + 1 : inlen ) = adjustl ( string ) ! center the input text in the output string else ! input string will not fit centered in output string adjustc ( 1 : inlen ) = adjustl ( string ) ! copy as much of input to output as can endif end function adjustc !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing) !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function compact(STR,CHAR) result (OUTSTR) !! !!     character(len=*),intent(in)          :: STR !!     character(len=*),intent(in),optional :: CHAR !!     character(len=len(str))              :: OUTSTR !!##DESCRIPTION !!   COMPACT(3f) converts multiple spaces, tabs and control characters !!   (called \"whitespace\") to a single character or nothing. Leading !!   whitespace is removed. !! !!##OPTIONS !!    STR     input string to reduce or remove whitespace from !!    CHAR    By default the character that replaces adjacent !!            whitespace is a space. If the optional CHAR parameter is supplied !!            it will be used to replace the whitespace. If a null character is !!            supplied for CHAR whitespace is removed. !!##RETURNS !!    OUTSTR  string of same length as input string but with all contiguous whitespace !!            reduced to a single space and leading whitespace removed !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_compact !!     use M_strings, only : compact !!     implicit none !!     ! produces 'This is a test               ' !!     write(*,*)compact('  This     is      a     test  ') !!     ! produces 'Thisisatest                  ' !!     write(*,*)compact('  This     is      a     test  ',char='') !!     ! produces 'This:is:a:test               ' !!     write(*,*)compact('  This     is      a     test  ',char=':') !!     ! note CHAR is used to replace the whitespace, but if CHAR is !!     ! in the original string it is just copied !!     write(*,*)compact('A  AA    A   AAAAA',char='A') !!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA' !!     ! not 'A' !!     end program demo_compact !! !!    Expected output !! !!     >This is a test !!     >Thisisatest !!     >This:is:a:test !!     >AAAAAAAAAAAA !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !elemental pure function compact(str,char) result (outstr) function compact ( str , char ) result ( outstr ) !character(len=*),parameter::ident_38=\"@(#)M_strings::compact(3f): Converts white-space to single spaces\" character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( in ), optional :: char character ( len = len ( str )) :: outstr character ( len = 1 ) :: ch integer :: i integer :: position_in_output logical :: last_was_space character ( len = 1 ) :: char_p logical :: nospace if ( present ( char )) then char_p = char if ( len ( char ) == 0 ) then nospace = . true . else nospace = . false . endif else char_p = ' ' nospace = . false . endif outstr = ' ' last_was_space = . false . position_in_output = 0 IFSPACE : do i = 1 , len_trim ( str ) ch = str ( i : i ) select case ( ichar ( ch )) case ( 0 : 32 , 127 ) ! space or tab character or control character if ( position_in_output == 0 ) then ! still at beginning so ignore leading whitespace cycle IFSPACE elseif (. not . last_was_space ) then ! if have not already put out a space output one if (. not . nospace ) then position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = char_p endif endif last_was_space = . true . case (: - 1 , 33 : 126 , 128 :) ! not a space, quote, or control character so copy it position_in_output = position_in_output + 1 outstr ( position_in_output : position_in_output ) = ch last_was_space = . false . end select end do IFSPACE end function compact !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      s2v(3f) - [M_strings:NUMERIC] function returns doubleprecision numeric value from a string !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    function s2v(string[,ierr][,onerr]) !! !!     character(len=*)             :: string !!     doubleprecision              :: s2v !!     integer,intent(out),optional :: ierr !!     class(*),intent(in),optional :: onerr !!##DESCRIPTION !!   This function converts a string to a DOUBLEPRECISION numeric value. !! !!   The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended to take !!   CHARACTER variables. The KIND= keyword is not supported on the extensions. !!##OPTIONS !! !!     string   holds string assumed to represent a numeric value !!     ierr     If an error occurs the program is stopped if the optional !!              parameter IERR is not present. If IERR returns a non-zero !!              value an error occurred. !!     onerr    The value to return on error. A value of zero (NaN) is !!              returned on error by default. !!##RETURNS !!     s2v !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_s2v !! !!     use M_strings, only: s2v, int, real, dble !!     implicit none !!     character(len=8)              :: s=' 10.345 ' !!     integer                       :: i !!     character(len=14),allocatable :: strings(:) !!     doubleprecision               :: dv !!     integer                       :: errnum !! !!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION !!     strings=[& !!     &' 10.345       ',& !!     &'+10           ',& !!     &'    -3        ',& !!     &'    -4.94e-2  ',& !!     &'0.1           ',& !!     &'12345.678910d0',& !!     &'              ',& ! Note: will return zero without an error message !!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored !!     &'WHAT?         ']  ! Note: error messages will appear, zero returned !! !!     ! a numeric value is returned, so it can be used in numeric expression !!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0 !!     write(*,*) !!     write(*,*)' STRING            VALUE                    ERROR_NUMBER' !!     do i=1,size(strings) !!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement, !!        ! as it does I/O when errors occur, so called on a separate line !!        dv=s2v(strings(i),errnum) !!        write(*,*) strings(i)//'=',dv,errnum !!     enddo !!     write(*,*)\"Extended intrinsics\" !!     write(*,*)'given inputs:',s,strings(:8) !!     write(*,*)'INT(3f):',int(s),int(strings(:8)) !!     write(*,*)'REAL(3f):',real(s),real(strings(:8)) !!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8)) !!     write(*,*)\"That's all folks!\" !! !!     end program demo_s2v !! !!    Expected output !! !!     >1/2 value of string is    5.1725000000000003 !!     > !!     > STRING            VALUE                    ERROR_NUMBER !!     > 10.345       =   10.345000000000001                0 !!     >+10           =   10.000000000000000                0 !!     >    -3        =  -3.0000000000000000                0 !!     >    -4.94e-2  =  -4.9399999999999999E-002           0 !!     >0.1           =  0.10000000000000001                0 !!     >12345.678910d0=   12345.678910000001                0 !!     >              =   0.0000000000000000                0 !!     >1 2 1 2 1 . 0 =   12121.000000000000                0 !!     >*a2d* - cannot produce number from string [WHAT?] !!     >*a2d* - [Bad value during floating point read] !!     >WHAT?         =   0.0000000000000000             5010 !!     >Extended intrinsics !!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1 12345.678910d0 1 2 1 2 1 . 0 !!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121 !!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000 -4.94000018E-02 !!     >          0.100000001 12345.6787 0.00000000 12121.0000 !!     >DBLE(3f): 10.345000000000001 10.345000000000001 10.000000000000000 !!     >          -3.0000000000000000 -4.9399999999999999E-002 0.10000000000000001 !!     >          12345.678910000001 0.0000000000000000 12121.000000000000 !!     >That's all folks! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !> !!##PROCEDURE: !! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs !!##VERSION:     2.0, 20160704 !! AUTHOR:      John S. Urban !=================================================================================================================================== doubleprecision function s2v ( chars , ierr , onerr ) !  1989 John S. Urban !character(len=*),parameter::ident_43=\"@(#)M_strings::s2v(3f): returns doubleprecision number from string\" character ( len =* ), intent ( in ) :: chars integer , optional :: ierr doubleprecision :: valu integer :: ierr_local class ( * ), intent ( in ), optional :: onerr ierr_local = 0 if ( present ( onerr )) then call a2d ( chars , valu , ierr_local , onerr ) else call a2d ( chars , valu , ierr_local ) endif if ( present ( ierr )) then ! if error is not returned stop program on error ierr = ierr_local s2v = valu elseif ( ierr_local /= 0 ) then write ( stderr , * ) '<ERROR>*s2v* - stopped while reading ' // trim ( chars ) stop 1 else s2v = valu endif end function s2v !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    split(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine split(input_line,array,delimiters,order,nulls) !! !!     character(len=*),intent(in)              :: input_line !!     character(len=:),allocatable,intent(out) :: array(:) !!     character(len=*),optional,intent(in)     :: delimiters !!     character(len=*),optional,intent(in)     :: order !!     character(len=*),optional,intent(in)     :: nulls !!##DESCRIPTION !!   SPLIT(3f) parses a string using specified delimiter characters and !!   store tokens into an allocatable array !! !!##OPTIONS !! !!    INPUT_LINE  Input string to tokenize !! !!    ARRAY       Output array of tokens !! !!    DELIMITERS  List of delimiter characters. !!                The default delimiters are the \"whitespace\" characters !!                (space, tab,new line, vertical tab, formfeed, carriage !!                return, and null). You may specify an alternate set of !!                delimiter characters. !! !!                Multi-character delimiters are not supported (Each !!                character in the DELIMITERS list is considered to be !!                a delimiter). !! !!                Quoting of delimiter characters is not supported. !! !!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array. !!                By default ARRAY contains the tokens having parsed !!                the INPUT_LINE from left to right. If ORDER='RIGHT' !!                or ORDER='REVERSE' the parsing goes from right to left. !! !!    NULLS IGNORE|RETURN|IGNOREEND  Treatment of null fields. !!                By default adjacent delimiters in the input string !!                do not create an empty string in the output array. if !!                NULLS='return' adjacent delimiters create an empty element !!                in the output ARRAY. If NULLS='ignoreend' then only !!                trailing delimiters at the right of the string are ignored. !! !!##EXAMPLES !! !!  Sample program: !! !!       program demo_split !!       use M_strings, only: split !!       character(len=*),parameter     :: & !!       & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ' !!       character(len=:),allocatable :: array(:) ! output array of tokens !!          write(*,*)'INPUT LINE:['//LINE//']' !!          write(*,'(80(\"=\"))') !!          write(*,*)'typical call:' !!          CALL split(line,array) !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!          write(*,'(80(\"-\"))') !!          write(*,*)'custom list of delimiters (colon and vertical line):' !!          CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore') !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!          write(*,'(80(\"-\"))') !!          write(*,*)& !!          &'custom list of delimiters, reverse array order and count null fields:' !!          CALL split(line,array,delimiters=':|',order='reverse',nulls='return') !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!          write(*,'(80(\"-\"))') !!          write(*,*)'INPUT LINE:['//LINE//']' !!          write(*,*)& !!          &'default delimiters and reverse array order and return null fields:' !!          CALL split(line,array,delimiters='',order='reverse',nulls='return') !!          write(*,'(i0,\" ==> \",a)')(i,trim(array(i)),i=1,size(array)) !!          write(*,*)'SIZE:',SIZE(array) !!      end program demo_split !! !!   Output !! !!        > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ] !!        > =========================================================================== !!        >  typical call: !!        > 1 ==> aBcdef !!        > 2 ==> ghijklmnop !!        > 3 ==> qrstuvwxyz !!        > 4 ==> 1:|:2 !!        > 5 ==> 333|333 !!        > 6 ==> a !!        > 7 ==> B !!        > 8 ==> cc !!        >  SIZE:           8 !!        > -------------------------------------------------------------------------- !!        >  custom list of delimiters (colon and vertical line): !!        > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1 !!        > 2 ==> 2     333 !!        > 3 ==> 333 a B cc !!        >  SIZE:           3 !!        > -------------------------------------------------------------------------- !!        >  custom list of delimiters, reverse array order and return null fields: !!        > 1 ==> 333 a B cc !!        > 2 ==> 2     333 !!        > 3 ==> !!        > 4 ==> !!        > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1 !!        >  SIZE:           5 !!        > -------------------------------------------------------------------------- !!        >  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ] !!        >  default delimiters and reverse array order and count null fields: !!        > 1 ==> !!        > 2 ==> !!        > 3 ==> !!        > 4 ==> cc !!        > 5 ==> B !!        > 6 ==> a !!        > 7 ==> 333|333 !!        > 8 ==> !!        > 9 ==> !!        > 10 ==> !!        > 11 ==> !!        > 12 ==> 1:|:2 !!        > 13 ==> !!        > 14 ==> qrstuvwxyz !!        > 15 ==> ghijklmnop !!        > 16 ==> !!        > 17 ==> !!        > 18 ==> aBcdef !!        > 19 ==> !!        > 20 ==> !!        >  SIZE:          20 !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine split ( input_line , array , delimiters , order , nulls ) !----------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_7=\"& !&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array\" !  John S. Urban !----------------------------------------------------------------------------------------------------------------------------------- intrinsic index , min , present , len !----------------------------------------------------------------------------------------------------------------------------------- !  given a line of structure \" par1 par2 par3 ... parn \" store each par(n) into a separate variable in array. !    o by default adjacent delimiters in the input string do not create an empty string in the output array !    o no quoting of delimiters is supported character ( len =* ), intent ( in ) :: input_line ! input string to tokenize character ( len =* ), optional , intent ( in ) :: delimiters ! list of delimiter characters character ( len =* ), optional , intent ( in ) :: order ! order of output array sequential|[reverse|right] character ( len =* ), optional , intent ( in ) :: nulls ! return strings composed of delimiters or not ignore|return|ignoreend character ( len = :), allocatable , intent ( out ) :: array (:) ! output array of tokens !----------------------------------------------------------------------------------------------------------------------------------- integer :: n ! max number of strings INPUT_LINE could split into if all delimiter integer , allocatable :: ibegin (:) ! positions in input string where tokens start integer , allocatable :: iterm (:) ! positions in input string where tokens end character ( len = :), allocatable :: dlim ! string containing delimiter characters character ( len = :), allocatable :: ordr ! string containing order keyword character ( len = :), allocatable :: nlls ! string containing nulls keyword integer :: ii , iiii ! loop parameters used to control print order integer :: icount ! number of tokens found integer :: ilen ! length of input string with trailing spaces trimmed integer :: i10 , i20 , i30 ! loop counters integer :: icol ! pointer into input string as it is being parsed integer :: idlim ! number of delimiter characters integer :: ifound ! where next delimiter character is found in remaining input string data integer :: inotnull ! count strings not composed of delimiters integer :: ireturn ! number of tokens returned integer :: imax ! length of longest token !----------------------------------------------------------------------------------------------------------------------------------- ! decide on value for optional DELIMITERS parameter if ( present ( delimiters )) then ! optional delimiter list was present if ( delimiters /= '' ) then ! if DELIMITERS was specified and not null use it dlim = delimiters else ! DELIMITERS was specified on call as empty string dlim = ' ' // achar ( 9 ) // achar ( 10 ) // achar ( 11 ) // achar ( 12 ) // achar ( 13 ) // achar ( 0 ) ! use default delimiter when not specified endif else ! no delimiter value was specified dlim = ' ' // achar ( 9 ) // achar ( 10 ) // achar ( 11 ) // achar ( 12 ) // achar ( 13 ) // achar ( 0 ) ! use default delimiter when not specified endif idlim = len ( dlim ) ! dlim a lot of blanks on some machines if dlim is a big string !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( order )) then ; ordr = lower ( adjustl ( order )); else ; ordr = 'sequential' ; endif ! decide on value for optional ORDER parameter if ( present ( nulls )) then ; nlls = lower ( adjustl ( nulls )); else ; nlls = 'ignore' ; endif ! optional parameter !----------------------------------------------------------------------------------------------------------------------------------- n = len ( input_line ) + 1 ! max number of strings INPUT_LINE could split into if all delimiter allocate ( ibegin ( n )) ! allocate enough space to hold starting location of tokens if string all tokens allocate ( iterm ( n )) ! allocate enough space to hold ending location of tokens if string all tokens ibegin (:) = 1 iterm (:) = 1 !----------------------------------------------------------------------------------------------------------------------------------- ilen = len ( input_line ) ! ILEN is the column position of the last non-blank character icount = 0 ! how many tokens found inotnull = 0 ! how many tokens found not composed of delimiters imax = 0 ! length of longest token found !----------------------------------------------------------------------------------------------------------------------------------- select case ( ilen ) !----------------------------------------------------------------------------------------------------------------------------------- case (: 0 ) ! command was totally blank !----------------------------------------------------------------------------------------------------------------------------------- case default ! there is at least one non-delimiter in INPUT_LINE if get here icol = 1 ! initialize pointer into input line INFINITE : do i30 = 1 , ilen , 1 ! store into each array element ibegin ( i30 ) = icol ! assume start new token on the character if ( index ( dlim ( 1 : idlim ), input_line ( icol : icol )) == 0 ) then ! if current character is not a delimiter iterm ( i30 ) = ilen ! initially assume no more tokens do i10 = 1 , idlim ! search for next delimiter ifound = index ( input_line ( ibegin ( i30 ): ilen ), dlim ( i10 : i10 )) IF ( ifound > 0 ) then iterm ( i30 ) = min ( iterm ( i30 ), ifound + ibegin ( i30 ) - 2 ) endif enddo icol = iterm ( i30 ) + 2 ! next place to look as found end of this token inotnull = inotnull + 1 ! increment count of number of tokens not composed of delimiters else ! character is a delimiter for a null string iterm ( i30 ) = icol - 1 ! record assumed end of string. Will be less than beginning icol = icol + 1 ! advance pointer into input string endif imax = max ( imax , iterm ( i30 ) - ibegin ( i30 ) + 1 ) icount = i30 ! increment count of number of tokens found if ( icol > ilen ) then ! no text left exit INFINITE endif enddo INFINITE !----------------------------------------------------------------------------------------------------------------------------------- end select !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) ireturn = inotnull case default ireturn = icount end select allocate ( character ( len = imax ) :: array ( ireturn )) ! allocate the array to return !allocate(array(ireturn))                                       ! allocate the array to turn !----------------------------------------------------------------------------------------------------------------------------------- select case ( trim ( adjustl ( ordr ))) ! decide which order to store tokens case ( 'reverse' , 'right' ) ; ii = ireturn ; iiii =- 1 ! last to first case default ; ii = 1 ; iiii = 1 ! first to last end select !----------------------------------------------------------------------------------------------------------------------------------- do i20 = 1 , icount ! fill the array with the tokens that were found if ( iterm ( i20 ) < ibegin ( i20 )) then select case ( trim ( adjustl ( nlls ))) case ( 'ignore' , '' , 'ignoreend' ) case default array ( ii ) = ' ' ii = ii + iiii end select else array ( ii ) = input_line ( ibegin ( i20 ): iterm ( i20 )) ii = ii + iiii endif enddo !----------------------------------------------------------------------------------------------------------------------------------- end subroutine split !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      string_to_values(3f) - [M_strings:NUMERIC] read a string representing numbers into a numeric array !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       subroutine string_to_values(line,iread,values,inums,delims,ierr) !! !!        character(len=*) :: line !!        integer          :: iread !!        real             :: values(*) !!        integer          :: inums !!        character(len=*) :: delims !!        integer          :: ierr !!##DESCRIPTION !!   This routine can take a string representing a series of numbers and !!   convert it to a numeric array and return how many numbers were found. !! !!##OPTIONS !! !!       LINE     Input string containing numbers !!       IREAD    maximum number of values to try to read from input string !! !!##RESULTS !! !!       VALUES   real array to be filled with numbers !!       INUMS    number of values successfully read (before error occurs !!                if one does) !!       DELIMS   delimiter character(s), usually a space. must not be a !!                null string. If more than one character, a space must !!                not be the last character or it will be ignored. !!       IERR     error flag (0=no error, else column number string starts !!                at that error occurred on). !! !!##EXAMPLES !! !!  Sample Program: !! !!       program demo_string_to_values !!        use M_strings, only : string_to_values !!        character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 ' !!        integer,parameter  :: isz=10 !!        real               :: array(isz) !! !!        call string_to_values(s,10,array,inums,' ;',ierr) !!        call reportit() !! !!        call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr) !!        call reportit() !! !!        contains !!           subroutine reportit() !!              write(*,*)'string_to_values:' !!              write(*,*)'input string.............',trim(s) !!              write(*,*)'number of values found...',inums !!              write(*,*)'values...................',(array(ii),ii=1,inums) !!           end subroutine reportit !!       end program demo_string_to_values !! !!    Expected output !! !!        string_to_values: !!        input string............. 10 20e3;3.45 -400.3e-2;1234; 5678 !!        number of values found...           6 !!        values...................   10.0000000  20000.0000  3.45000005  -4.00299978  1234.00000  5678.00000 !!        string_to_values: !!        input string............. 10 20e3;3.45 -400.3e-2;1234; 5678 !!        number of values found...           3 !!        values...................   10.0000000  2.29999995  3.14159989 !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine string_to_values ( line , iread , values , inums , delims , ierr ) !---------------------------------------------------------------------------------------------------------------------------------- !   1989,1997-12-31,2014 John S. Urban !   given a line of structure , string , string , string process each !   string as a numeric value and store into an array. !   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS. !   There is no direct checking for more values than can fit in VALUES. !   Quits if encounters any errors in read. !---------------------------------------------------------------------------------------------------------------------------------- !character(len=*),parameter::ident_54=\"@(#)M_strings::string_to_values(3f): reads an array of numbers from a numeric string\" character ( len =* ), intent ( in ) :: line ! input string integer , intent ( in ) :: iread ! maximum number of values to try to read into values real , intent ( inout ) :: values ( iread ) ! real array to be filled with values integer , intent ( out ) :: inums ! number of values successfully read from string character ( len =* ), intent ( in ) :: delims ! allowed delimiters integer , intent ( out ) :: ierr ! 0 if no error, else column number undecipherable string starts at !---------------------------------------------------------------------------------------------------------------------------------- character ( len = 256 ) :: delims_local ! mutable copy of allowed delimiters integer :: istart , iend , ilen , icol integer :: i10 , i20 , i40 real :: rval integer :: ier integer :: delimiters_length !---------------------------------------------------------------------------------------------------------------------------------- delims_local = delims ! need a mutable copy of the delimiter list if ( delims_local == '' ) then ! if delimiter list is null or all spaces make it a space delims_local = ' ' ! delimiter is a single space delimiters_length = 1 ! length of delimiter list else delimiters_length = len_trim ( delims ) ! length of variable WITH TRAILING WHITESPACE TRIMMED endif !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error code returned inums = 0 ! initialize count of values successfully returned istart = 0 !---------------------------------------------------------------------------------------------------------------------------------- ilen = 0 ! ilen will be the position of the right-most non-delimiter in the input line do i20 = len ( line ), 1 , - 1 ! loop from end of string to beginning to find right-most non-delimiter if ( index ( delims_local (: delimiters_length ), line ( i20 : i20 )) == 0 ) then ! found a non-delimiter ilen = i20 exit endif enddo if ( ilen == 0 ) then ! command was totally composed of delimiters write ( stderr , gen ) '<ERROR>*string_to_values* - blank line passed as a list of numbers' return endif !---------------------------------------------------------------------------------------------------------------------------------- !     there is at least one non-delimiter sub-string !     ilen is the column position of the last non-delimiter character !     now, starting at beginning of string find next non-delimiter icol = 1 ! pointer to beginning of unprocessed part of LINE LOOP : dO i10 = 1 , iread , 1 ! each pass should find a value if ( icol > ilen ) EXIT LOOP ! everything is done INFINITE : do if ( index ( delims_local (: delimiters_length ), line ( icol : icol )) == 0 ) then ! found non-delimiter istart = icol iend = 0 ! FIND END OF SUBSTRING do i40 = istart , ilen ! look at each character starting at left if ( index ( delims_local (: delimiters_length ), line ( i40 : i40 )) /= 0 ) then ! determine if character is a delimiter iend = i40 ! found a delimiter. record where it was found EXIT ! found end of substring so leave loop endif enddo if ( iend == 0 ) iend = ilen + 1 ! no delimiters found, so this substring goes to end of line iend = iend - 1 ! do not want to pass delimiter to be converted rval = 0.0 call string_to_value ( line ( istart : iend ), rval , ier ) ! call procedure to convert string to a numeric value if ( ier == 0 ) then ! a substring was successfully converted to a numeric value values ( i10 ) = rval ! store numeric value in return array inums = inums + 1 ! increment number of values converted to a numeric value else ! an error occurred converting string to value ierr = istart ! return starting position of substring that could not be converted return endif icol = iend + 2 ! set to next character to look at CYCLE LOOP ! start looking for next value else ! this is a delimiter so keep looking for start of next string icol = icol + 1 ! increment pointer into LINE CYCLE INFINITE endif enddo INFINITE enddo LOOP !     error >>>>> more than iread numbers were in the line. end subroutine string_to_values !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    transliterate(3f) - [M_strings:EDITING] replace characters from old set with new set !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    pure function transliterate(instr,old_set,new_set) result(outstr) !! !!     character(len=*),intent(in)  :: instr !!     character(len=*),intent(in)  :: old_set !!     character(len=*),intent(in)  :: new_set !!     character(len=len(instr))    :: outstr !!##DESCRIPTION !!   Translate, squeeze, and/or delete characters from the input string. !! !!##OPTIONS !!    instr    input string to change !!    old_set  list of letters to change in INSTR if found !! !!             Each character in the input string that matches a character in !!             the old set is replaced. !!    new_set  list of letters to replace letters in OLD_SET with. !! !!             If the new_set is the empty set the matched characters are deleted. !! !!             If the new_set is shorter than the old set the last character in the !!             new set is used to replace the remaining characters in the new set. !!##RETURNS !!    outstr   instr with substitutions applied !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_transliterate !! !!     use M_strings, only : transliterate !!     implicit none !!     character(len=80)   :: STRING !! !!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ' !!     write(*,'(a)') STRING !! !!     ! convert a string to uppercase: !!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ') !! !!     ! change all miniscule letters to a colon (\":\"): !!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz',':') !! !!     ! delete all miniscule letters !!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','') !! !!     end program demo_transliterate !! !!    Expected output !! !!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ !!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ !!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z !!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== PURE FUNCTION transliterate ( instr , old_set , new_set ) RESULT ( outstr ) !character(len=*),parameter::ident_16=\"@(#)M_strings::transliterate(3f): replace characters from old set with new set\" !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN =* ), INTENT ( IN ) :: instr ! input string to change CHARACTER ( LEN =* ), intent ( in ) :: old_set CHARACTER ( LEN =* ), intent ( in ) :: new_set !----------------------------------------------------------------------------------------------------------------------------------- CHARACTER ( LEN = LEN ( instr )) :: outstr ! output string to generate !----------------------------------------------------------------------------------------------------------------------------------- INTEGER :: i10 ! loop counter for stepping thru string INTEGER :: ii , jj !----------------------------------------------------------------------------------------------------------------------------------- jj = LEN ( new_set ) IF ( jj /= 0 ) THEN outstr = instr ! initially assume output string equals input string stepthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii /= 0 ) THEN if ( ii <= jj ) then ! use corresponding character in new_set outstr ( i10 : i10 ) = new_set ( ii : ii ) else outstr ( i10 : i10 ) = new_set ( jj : jj ) ! new_set not as long as old_set; use last character in new_set endif ENDIF ENDDO stepthru else ! new_set is null string so delete characters in old_set outstr = ' ' hopthru : DO i10 = 1 , LEN ( instr ) ii = iNDEX ( old_set , instr ( i10 : i10 )) ! see if current character is in old_set IF ( ii == 0 ) THEN ! only keep characters not in old_set jj = jj + 1 outstr ( jj : jj ) = instr ( i10 : i10 ) ENDIF ENDDO hopthru endif END FUNCTION transliterate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      v2s(3f) - [M_strings:NUMERIC] return numeric string from a numeric value !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       function v2s(value) result(outstr) !! !!        integer|real|doubleprecision|logical,intent(in ) :: value !!        character(len=:),allocatable :: outstr !!        character(len=*),optional,intent(in) :: fmt !! !!##DESCRIPTION !! !!   v2s(3f) returns a representation of a numeric value as a !!   string when given a numeric value of type REAL, DOUBLEPRECISION, !!   INTEGER or LOGICAL. It creates the strings using internal WRITE() !!   statements. Trailing zeros are removed from non-zero values, and the !!   string is left-justified. !! !!##OPTIONS !!    VALUE   input value to be converted to a string !!    FMT     format can be explicitly given, but is limited to !!            generating a string of eighty or less characters. !! !!##RETURNS !!    OUTSTR  returned string representing input value, !! !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_v2s !!     use M_strings, only: v2s !!     write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']' !!     write(*,*) 'The value of 1234    is ['//v2s(1234)//']' !!     write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']' !!     write(*,*) 'The value of .false. is ['//v2s(.false.)//']' !!     write(*,*) 'The value of .true. is  ['//v2s(.true.)//']' !!     end program demo_v2s !! !!    Expected output !! !!     The value of 3.0/4.0 is [0.75] !!     The value of 1234    is [1234] !!     The value of 0d0     is [0] !!     The value of .false. is [F] !!     The value of .true. is  [T] !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== function d2s ( dvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_45=\"@(#)M_strings::d2s(3fp): private function returns string given doubleprecision value\" doubleprecision , intent ( in ) :: dvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( dvalue , string , fmt = fmt ) else call value_to_string ( dvalue , string ) endif outstr = trim ( string ) end function d2s !=================================================================================================================================== function r2s ( rvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_46=\"@(#)M_strings::r2s(3fp): private function returns string given real value\" real , intent ( in ) :: rvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( rvalue , string , fmt = fmt ) else call value_to_string ( rvalue , string ) endif outstr = trim ( string ) end function r2s !=================================================================================================================================== function i2s ( ivalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_47=\"@(#)M_strings::i2s(3fp): private function returns string given integer value\" integer , intent ( in ) :: ivalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( ivalue , string , fmt = fmt ) else call value_to_string ( ivalue , string ) endif outstr = trim ( string ) end function i2s !=================================================================================================================================== function l2s ( lvalue , fmt ) result ( outstr ) !character(len=*),parameter::ident_48=\"@(#)M_strings::l2s(3fp): private function returns string given logical value\" logical , intent ( in ) :: lvalue ! input value to convert to a string character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: outstr ! output string to generate character ( len = 80 ) :: string if ( present ( fmt )) then call value_to_string ( lvalue , string , fmt = fmt ) else call value_to_string ( lvalue , string ) endif outstr = trim ( string ) end function l2s !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      value_to_string(3f) - [M_strings:NUMERIC] return numeric string from a numeric value !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine value_to_string(value,chars[,ilen,ierr,fmt,trimz]) !! !!     character(len=*) :: chars  ! minimum of 23 characters required !!     !-------- !!     ! VALUE may be any <em>one</em> of the following types: !!     doubleprecision,intent(in)               :: value !!     real,intent(in)                          :: value !!     integer,intent(in)                       :: value !!     logical,intent(in)                       :: value !!     !-------- !!     character(len=*),intent(out)             :: chars !!     integer,intent(out),optional             :: ilen !!     integer,optional                         :: ierr !!     character(len=*),intent(in),optional     :: fmt !!     logical,intent(in)                       :: trimz !!##DESCRIPTION !! !!   value_to_string(3f) returns a numeric representation of a numeric !!   value in a string given a numeric value of type REAL, DOUBLEPRECISION, !!   INTEGER or LOGICAL. It creates the string using internal writes. It !!   then removes trailing zeros from non-zero values, and left-justifies !!   the string. !! !!##OPTIONS !!       VALUE   input value to be converted to a string !!       FMT     You may specify a specific format that produces a string !!               up to the length of CHARS; optional. !!       TRIMZ   If a format is supplied the default is not to try to trim !!               trailing zeros. Set TRIMZ to .true. to trim zeros from a !!               string assumed to represent a simple numeric value. !! !!##RETURNS !!       CHARS   returned string representing input value, must be at least !!               23 characters long; or what is required by optional FMT if longer. !!       ILEN    position of last non-blank character in returned string; optional. !!       IERR    If not zero, error occurred; optional. !!##EXAMPLES !! !!    Sample program: !! !!      program demo_value_to_string !!      use M_strings, only: value_to_string !!      implicit none !!      character(len=80) :: string !!      integer           :: ilen !!         call value_to_string(3.0/4.0,string,ilen) !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(3.0/4.0,string,ilen,fmt='') !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(3.0/4.0,string,ilen,fmt='(\"THE VALUE IS \",g0)') !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(1234,string,ilen) !!         write(*,*) 'The value is [',string(:ilen),']' !! !!         call value_to_string(1.0d0/3.0d0,string,ilen) !!         write(*,*) 'The value is [',string(:ilen),']' !! !!      end program demo_value_to_string !! !!    Expected output !! !!     The value is [0.75] !!     The value is [      0.7500000000] !!     The value is [THE VALUE IS .750000000] !!     The value is [1234] !!     The value is [0.33333333333333331] !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !=================================================================================================================================== subroutine value_to_string ( gval , chars , length , err , fmt , trimz ) !character(len=*),parameter::ident_40=\"@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value\" class ( * ), intent ( in ) :: gval character ( len =* ), intent ( out ) :: chars integer , intent ( out ), optional :: length integer , optional :: err integer :: err_local character ( len =* ), optional , intent ( in ) :: fmt ! format to write value with logical , intent ( in ), optional :: trimz character ( len = :), allocatable :: fmt_local character ( len = 1024 ) :: msg !  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL) if ( present ( fmt )) then select type ( gval ) type is ( integer ) fmt_local = '(i0)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( real ) fmt_local = '(bz,g23.10e3)' fmt_local = '(bz,g0.8)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) fmt_local = '(bz,g0)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval type is ( logical ) fmt_local = '(l1)' if ( fmt /= '' ) fmt_local = fmt write ( chars , fmt_local , iostat = err_local , iomsg = msg ) gval class default write ( stderr , gen ) '<ERROR>*value_to_string* - UNKNOWN TYPE' chars = ' ' end select if ( fmt == '' ) then chars = adjustl ( chars ) call trimzeros ( chars ) endif else ! no explicit format option present err_local =- 1 select type ( gval ) type is ( integer ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( real ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( doubleprecision ) write ( chars , * , iostat = err_local , iomsg = msg ) gval type is ( logical ) write ( chars , * , iostat = err_local , iomsg = msg ) gval class default chars = '' end select chars = adjustl ( chars ) if ( index ( chars , '.' ) /= 0 ) call trimzeros ( chars ) endif if ( present ( trimz )) then if ( trimz ) then chars = adjustl ( chars ) call trimzeros ( chars ) endif endif if ( present ( length )) then length = len_trim ( chars ) endif if ( present ( err )) then err = err_local elseif ( err_local /= 0 ) then !x! cannot currently do I/O from a function being called from I/O !x!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']' chars = chars // ' *value_to_string* WARNING:[' // trim ( msg ) // ']' endif end subroutine value_to_string !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    trimzeros(3fp) - [M_strings:NUMERIC] Delete trailing zeros from numeric decimal string !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine trimzeros(str) !! !!     character(len=*)  :: str !!##DESCRIPTION !!   TRIMZEROS(3f) deletes trailing zeros from a string representing a !!   number. If the resulting string would end in a decimal point, one !!   trailing zero is added. !!##OPTIONS !!    str   input string will be assumed to be a numeric value and have trailing !!          zeros removed !!##EXAMPLES !! !!    Sample program: !! !!       program demo_trimzeros !!       use M_strings, only : trimzeros !!       character(len=:),allocatable :: string !!          write(*,*)trimzeros('123.450000000000') !!          write(*,*)trimzeros('12345') !!          write(*,*)trimzeros('12345.') !!          write(*,*)trimzeros('12345.00e3') !!       end program demo_trimzeros !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine trimzeros ( string ) !character(len=*),parameter::ident_50=\"@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string\" ! if zero needs added at end assumes input string has room character ( len =* ) :: string character ( len = len ( string ) + 2 ) :: str character ( len = len ( string )) :: exp ! the exponent string if present integer :: ipos ! where exponent letter appears if present integer :: i , ii str = string ! working copy of string ipos = scan ( str , 'eEdD' ) ! find end of real number if string uses exponent notation if ( ipos > 0 ) then ! letter was found exp = str ( ipos :) ! keep exponent string so it can be added back as a suffix str = str ( 1 : ipos - 1 ) ! just the real part, exponent removed will not have trailing zeros removed endif if ( index ( str , '.' ) == 0 ) then ! if no decimal character in original string add one to end of string ii = len_trim ( str ) str ( ii + 1 : ii + 1 ) = '.' ! add decimal to end of string endif do i = len_trim ( str ), 1 , - 1 ! scanning from end find a non-zero character select case ( str ( i : i )) case ( '0' ) ! found a trailing zero so keep trimming cycle case ( '.' ) ! found a decimal character at end of remaining string if ( i <= 1 ) then str = '0' else str = str ( 1 : i - 1 ) endif exit case default str = str ( 1 : i ) ! found a non-zero character so trim string and exit exit end select end do if ( ipos > 0 ) then ! if originally had an exponent place it back on string = trim ( str ) // trim ( exp ) else string = str endif end subroutine trimzeros !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric value from string !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine string_to_value(chars,valu,ierr) !! !!     character(len=*),intent(in)              :: chars   ! input string !!     integer|real|doubleprecision,intent(out) :: valu !!     integer,intent(out)                      :: ierr !!##DESCRIPTION !!   returns a numeric value from a numeric character string. !! !!   works with any g-format input, including integer, real, and !!   exponential. If the input string begins with \"B\", \"Z\", or \"O\" !!   and otherwise represents a positive whole number it is assumed to !!   be a binary, hexadecimal, or octal value. If the string contains !!   commas they are removed. If the string is of the form NN:MMM... or !!   NN#MMM then NN is assumed to be the base of the whole number. !! !!   if an error occurs in the READ, IOSTAT is returned in IERR and !!   value is set to zero. if no error occurs, IERR=0. !!##OPTIONS !!       CHARS  input string to read numeric value from !!##RETURNS !!       VALU   numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION. !!       IERR   error flag (0 == no error) !!##EXAMPLES !! !!    Sample Program: !! !!     program demo_string_to_value !!     use M_strings, only: string_to_value !!     character(len=80) :: string !!        string=' -40.5e-2 ' !!        call string_to_value(string,value,ierr) !!        write(*,*) 'value of string ['//trim(string)//'] is ',value !!     end program demo_string_to_value !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== subroutine a2r ( chars , valu , ierr ) !> !! subroutine returns real value from string !character(len=*),parameter::ident_40=\"@(#)M_strings::a2r(3fp): subroutine returns real value from string\" character ( len =* ), intent ( in ) :: chars ! input string real , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( ierr == 0 ) then if ( valu8 <= huge ( valu )) then valu = real ( valu8 ) else write ( stderr , gen ) '<ERROR>*a2r* - value too large' , valu8 , '>' , huge ( valu ) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2r !---------------------------------------------------------------------------------------------------------------------------------- subroutine a2i ( chars , valu , ierr ) !> !! subroutine returns integer value from string !character(len=*),parameter::ident_41=\"@(#)M_strings::a2i(3fp): subroutine returns integer value from string\" character ( len =* ), intent ( in ) :: chars ! input string integer , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) doubleprecision :: valu8 valu8 = 0.0d0 call a2d ( chars , valu8 , ierr , onerr = 0.0d0 ) if ( valu8 <= huge ( valu )) then if ( valu8 <= huge ( valu )) then valu = int ( valu8 ) else write ( stderr , gen ) '<ERROR>*a2i*' , '- value too large' , valu8 , '>' , huge ( valu ) valu = huge ( valu ) ierr =- 1 endif endif end subroutine a2i !---------------------------------------------------------------------------------------------------------------------------------- subroutine a2d ( chars , valu , ierr , onerr ) !> !! subroutine returns doubleprecision value from string !character(len=*),parameter::ident_42=\"@(#)M_strings::a2d(3fp): subroutine returns double value from string\" !     1989,2016 John S. Urban. ! !  o  works with any g-format input, including integer, real, and exponential. !  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0. !  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data. !     IERR will still be non-zero in this case. !---------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( in ) :: chars ! input string character ( len = :), allocatable :: local_chars doubleprecision , intent ( out ) :: valu ! value read from input string integer , intent ( out ) :: ierr ! error flag (0 == no error) class ( * ), optional , intent ( in ) :: onerr !---------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), parameter :: fmt = \"('(bn,g',i5,'.0)')\" ! format used to build frmt character ( len = 15 ) :: frmt ! holds format built to read input string character ( len = 256 ) :: msg ! hold message from I/O errors integer :: intg integer :: pnd integer :: basevalue , ivalu character ( len = 3 ), save :: nan_string = 'NaN' !---------------------------------------------------------------------------------------------------------------------------------- ierr = 0 ! initialize error flag to zero local_chars = chars msg = '' if ( len ( local_chars ) == 0 ) local_chars = ' ' call substitute ( local_chars , ',' , '' ) ! remove any comma characters pnd = scan ( local_chars , '#:' ) if ( pnd /= 0 ) then write ( frmt , fmt ) pnd - 1 ! build format of form '(BN,Gn.0)' read ( local_chars (: pnd - 1 ), fmt = frmt , iostat = ierr , iomsg = msg ) basevalue ! try to read value from string if ( decodebase ( local_chars ( pnd + 1 :), basevalue , ivalu )) then valu = real ( ivalu , kind = kind ( 0.0d0 )) else valu = 0.0d0 ierr =- 1 endif else select case ( local_chars ( 1 : 1 )) case ( 'z' , 'Z' , 'h' , 'H' ) ! assume hexadecimal frmt = '(Z' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'b' , 'B' ) ! assume binary (base 2) frmt = '(B' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case ( 'o' , 'O' ) ! assume octal frmt = '(O' // v2s ( len ( local_chars )) // ')' read ( local_chars ( 2 :), frmt , iostat = ierr , iomsg = msg ) intg valu = dble ( intg ) case default write ( frmt , fmt ) len ( local_chars ) ! build format of form '(BN,Gn.0)' read ( local_chars , fmt = frmt , iostat = ierr , iomsg = msg ) valu ! try to read value from string end select endif if ( ierr /= 0 ) then ! if an error occurred ierr will be non-zero. if ( present ( onerr )) then select type ( onerr ) type is ( integer ) valu = onerr type is ( real ) valu = onerr type is ( doubleprecision ) valu = onerr end select else ! set return value to NaN read ( nan_string , '(g3.3)' ) valu endif if ( local_chars /= 'eod' ) then ! print warning message except for special value \"eod\" write ( stderr , gen ) '<ERROR>*a2d* - cannot produce number from string [' // trim ( chars ) // ']' if ( msg /= '' ) then write ( stderr , gen ) '       *a2d* - [' // trim ( msg ) // ']' endif endif endif end subroutine a2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !! !!   decodebase(3f) - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number !!   (LICENSE:PD) !! !!##SYNOPSIS !! !!    logical function decodebase(string,basein,out10) !! !!     character(len=*),intent(in)  :: string !!     integer,intent(in)           :: basein !!     integer,intent(out)          :: out10 !!##DESCRIPTION !! !!   Convert a numeric string representing a whole number in base BASEIN !!   to base 10. The function returns FALSE if BASEIN is not in the range !!   [2..36] or if string STRING contains invalid characters in base BASEIN !!   or if result OUT10 is too big !! !!   The letters A,B,...,Z represent 10,11,...,36 in the base > 10. !! !!##OPTIONS !!    string   input string. It represents a whole number in !!             the base specified by BASEIN unless BASEIN is set !!             to zero. When BASEIN is zero STRING is assumed to !!             be of the form BASE#VALUE where BASE represents !!             the function normally provided by BASEIN. !!    basein   base of input string; either 0 or from 2 to 36. !!    out10    output value in base 10 !! !!##EXAMPLES !! !!    Sample program: !! !!     program demo_decodebase !!     use M_strings, only : codebase, decodebase !!     implicit none !!     integer           :: ba,bd !!     character(len=40) :: x,y !!     integer           :: r !! !!     print *,' BASE CONVERSION' !!     write(*,'(\"Start   Base (2 to 36): \")',advance='no'); read *, bd !!     write(*,'(\"Arrival Base (2 to 36): \")',advance='no'); read *, ba !!     INFINITE: do !!        print *,'' !!        write(*,'(\"Enter number in start base: \")',advance='no'); read *, x !!        if(x=='0') exit INFINITE !!        if(decodebase(x,bd,r)) then !!           if(codebase(r,ba,y)) then !!             write(*,'(\"In base \",I2,\": \",A20)')  ba, y !!           else !!             print *,'Error in coding number.' !!           endif !!        else !!           print *,'Error in decoding number.' !!        endif !!     enddo INFINITE !! !!     end program demo_decodebase !! !!##AUTHOR !!    John S. Urban !! !!       Ref.: \"Math matiques en Turbo-Pascal by !!              M. Ducamp and A. Reverchon (2), !!              Eyrolles, Paris, 1988\". !! !!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr) !! !!##LICENSE !!    Public Domain !=================================================================================================================================== logical function decodebase ( string , basein , out_baseten ) !character(len=*),parameter::ident_72=\"@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number\" character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: basein integer , intent ( out ) :: out_baseten character ( len = len ( string )) :: string_local integer :: long , i , j , k real :: y real :: mult character ( len = 1 ) :: ch real , parameter :: XMAXREAL = real ( huge ( 1 )) integer :: out_sign integer :: basein_local integer :: ipound integer :: ierr string_local = upper ( trim ( adjustl ( string ))) decodebase = . false . ipound = index ( string_local , '#' ) ! determine if in form [-]base#whole if ( basein == 0. and . ipound > 1 ) then ! split string into two values call string_to_value ( string_local (: ipound - 1 ), basein_local , ierr ) ! get the decimal value of the base string_local = string_local ( ipound + 1 :) ! now that base is known make string just the value if ( basein_local >= 0 ) then ! allow for a negative sign prefix out_sign = 1 else out_sign =- 1 endif basein_local = abs ( basein_local ) else ! assume string is a simple positive value basein_local = abs ( basein ) out_sign = 1 endif out_baseten = 0 y = 0.0 ALL : if ( basein_local < 2. or . basein_local > 36 ) then print gen , '(*decodebase* ERROR: Base must be between 2 and 36. base=' , basein_local else ALL out_baseten = 0 ; y = 0.0 ; mult = 1.0 long = LEN_TRIM ( string_local ) do i = 1 , long k = long + 1 - i ch = string_local ( k : k ) if ( ch == '-' . and . k == 1 ) then out_sign =- 1 cycle endif if ( ch < '0' . or . ch > 'Z' . or .( ch > '9' . and . ch < 'A' )) then write ( stderr , * ) '<ERROR>*decodebase* - invalid character ' , ch exit ALL endif if ( ch <= '9' ) then j = IACHAR ( ch ) - IACHAR ( '0' ) else j = IACHAR ( ch ) - IACHAR ( 'A' ) + 10 endif if ( j >= basein_local ) then exit ALL endif y = y + mult * j if ( mult > XMAXREAL / basein_local ) then exit ALL endif mult = mult * basein_local enddo decodebase = . true . out_baseten = nint ( out_sign * y ) * sign ( 1 , basein ) endif ALL end function decodebase end module M_time__duplicate","tags":"","url":"sourcefile/m_time__duplicate.f90.html"},{"title":"M_time__oop.f90 – M_time","text":"Source Code !=================================================================================================================================== ! !     XX                                             X !      X            X                       X !      X            X                       X !  XXXXX   XXXX    XXXX    XXXXX           XXXX    XXX    XXX X    XXXXX ! X    X       X    X     X     X           X        X     X X X  X     X ! X    X   XXXXX    X     XXXXXXX           X        X     X X X  XXXXXXX ! X    X  X    X    X     X                 X        X     X X X  X ! X    X  X    X    X  X  X     X           X  X     X     X X X  X     X !  XXXXXX  XXXX X    XX    XXXXX             XX    XXXXX  XX X XX  XXXXX ! !                                XXXXXXXX ! !> !!##NAME !!    M_time__oop(3fm) - [M_time::INTRO::OOPS] OOP interface for M_time(3fm) !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!   use M_time__oop, only : date_time !!   ! the type includes the following operators: !!   !    operator(+) !!   !    operator(-) !!   !    operator(>) !!   !    operator(<) !!   !    operator(<=) !!   !    operator(>=) !!   !    operator(==) !!   !    operator(/=) !! !!    TYPE(date_time) :: mydate !! !!       mydate%year !!       mydate%month !!       mydate%day !!       mydate%tz !!       mydate%hour !!       mydate%minute !!       mydate%second !!       mydate%millisecond !! !!       call mydate%init() !! !!       mydate%format('') !!       mydate%ordinal() !!       mydate%weekday() !!       mydate%epoch() !!       mydate%julian() !!       mydate%mjd() !!       dat=mydate%datout() !!       mydate%delta(year=NN, month=NN, day=NN, tz=NN, hour=NN, minute=NN, !!       second=NN, millisecond=NN, week=NN, duration='DD-HH:MM:SS.XX') !! !!##DESCRIPTION !!    An object-oriented interface to the M_time module. The following !!    example program demonstrates and documents the interface !! !!##EXAMPLES !! !! !!  sample program !! !!     program demo_M_time__oop !!     ! !!     ! This is an example using the object-oriented class/type model !!     ! This is essentially the same functionality as the procedures !!     ! in the procedural module M_time(3fm), but allows for Object !!     ! Oriented syntax: !!     ! !!     use M_time__oop,only : date_time !!     ! The type includes the operators ... !!     !  operator(+) !!     !  operator(-) !!     !  operator(>) !!     !  operator(<) !!     !  operator(<=) !!     !  operator(>=) !!     !  operator(==) !!     !  operator(/=) !!     implicit none !!     integer,parameter :: dp=kind(0.0d0) !!     integer         :: dat(8) !!     TYPE(date_time) :: event !!     TYPE(date_time) :: otherdate !!     TYPE(date_time) :: answer !! !!     character(len=*),parameter :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z' !!        ! DIFFERENT INITIALIZATION STYLES !!        ! (Still debating on how best to do this) !!        write(*,*) !!        write(*,'(a)')'Various initialization styles' !! !!        ! DEFINE type(date_time) WITH CONSTRUCTOR !!        otherdate=date_time() !!        print *,'DEFAULT CONSTRUCTOR %format()               ',& !!        & otherdate%format() !!        print *,'DEFAULT CONSTRUCTOR %format(\"\")             ',& !!        & otherdate%format(\"\") !!        print *,'DEFAULT CONSTRUCTOR %format(user-specified) ',& !!        & otherdate%format(iso_fmt) !!        print *,'DEFAULT CONSTRUCTOR %format(\"USA\")          ',& !!        & otherdate%format(\"USA\") !! !!        otherdate=date_time(1492,10,12,0,0,0,0,0) !!        print *,'DEFAULT CONSTRUCTOR setting values          ',& !!        & otherdate%format() !! !!        otherdate=date_time(2016,6,11) !!        print *,'DEFAULT CONSTRUCTOR with partial values     ',& !!        & otherdate%format() !! !!        otherdate=date_time(year=2016,month=6,day=11,tz=-240,& !!        & hour=21,minute=09,second=11,millisecond=500) !!        print *,'DEFAULT CONSTRUCTOR with values by name     ',& !!        & otherdate%format() !! !!        otherdate=date_time([1776,7,4,0,0,0,0,0]) !!        print *,'CONSTRUCTOR with a dat array                ',& !!        & otherdate%format() !! !!        otherdate=date_time([1776,7,4]) !!        print *,'CONSTRUCTOR with a partial dat array        ',& !!        & otherdate%format() !! !!        ! the init() method supports several methods !!        ! initialize to current time using INIT !!        call otherdate%init() !!        ! initialize to current time using INIT !!        call otherdate%init(type=\"now\") !! !!        ! initialize to beginning of Unix Epoch Time !!        call otherdate%init(type=\"epoch\") !!        ! Note !!        ! currently, DATE_TIME DATE array is set to Unix Epoch !!        ! start USING LOCAL TIMEZONE !!        ! whereas default constructor is using default of Unix Epoch !!        ! start using Z time (GMT or UTC time) !! !!        ! initialize with a DAT array using INIT, !!        ! compatible with DATE_AND_TIME VALUES(8) !!        call otherdate%init(dat=[1970,1,1,0,0,0,0,0]) !!        ! using INIT with ordered values !!        call otherdate%init(2016,6,11,-300,23,1,0,0) !!        ! using INIT with names !!        call otherdate%init(year=2016,month=6,day=11,& !!        & tz=-300,hour=23,minute=1,second=0,millisecond=0) !!        ! !!        ! take current date and exercise the OOP interface !!        ! initialize to current time using INIT !!        call event%init() !!        write(*,*) !!        write(*,*)'Print members of type(DATE_TIME)' !!        ! show derived type !!        write(*,404)'EVENT=',event !!        404 format(1x,a,i0,*(\",\",i0:)) !! !!        ! MEMBERS ( basic time values are all integers) !!        ! print members of type !!        write(*,101)'%year        Year................... ',event%year !!        write(*,101)'%month       Month.................. ',event%month !!        write(*,101)'%day         Day.................... ',event%day !!        write(*,101)'%tz          Timezone............... ',event%tz !!        write(*,101)'%hour        Hour................... ',event%hour !!        write(*,101)'%minute      Minute................. ',event%minute !!        write(*,101)'%second      Second................. ',event%second !!        write(*,101)'%millisecond Millisecond............ ',event%millisecond !! !!        ! PRINT METHODS OF TYPE !!        write(*,*)'Print methods of type(DATE_TIME)' !!        write(*,101)'%ordinal     Ordinal day of year.... ',  event%ordinal() !!        write(*,101)'%weekday     Weekday................ ',  event%weekday() !!        101 format(1x,a,i0) !!        ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY !!        write(*,202)'%epoch      Unix epoch time........ ',  event%epoch() !!        write(*,202)'%julian     Julian date............ ',  event%julian() !!        write(*,202)'%mjd        Modiied Julian date.... ',  event%mjd() !!        202 format(1x,a,g0) !! !!        ! FORMATTED STRINGS (many strings possible. !!        ! Takes the same format string as fmtdate(3f)) !!        write(*,*) !!        write(*,'(a)')' Formatted Strings (%format(\"STRING\") & !!        & -- see fmtdate(3f) for format descriptions' !!        ! abbreviated month name             %l  Dec !!        write(*,303)'Short month............ ',& !!        & event%format(\"%l\") !!        ! !!        ! full month name                    %L  December !!        write(*,303)'Month.................. ',& !!        & event%format(\"%L\") !!        ! !!        ! first three characters of weekday  %w  Sat !!        write(*,303)'Short week............. ',& !!        & event%format(\"%w\") !!        ! !!        ! weekday name                       %W  Saturday !!        write(*,303)'Week .................. ',& !!        & event%format(\"%W\") !!        ! !!        ! with no percent (%) characters !!        write(*,303)'Calendar Time ......... ',& !!        & event%format(\"Y-M-D h:m:s.x z\") !!        ! !!        ! keywords with no percent (%) characters !!        write(*,303)'Calendar Time ......... ',& !!        & event%format('\"year-month-day & !!        & hour:minute:second.millisecond timezone\"') !!        ! !!        write(*,*)event%format('Longer format.......... & !!        &\"%W, %L %d, %Y %H:%m:%s %N\"') ! a nice friendly format !!        ! !!        303 format(1x,a,'\"',a,'\"') !! !!        ! convert date_time to integer array !!        ! (maybe to use with module M_TIME base procedures) !!        dat=event%datout() !!        write(*,*) !!        write(*,404)'DAT=',dat !! !!        ! OVERLOADED OPERATORS (add and subtract) !!        ! a date_time object can have seconds added !!        answer=event+1*86400.0_dp !!        ! !!        ! a nice friendly format !!        write(*,*)answer%format('TOMORROW=\"%W, %L %d, %Y %H:%m:%s %N\"') !!        ! !!        ! a date_time object can have seconds subtracted !!        answer=event-1*86400.0_dp !!        ! a nice friendly format !!        write(*,*)answer%format('YESTERDAY=\"%W, %L %d, %Y %H:%m:%s %N\"') !!        ! !!        ! if both operands are DATE_TIME objects a subtraction !!        ! finds the time in seconds between the two dates !!        write(*,*)'DIFFERENCE (subtracting one date_time from another)=',& !!        & answer-event !! !!        ! OVERLOADED OPERATORS (logical comparisons) !!        ! NOTE COMPARISONS ARE PERFORMED BY !!        ! CONVERTING TIMES TO INTEGER SECONDS !!        write(*,*)'> ',event==event   ,event<event   ,event>event & !!        & ,event<=event   ,event>=event   ,event/=event !!        ! !!        write(*,*)'> ',event==answer  ,event<answer  ,event>answer  & !!        & ,event<=answer  ,event>=answer  ,event/=answer !!        ! !!        write(*,*)'> ',answer==event  ,answer<event  ,answer>event  & !!        & ,answer<=event  ,answer>=event  ,answer/=event !! !!        ! %DELTA easily lets you change dates by common increments !!        write(*,*) !!        write(*,404)'%DELTA tests starting with date ',event%delta() !!        ! !!        write(*,*) event%format(\"                             & !!        &%W, %L %d, %Y %H:%m:%s %N\") !! !!        write(*,*)'Remember years and months are not constant units' !! !!        answer=event%delta(year=1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N\") !!        answer=event%delta(year=-1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(month=24) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(month=-24) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(week=1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(week=-1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(day=1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(day=-1) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(hour=4) !!        write(*,*)answer%format(& !!        ! !!        & \"FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N\") !!        answer=event%delta(hour=-4) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(minute=180) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(minute=-180) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(second=1800) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(second=-1800) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(millisecond=10000) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N\") !!        ! !!        answer=event%delta(millisecond=-10000) !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(year=3,month=2,day=100,hour=200,& !!        & week=-1,minute=300,second=1000,millisecond=-10000) !!        write(*,*)answer%format(& !!        ! !!        &\"FOR %%DELTA(year=3,month=2,day=100,hour=200,& !!        &week=-1,minute=300,second=1000,millisecond=100000)& !!        & %W, %L %d, %Y %H:%m:%s %N\") !! !!        answer=event%delta(duration=\"1-20:30:40.50\") !!        write(*,*)answer%format(& !!        & \"FOR %%DELTA(DURATION='1-20:30:40.50')& !!        & %W, %L %d, %Y %H:%m:%s %N\") !! !!     end program demo_M_time__oop !! !! Sample output: !! !!  Various initialization styes !!   DEFAULT CONSTRUCTOR %format()               1970-01-01T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR %format(\"\")             1970-01-01T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR %format(user-specified) 1970-01-01T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR %format(\"USA\")   Thursday, January 1st, 1970 12:00:00 AM !!   DEFAULT CONSTRUCTOR setting values          1492-10-12T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR with partial values     2016-06-11T00:00:00.000+00:00 !!   DEFAULT CONSTRUCTOR with values by name     2016-06-11T21:09:11.500-04:00 !!   CONSTRUCTOR with a dat array                1776-07-04T00:00:00.000+00:00 !!   CONSTRUCTOR with a partial dat array        1776-07-04T20:00:00.000-04:00 !! !!   Print members of type(DATE_TIME) !!   EVENT=2020,10,24,-240,21,49,54,105 !!   %year        Year................... 2020 !!   %month       Month.................. 10 !!   %day         Day.................... 24 !!   %tz          Timezone............... -240 !!   %hour        Hour................... 21 !!   %minute      Minute................. 49 !!   %second      Second................. 54 !!   %millisecond Millisecond............ 105 !!   Print methods of type(DATE_TIME) !!   %ordinal     Ordinal day of year.... 298 !!   %weekday     Weekday................ 6 !!   %epoch      Unix epoch time........ 1603590594.1049695 !!   %julian     Julian date............ 2459147.5763206594 !!   %mjd        Modified Julian date... 59147.9763206594 !! !!   Formatted Strings (%format(\"STRING\") !!   -- see fmtdate(3f) for format descriptions !!   Short month............ \"Oct\" !!   Month.................. \"October\" !!   Short week............. \"Sat\" !!   Week .................. \"Saturday\" !!   Calendar Time ......... \"2020-10-24 21:49:54.105 -04:00\" !!   Calendar Time ......... \"\"2020-10-24 21:49:54.105 -0400\"\" !!   Longer format.......... \"Saturday, October 24th, 2020 9:49:54 PM\" !! !!   DAT=2020,10,24,-240,21,49,54,105 !!   TOMORROW=\"Sunday, October 25th, 2020 9:49:54 PM\" !!   YESTERDAY=\"Friday, October 23rd, 2020 9:49:54 PM\" !!   DIFFERENCE (subtracting one date_time from another)=  -86400.000000000000 !!   >  T F F T T F !!   >  F F T F T T !!   >  F T F T F T !! !!   %DELTA tests starting with date 2020,10,24,-240,21,49,54,105 !!                                Saturday, October 24th, 2020 9:49:54 PM !!   Remember years and months are not constant units !!   FOR %DELTA(YEAR=+1)            Sunday, October 24th, 2021 9:49:54 PM !!   FOR %DELTA(YEAR=-1)            Thursday, October 24th, 2019 9:49:54 PM !!   FOR %DELTA(MONTH=+24)          Wednesday, October 26th, 2022 9:49:54 PM !!   FOR %DELTA(MONTH=-24)          Wednesday, October 24th, 2018 9:49:54 PM !!   FOR %DELTA(WEEK=+1)            Saturday, October 31st, 2020 9:49:54 PM !!   FOR %DELTA(WEEK=-1)            Saturday, October 17th, 2020 9:49:54 PM !!   FOR %DELTA(DAY=+1)             Sunday, October 25th, 2020 9:49:54 PM !!   FOR %DELTA(DAY=-1)             Friday, October 23rd, 2020 9:49:54 PM !!   FOR %DELTA(HOUR=+4)            Sunday, October 25th, 2020 1:49:54 AM !!   FOR %DELTA(HOUR=-4)            Saturday, October 24th, 2020 5:49:54 PM !!   FOR %DELTA(MINUTE=+180)        Sunday, October 25th, 2020 12:49:54 AM !!   FOR %DELTA(MINUTE=-180)        Saturday, October 24th, 2020 6:49:54 PM !!   FOR %DELTA(SECOND=+1800)       Saturday, October 24th, 2020 10:19:54 PM !!   FOR %DELTA(SECOND=-1800)       Saturday, October 24th, 2020 9:19:54 PM !!   FOR %DELTA(MILLISECOND=+10000) Saturday, October 24th, 2020 9:50:04 PM !!   FOR %DELTA(MILLISECOND=-10000) Saturday, October 24th, 2020 9:49:44 PM !!   FOR %DELTA(year=3,month=2,day=100,hour=200,week=-1,minute=300, !!   second=1000,millisecond=100000) Thursday, April 4th, 2024 11:06:24 AM !!   FOR %DELTA(DURATION='1-20:30:40.50') Monday, October 26th, 2020 6:20:34 PM !!##AUTHOR !!    John S. Urban, 2015 !! !!##LICENSE !!    MIT !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! submodule is not supported by the compiler used to develop this yet or it would be worth a try !!submodule (M_time) M_time__oop !!end submodule M_time__oop ! module M_time__oop ! ! Define an OOP (Object-Oriented Programming) interface for the M_time module. ! ! Leveraging the existing procedural functions in module M_TIME to do the calculations allows ! this to simply be a definition of a derived type ( TYPE(DATE_TIME) ) and the ! methods it supports and overloading of operators to support the new data type. ! use M_time , only : d2u , u2d , fmtdate , d2o , dow , fmtdate_usage , days2sec , realtime use M_time , only : j2d , d2j , d2m use M_time__duplicate , only : upper implicit none !(type,external) integer , parameter :: dp = kind ( 0.0d0 ) private private upper !----------------------------------------------------------------------------------------------------------------------------------- public date_time private dt2d_ private epoch_ private julian_ private mjd_ private ordinal private weekday private format private delta private init_dt !----------------------------------------------------------------------------------------------------------------------------------- !DERIVED TYPE DATE_TIME ! type date_time ! COMPONENTS: ! Eight integer element integer elements containing year, month, day, Time zone difference ! from UTC in minutes, hour, minutes, seconds, and milliseconds of the second in one-to-one ! correspondence with the elements of the array generated by the intrinsic function DATE_AND_TIME()... integer :: year = 1970 integer :: month = 1 integer :: day = 1 integer :: tz = 0 integer :: hour = 0 integer :: minute = 0 integer :: second = 0 integer :: millisecond = 0 contains ! METHODS: procedure :: datout => dt2d_ procedure :: epoch => epoch_ procedure :: julian => julian_ procedure :: mjd => mjd_ procedure :: ordinal procedure :: weekday procedure :: format procedure :: delta procedure :: init => init_dt !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(DATE_TIME) procedure , private :: plus_seconds generic :: operator ( + ) => plus_seconds procedure , private :: eq generic :: operator ( == ) => eq procedure , private :: lt generic :: operator ( < ) => lt procedure , private :: gt generic :: operator ( > ) => gt procedure , private :: ge generic :: operator ( >= ) => ge procedure , private :: le generic :: operator ( <= ) => le procedure , private :: ne generic :: operator ( /= ) => ne !-! procedure         :: construct_from_dat !-! generic           :: assignment(=)  => construct_from_dat procedure , private :: minus_seconds ! subtracts seconds, returns a new date_time procedure , private :: minus_date_time ! returns seconds generic :: operator ( - ) => minus_seconds generic :: operator ( - ) => minus_date_time end type !=================================================================================================================================== ! User-defined constructors are created by defining a generic interface ! with the same name as the derived type they're supposed to construct. interface date_time module procedure construct_from_dat !-!module procedure construct_from_jd !-!module procedure construct_from_uet end interface date_time !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! this function is used internally in the module, but is also declared to be a constructor for creating TYPE(DATE_TYPE) structures ! function construct_from_dat ( dat ) ! ident_1=\"@(#) M_time construct_from_dat(3f) construct TYPE(DATE_TIME) with DAT date-time array\" integer , intent ( in ) :: dat (:) ! (maybe partial) date time array integer :: datlocal ( 8 ) ! date time array similar to that returned by DATE_AND_TIME type ( date_time ) :: construct_from_dat datlocal = u2d ( 0.0_dp ) ! initialize to start of Unix Epoch Time using local time zone if ( size ( dat ) > 0 ) then ! allow for partial DAT arrays datlocal (: size ( dat )) = dat endif construct_from_dat % year = datlocal ( 1 ) construct_from_dat % month = datlocal ( 2 ) construct_from_dat % day = datlocal ( 3 ) construct_from_dat % tz = datlocal ( 4 ) construct_from_dat % hour = datlocal ( 5 ) construct_from_dat % minute = datlocal ( 6 ) construct_from_dat % second = datlocal ( 7 ) construct_from_dat % millisecond = datlocal ( 8 ) end function construct_from_dat !=================================================================================================================================== function construct_from_jd ( jd ) ! ident_2=\"@(#) M_time construct_from_jd(3f) construct TYPE(DATE_TIME) with REAL Julian JD date-time value\" real ( kind = realtime ), intent ( in ) :: jd type ( date_time ) :: construct_from_jd construct_from_jd = construct_from_dat ( j2d ( jd )) end function construct_from_jd !=================================================================================================================================== function construct_from_uet ( uet ) ! ident_3=\"@(#) M_time construct_from_uet(3f) construct TYPE(DATE_TIME) with INTEGER Unix UET date-time value\" integer , intent ( in ) :: uet type ( date_time ) :: construct_from_uet construct_from_uet = construct_from_dat ( u2d ( real ( uet , kind = realtime ))) end function construct_from_uet !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! DEFINE THE METHODS FOR THE TYPE ! These functions are privately used to define the methods that TYPE(DATE_TIME) will support !=================================================================================================================================== function dt2d_ ( self ) result ( dat ) ! ident_4=\"@(#) M_time dt2d_(3f) convert derived type date_time to DAT date-time array\" class ( date_time ), intent ( in ) :: self integer :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME dat = [ self % year , self % month , self % day , self % tz , self % hour , self % minute , self % second , self % millisecond ] end function dt2d_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function epoch_ ( self ) result ( epoch_seconds ) ! ident_5=\"@(#) M_time epoch_(3f) convert derived type date_time to unix epoch seconds\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ) :: epoch_seconds epoch_seconds = d2u ( dt2d_ ( self )) end function epoch_ !=================================================================================================================================== function format ( self , fmt ) result ( string ) ! ident_6=\"@(#) M_time format(3f) convert derived type date_time to formatted string\" class ( date_time ), intent ( in ) :: self character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: fmtlocal character ( len = :), allocatable :: string character ( len =* ), parameter :: iso_fmt = '%Y-%M-%DT%h:%m:%s.%x%z' character ( len =* ), parameter :: usa_fmt = '%W, %L %d, %Y %H:%m:%s %N' character ( len =* ), parameter :: ymd_fmt = '%Y-%M-%D %h:%m:%s.%x%z' character ( len =* ), parameter :: mdy_fmt = '%M/%D/%Y %h:%m:%s.%x%z' if ( present ( fmt )) then fmtlocal = fmt else fmtlocal = iso_fmt endif if ( index ( fmtlocal , '%' ) == 0 ) then ! if a percent(%) in string assume it is a string to be passed to fmtdate select case ( upper ( fmtlocal )) case ( \"ISO\" , \"ISO-8601\" , \"\" ); fmtlocal = iso_fmt case ( \"USA\" ); fmtlocal = usa_fmt case ( \"YMD\" ); fmtlocal = ymd_fmt case ( \"MDY\" ); fmtlocal = mdy_fmt case default !! usually used in a WRITE(3f) or PRINT(3f) so should not write output !write(*,*)'date_time%format: unknown format name' !write(*,*)'use predefined names (\"iso\",\"usa\",\"ymd\",\"mdy\")' !write(*,*)'or a user-supplied format including the following macros:' !call fmtdate_usage() !fmtlocal='date_time%format: unknown format name '//trim(fmtlocal)//'(not \"iso\",\"usa\",\"ymd\",\"mdy\" or %macros)'//iso_fmt end select endif string = fmtdate ( dt2d_ ( self ), fmtlocal ) end function format !=================================================================================================================================== function mjd_ ( self ) result ( mjd_days ) ! ident_7=\"@(#) M_time mjd_(3f) convert derived type date_time to mjd date\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ) :: mjd_days mjd_days = d2m ( dt2d_ ( self )) end function mjd_ !=================================================================================================================================== function julian_ ( self ) result ( julian_days ) ! ident_8=\"@(#) M_time julian_(3f) convert derived type date_time to julian date\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ) :: julian_days julian_days = d2j ( dt2d_ ( self )) end function julian_ !=================================================================================================================================== function ordinal ( self ) result ( ordinal_days ) ! ident_9=\"@(#) M_time ordinal(3f) convert derived type date_time to ordinal date\" class ( date_time ), intent ( in ) :: self integer :: ordinal_days ordinal_days = d2o ( dt2d_ ( self )) end function ordinal !=================================================================================================================================== function weekday ( self ) result ( iday ) ! ident_10=\"@(#) M_time weekday(3f) convert derived type date_time to weekday (1=Monday 7=Sunday)\" class ( date_time ), intent ( in ) :: self integer :: iday integer :: ierr ! Error return,0=correct,-1=invalid Julian Date,-2=neither day nor weekday specified call dow ( dt2d_ ( self ), weekday = iday , ierr = ierr ) end function weekday !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function delta ( self , year , month , day , tz , hour , minute , second , millisecond , week , duration ) ! ! allow keyword addition and subtraction from each member of a date_time object ! even though there is no specific size for month and year, this is conventionally what is meant by \"a year from now\" ! or \"a month from now\". Once the arbitrary values are used to change the original date_time value convert it to ! Epoch time and back to make sure you get a valid date. ! ident_11=\"@(#) M_time delta(3f) add times to a type(date_time)\" class ( date_time ), intent ( in ) :: self integer , intent ( in ), optional :: year , month , day , tz , hour , minute , second , millisecond , week character ( len =* ), intent ( in ), optional :: duration type ( date_time ) :: delta delta = self if ( present ( year )) then ; delta % year = self % year + year ; else ; delta % year = self % year ; endif if ( present ( month )) then ; delta % month = self % month + month ; else ; delta % month = self % month ; endif if ( present ( day )) then ; delta % day = self % day + day ; else ; delta % day = self % day ; endif if ( present ( tz )) then ; delta % tz = self % tz + tz ; else ; delta % tz = self % tz ; endif if ( present ( hour )) then ; delta % hour = self % hour + hour ; else ; delta % hour = self % hour ; endif if ( present ( minute )) then ; delta % minute = self % minute + minute ; else ; delta % minute = self % minute ; endif if ( present ( second )) then ; delta % second = self % second + second ; else ; delta % second = self % second ; endif if ( present ( millisecond )) then ; delta % millisecond = self % millisecond + millisecond ; else ; delta % millisecond = self % millisecond ; endif if ( present ( week )) then ; delta % day = delta % day + week * 7 ; endif if ( present ( duration )) then ; delta % second = delta % second + int ( days2sec ( duration )) ; endif delta = construct_from_dat ( u2d ( d2u ( dt2d_ ( delta )))) ! to get a valid date after arbitrary math convert to Epoch and back end function delta !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine init_dt ( self , year , month , day , tz , hour , minute , second , millisecond , type , dat ) ! ! allow for date_time object to be initialized. Default is current time ! If the 8-element dat array is present use it to initialize the date_time object ! If not, initialize to the current time or start of epoch depending on TYPE=[\"now\"|\"epoch\"] ! Then, apply specific values, typically specified by keyword value ! ident_12=\"@(#) M_time init_dt(3f) initialize TYPE(DATE_TIME)\" class ( date_time ) :: self type ( date_time ) :: holddt integer , intent ( in ), optional :: year , month , day , tz , hour , minute , second , millisecond character ( len =* ), intent ( in ), optional :: type integer , intent ( in ), optional :: dat ( 8 ) character ( len = 10 ) :: typelocal integer :: datlocal ( 8 ) if ( present ( dat )) then holddt = construct_from_dat ( dat ) else if ( present ( type )) then typelocal = type else typelocal = \"now\" endif select case ( typelocal ) case ( \"now\" , \"NOW\" ) call date_and_time ( values = datlocal ) ! current time is placed in array using standard procedure holddt = construct_from_dat ( datlocal ) ! convert date array to date_time type case ( \"epoch\" , \"EPOCH\" ) holddt = construct_from_dat ([ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ]) case default call date_and_time ( values = datlocal ) ! current time is placed in array using standard procedure holddt = construct_from_dat ( datlocal ) ! convert date array to date_time type end select endif if ( present ( year )) holddt % year = year if ( present ( month )) holddt % month = month if ( present ( day )) holddt % day = day if ( present ( tz )) holddt % tz = tz if ( present ( hour )) holddt % hour = hour if ( present ( minute )) holddt % minute = minute if ( present ( second )) holddt % second = second if ( present ( millisecond )) holddt % millisecond = millisecond holddt = construct_from_dat ( u2d ( d2u ( dt2d_ ( holddt )))) ! to get a valid date after arbitrary values convert to Epoch and back self % year = holddt % year self % month = holddt % month self % day = holddt % day self % tz = holddt % tz self % hour = holddt % hour self % minute = holddt % minute self % second = holddt % second self % millisecond = holddt % millisecond end subroutine init_dt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! FUNCTIONS FOR DEFINING OVERLOADED OPERATORS !=================================================================================================================================== function plus_seconds ( self , seconds ) result ( dattim ) ! ident_13=\"@(#) M_time plus_seconds(3f) add derived type date_time object and seconds\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ), intent ( in ) :: seconds type ( date_time ) :: dattim ! convert TYPE(DATE_TIME) to a DAT array for input into d2u (DAT to UNIX time) and add seconds ! take the seconds (ie. the Unix Epoch time) and convert it back into a DAT array and call the ! construct_from_dat() function to convert the DAT array back to a TYPE(DATE_TIME) dattim = construct_from_dat ( u2d ( d2u ( dt2d_ ( self )) + seconds )) end function plus_seconds !=================================================================================================================================== function minus_seconds ( self , seconds ) result ( dattim ) ! ident_14=\"@(#) M_time minus_seconds(3f) subtract seconds from derived type date_time object\" class ( date_time ), intent ( in ) :: self real ( kind = realtime ), intent ( in ) :: seconds type ( date_time ) :: dattim dattim = construct_from_dat ( u2d ( d2u ( dt2d_ ( self )) - seconds )) end function minus_seconds !=================================================================================================================================== function minus_date_time ( self , other ) result ( seconds ) ! ident_15=\"@(#) M_time minus_date_time(3f) add derived type date_time object and seconds\" class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other real ( kind = realtime ) :: seconds seconds = d2u ( dt2d_ ( self )) - d2u ( dt2d_ ( other )) end function minus_date_time !=================================================================================================================================== ! ident_16=\"@(#) M_time eq(3f) compare derived type date_time objects (eq lt gt le ge ne)\" logical function eq ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other eq = int ( d2u ( dt2d_ ( self ))) == int ( d2u ( dt2d_ ( other ))) end function eq logical function lt ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other lt = int ( d2u ( dt2d_ ( self ))) < int ( d2u ( dt2d_ ( other ))) end function lt logical function gt ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other gt = int ( d2u ( dt2d_ ( self ))) > int ( d2u ( dt2d_ ( other ))) end function gt logical function le ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other le = int ( d2u ( dt2d_ ( self ))) <= int ( d2u ( dt2d_ ( other ))) end function le logical function ge ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other ge = int ( d2u ( dt2d_ ( self ))) >= int ( d2u ( dt2d_ ( other ))) end function ge logical function ne ( self , other ) class ( date_time ), intent ( in ) :: self type ( date_time ), intent ( in ) :: other ne = int ( d2u ( dt2d_ ( self ))) /= int ( d2u ( dt2d_ ( other ))) end function ne !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_time__oop","tags":"","url":"sourcefile/m_time__oop.f90.html"},{"title":"demo_d2j.f90 – M_time","text":"Source Code program demo_d2j use M_time , only : d2j implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Julian Date is ' , d2j ( dat ) end program demo_d2j","tags":"","url":"sourcefile/demo_d2j.f90.html"},{"title":"demo_sec2days.f90 – M_time","text":"Source Code program demo_sec2days use M_time , only : sec2days implicit none integer , parameter :: dp = kind ( 0.0d0 ) write ( * , * ) sec2days ( 129860 ) write ( * , * ) sec2days ( 8000 0.0_dp ) write ( * , * ) sec2days ( 8000 0.0 , crop = . true .) write ( * , * ) sec2days ( '1 day 2.0hr 100 min 300.0seconds' ) end program demo_sec2days","tags":"","url":"sourcefile/demo_sec2days.f90.html"},{"title":"demo_m2d.f90 – M_time","text":"Source Code program demo_m2d use M_time , only : m2d , d2m , fmtdate , realtime implicit none integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = realtime ) :: today integer :: dat ( 8 ) call date_and_time ( values = dat ) ! get the date using intrinsic today = d2m ( dat ) ! convert today to Julian Date write ( * , * ) 'Today=' , fmtdate ( m2d ( today )) ! math is easy with Julian Days and Julian Dates write ( * , * ) 'Yesterday=' , fmtdate ( m2d ( today - 1.0_dp )) write ( * , * ) 'Tomorrow=' , fmtdate ( m2d ( today + 1.0_dp )) end program demo_m2d","tags":"","url":"sourcefile/demo_m2d.f90.html"},{"title":"demo_d2m.f90 – M_time","text":"Source Code program demo_d2m use M_time , only : d2m , realtime implicit none integer :: dat ( 8 ) call date_and_time ( values = dat ) write ( * , '(\" Today is:\",*(i0:,\":\"))' ) dat write ( * , * ) 'Modified Julian Date is ' , d2m ( dat ) end program demo_d2m","tags":"","url":"sourcefile/demo_d2m.f90.html"},{"title":"demo_fmtdate_usage.f90 – M_time","text":"Source Code program demo_fmtdate_usage use M_time , only : fmtdate_usage implicit none call fmtdate_usage () ! see all formatting options end program demo_fmtdate_usage","tags":"","url":"sourcefile/demo_fmtdate_usage.f90.html"},{"title":"demo_o2d.f90 – M_time","text":"Source Code program demo_o2d use M_time , only : o2d , fmtdate implicit none integer :: year do year = 2004 , 2008 write ( * , '(*(g0))' )& & '100th day of ' , year , ' is ' , fmtdate ( o2d ( 100 , year )) enddo write ( * , '(*(g0))' ) '100th day of this year is ' , fmtdate ( o2d ( 100 )) end program demo_o2d","tags":"","url":"sourcefile/demo_o2d.f90.html"}]}